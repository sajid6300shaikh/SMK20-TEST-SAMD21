
SMK20 TEST SAMD21.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000295c  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000001c  20000000  0000295c  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000140  2000001c  00002978  0001001c  2**2
                  ALLOC
  3 .stack        00002004  2000015c  00002ab8  0001001c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0001001c  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010044  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001b6d3  00000000  00000000  0001009f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002c57  00000000  00000000  0002b772  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00005593  00000000  00000000  0002e3c9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000660  00000000  00000000  0003395c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000580  00000000  00000000  00033fbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001ab54  00000000  00000000  0003453c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000cb92  00000000  00000000  0004f090  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0008a8c5  00000000  00000000  0005bc22  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000010e0  00000000  00000000  000e64e8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20002160 	.word	0x20002160
       4:	00002239 	.word	0x00002239
       8:	00002235 	.word	0x00002235
       c:	00002235 	.word	0x00002235
	...
      2c:	00002235 	.word	0x00002235
	...
      38:	00002235 	.word	0x00002235
      3c:	00002235 	.word	0x00002235
      40:	00002235 	.word	0x00002235
      44:	00002235 	.word	0x00002235
      48:	00002235 	.word	0x00002235
      4c:	00002235 	.word	0x00002235
      50:	00002235 	.word	0x00002235
      54:	00002235 	.word	0x00002235
      58:	00002235 	.word	0x00002235
      5c:	00002235 	.word	0x00002235
      60:	00002235 	.word	0x00002235
      64:	00000d7d 	.word	0x00000d7d
      68:	00000d8d 	.word	0x00000d8d
      6c:	00000d9d 	.word	0x00000d9d
      70:	00000dad 	.word	0x00000dad
      74:	00000dbd 	.word	0x00000dbd
      78:	00000dcd 	.word	0x00000dcd
      7c:	00002235 	.word	0x00002235
      80:	00002235 	.word	0x00002235
      84:	00002235 	.word	0x00002235
      88:	00002235 	.word	0x00002235
      8c:	00002235 	.word	0x00002235
      90:	00002235 	.word	0x00002235
      94:	00002235 	.word	0x00002235
      98:	00002235 	.word	0x00002235
      9c:	00002235 	.word	0x00002235
      a0:	00002235 	.word	0x00002235
      a4:	00002235 	.word	0x00002235
      a8:	00002235 	.word	0x00002235
      ac:	00002235 	.word	0x00002235

000000b0 <__do_global_dtors_aux>:
      b0:	b510      	push	{r4, lr}
      b2:	4c06      	ldr	r4, [pc, #24]	; (cc <__do_global_dtors_aux+0x1c>)
      b4:	7823      	ldrb	r3, [r4, #0]
      b6:	2b00      	cmp	r3, #0
      b8:	d107      	bne.n	ca <__do_global_dtors_aux+0x1a>
      ba:	4b05      	ldr	r3, [pc, #20]	; (d0 <__do_global_dtors_aux+0x20>)
      bc:	2b00      	cmp	r3, #0
      be:	d002      	beq.n	c6 <__do_global_dtors_aux+0x16>
      c0:	4804      	ldr	r0, [pc, #16]	; (d4 <__do_global_dtors_aux+0x24>)
      c2:	e000      	b.n	c6 <__do_global_dtors_aux+0x16>
      c4:	bf00      	nop
      c6:	2301      	movs	r3, #1
      c8:	7023      	strb	r3, [r4, #0]
      ca:	bd10      	pop	{r4, pc}
      cc:	2000001c 	.word	0x2000001c
      d0:	00000000 	.word	0x00000000
      d4:	0000295c 	.word	0x0000295c

000000d8 <frame_dummy>:
      d8:	b508      	push	{r3, lr}
      da:	4b08      	ldr	r3, [pc, #32]	; (fc <frame_dummy+0x24>)
      dc:	2b00      	cmp	r3, #0
      de:	d003      	beq.n	e8 <frame_dummy+0x10>
      e0:	4807      	ldr	r0, [pc, #28]	; (100 <frame_dummy+0x28>)
      e2:	4908      	ldr	r1, [pc, #32]	; (104 <frame_dummy+0x2c>)
      e4:	e000      	b.n	e8 <frame_dummy+0x10>
      e6:	bf00      	nop
      e8:	4807      	ldr	r0, [pc, #28]	; (108 <frame_dummy+0x30>)
      ea:	6803      	ldr	r3, [r0, #0]
      ec:	2b00      	cmp	r3, #0
      ee:	d003      	beq.n	f8 <frame_dummy+0x20>
      f0:	4b06      	ldr	r3, [pc, #24]	; (10c <frame_dummy+0x34>)
      f2:	2b00      	cmp	r3, #0
      f4:	d000      	beq.n	f8 <frame_dummy+0x20>
      f6:	4798      	blx	r3
      f8:	bd08      	pop	{r3, pc}
      fa:	46c0      	nop			; (mov r8, r8)
      fc:	00000000 	.word	0x00000000
     100:	0000295c 	.word	0x0000295c
     104:	20000020 	.word	0x20000020
     108:	0000295c 	.word	0x0000295c
     10c:	00000000 	.word	0x00000000

00000110 <i2c_master_init>:
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
				packet->data[counter++] = i2c_module->DATA.reg;
				/* Wait for response. */
				tmp_status = _i2c_master_wait_for_bus(module);
     110:	b5f0      	push	{r4, r5, r6, r7, lr}
			if (tmp_status != STATUS_OK) {
				break;
			}
		}

		if (module->send_stop) {
     112:	4647      	mov	r7, r8
     114:	b480      	push	{r7}
     116:	b082      	sub	sp, #8
			/* Send stop command unless arbitration is lost. */
			_i2c_master_wait_for_sync(module);
     118:	1c07      	adds	r7, r0, #0
     11a:	1c0c      	adds	r4, r1, #0
     11c:	1c15      	adds	r5, r2, #0
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
     11e:	6039      	str	r1, [r7, #0]
     120:	1c08      	adds	r0, r1, #0
     122:	4b5d      	ldr	r3, [pc, #372]	; (298 <i2c_master_init+0x188>)
     124:	4798      	blx	r3
     126:	1c06      	adds	r6, r0, #0
		}

		/* Save last data to buffer. */
		_i2c_master_wait_for_sync(module);
     128:	4b5c      	ldr	r3, [pc, #368]	; (29c <i2c_master_init+0x18c>)
     12a:	6a19      	ldr	r1, [r3, #32]
     12c:	1c82      	adds	r2, r0, #2
		packet->data[counter] = i2c_module->DATA.reg;
     12e:	2001      	movs	r0, #1
     130:	4090      	lsls	r0, r2
     132:	1c02      	adds	r2, r0, #0
     134:	430a      	orrs	r2, r1
     136:	621a      	str	r2, [r3, #32]
     138:	a901      	add	r1, sp, #4
     13a:	7b2b      	ldrb	r3, [r5, #12]
	if (tmp_status == STATUS_OK) {
		/* Read data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
				return STATUS_ERR_PACKET_COLLISION;
     13c:	700b      	strb	r3, [r1, #0]
		_i2c_master_wait_for_sync(module);
		packet->data[counter] = i2c_module->DATA.reg;
	}

	return tmp_status;
}
     13e:	3614      	adds	r6, #20
     140:	b2f6      	uxtb	r6, r6
     142:	1c30      	adds	r0, r6, #0
     144:	4b56      	ldr	r3, [pc, #344]	; (2a0 <i2c_master_init+0x190>)
     146:	4798      	blx	r3
     148:	1c30      	adds	r0, r6, #0
     14a:	4b56      	ldr	r3, [pc, #344]	; (2a4 <i2c_master_init+0x194>)
     14c:	4798      	blx	r3
     14e:	7b28      	ldrb	r0, [r5, #12]
     150:	2100      	movs	r1, #0
     152:	4b55      	ldr	r3, [pc, #340]	; (2a8 <i2c_master_init+0x198>)
     154:	4798      	blx	r3
     156:	6823      	ldr	r3, [r4, #0]
     158:	201c      	movs	r0, #28
     15a:	0799      	lsls	r1, r3, #30
     15c:	d500      	bpl.n	160 <i2c_master_init+0x50>
     15e:	e097      	b.n	290 <i2c_master_init+0x180>
     160:	6823      	ldr	r3, [r4, #0]
     162:	2005      	movs	r0, #5
     164:	07da      	lsls	r2, r3, #31
     166:	d500      	bpl.n	16a <i2c_master_init+0x5a>
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
		return STATUS_ERR_DENIED;
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
     168:	e092      	b.n	290 <i2c_master_init+0x180>
	module->status = STATUS_OK;
	module->buffer = NULL;
#endif

	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);
     16a:	2314      	movs	r3, #20
     16c:	6023      	str	r3, [r4, #0]
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     16e:	683c      	ldr	r4, [r7, #0]
	Sercom *const sercom_hw = module->hw;

	uint8_t sercom_index = _sercom_get_sercom_inst_index(sercom_hw);
     170:	1c20      	adds	r0, r4, #0
     172:	4b49      	ldr	r3, [pc, #292]	; (298 <i2c_master_init+0x188>)
     174:	4798      	blx	r3
     176:	4680      	mov	r8, r0
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     178:	2380      	movs	r3, #128	; 0x80
     17a:	4669      	mov	r1, sp
     17c:	700b      	strb	r3, [r1, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
     17e:	2300      	movs	r3, #0
     180:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
     182:	2201      	movs	r2, #1
     184:	708a      	strb	r2, [r1, #2]
	config->powersave    = false;
     186:	70cb      	strb	r3, [r1, #3]

	/* Pin configuration */
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);

	uint32_t pad0 = config->pinmux_pad0;
     188:	69e8      	ldr	r0, [r5, #28]
	uint32_t pad1 = config->pinmux_pad1;
     18a:	6a2e      	ldr	r6, [r5, #32]

	/* SERCOM PAD0 - SDA */
	if (pad0 == PINMUX_DEFAULT) {
     18c:	2800      	cmp	r0, #0
     18e:	d103      	bne.n	198 <i2c_master_init+0x88>
		pad0 = _sercom_get_default_pad(sercom_hw, 0);
     190:	1c20      	adds	r0, r4, #0
     192:	2100      	movs	r1, #0
     194:	4b45      	ldr	r3, [pc, #276]	; (2ac <i2c_master_init+0x19c>)
     196:	4798      	blx	r3
	}
	pin_conf.mux_position = pad0 & 0xFFFF;
     198:	466a      	mov	r2, sp
     19a:	7010      	strb	r0, [r2, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
     19c:	2202      	movs	r2, #2
     19e:	466b      	mov	r3, sp
     1a0:	705a      	strb	r2, [r3, #1]
	system_pinmux_pin_set_config(pad0 >> 16, &pin_conf);
     1a2:	0c03      	lsrs	r3, r0, #16
     1a4:	b2d8      	uxtb	r0, r3
     1a6:	4669      	mov	r1, sp
     1a8:	4b41      	ldr	r3, [pc, #260]	; (2b0 <i2c_master_init+0x1a0>)
     1aa:	4798      	blx	r3

	/* SERCOM PAD1 - SCL */
	if (pad1 == PINMUX_DEFAULT) {
     1ac:	2e00      	cmp	r6, #0
     1ae:	d104      	bne.n	1ba <i2c_master_init+0xaa>
		pad1 = _sercom_get_default_pad(sercom_hw, 1);
     1b0:	1c20      	adds	r0, r4, #0
     1b2:	2101      	movs	r1, #1
     1b4:	4b3d      	ldr	r3, [pc, #244]	; (2ac <i2c_master_init+0x19c>)
     1b6:	4798      	blx	r3
     1b8:	1c06      	adds	r6, r0, #0
	}
	pin_conf.mux_position = pad1 & 0xFFFF;
     1ba:	4669      	mov	r1, sp
     1bc:	700e      	strb	r6, [r1, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
     1be:	2302      	movs	r3, #2
     1c0:	704b      	strb	r3, [r1, #1]
	system_pinmux_pin_set_config(pad1 >> 16, &pin_conf);
     1c2:	0c36      	lsrs	r6, r6, #16
     1c4:	b2f0      	uxtb	r0, r6
     1c6:	4b3a      	ldr	r3, [pc, #232]	; (2b0 <i2c_master_init+0x1a0>)
     1c8:	4798      	blx	r3

	/* Save timeout on unknown bus state in software module. */
	module->unknown_bus_state_timeout = config->unknown_bus_state_timeout;
     1ca:	8aab      	ldrh	r3, [r5, #20]
     1cc:	80fb      	strh	r3, [r7, #6]

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;
     1ce:	8aeb      	ldrh	r3, [r5, #22]
     1d0:	813b      	strh	r3, [r7, #8]

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
     1d2:	7e2a      	ldrb	r2, [r5, #24]
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
     1d4:	2380      	movs	r3, #128	; 0x80

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
     1d6:	2a00      	cmp	r2, #0
     1d8:	d104      	bne.n	1e4 <i2c_master_init+0xd4>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
     1da:	4b36      	ldr	r3, [pc, #216]	; (2b4 <i2c_master_init+0x1a4>)
     1dc:	789b      	ldrb	r3, [r3, #2]
     1de:	079b      	lsls	r3, r3, #30
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
	} else {
		tmp_ctrla = 0;
     1e0:	0fdb      	lsrs	r3, r3, #31
     1e2:	01db      	lsls	r3, r3, #7
	}

	/* Check and set start data hold timeout. */
	if (config->start_hold_time != I2C_MASTER_START_HOLD_TIME_DISABLED) {
     1e4:	692a      	ldr	r2, [r5, #16]
     1e6:	2a00      	cmp	r2, #0
     1e8:	d000      	beq.n	1ec <i2c_master_init+0xdc>
		tmp_ctrla |= config->start_hold_time;
     1ea:	4313      	orrs	r3, r2
	}

	/* Check and set transfer speed */
	tmp_ctrla |= config->transfer_speed;
     1ec:	68aa      	ldr	r2, [r5, #8]
     1ee:	4313      	orrs	r3, r2

	/* Check and set SCL low timeout. */
	if (config->scl_low_timeout) {
     1f0:	2224      	movs	r2, #36	; 0x24
     1f2:	5caa      	ldrb	r2, [r5, r2]
     1f4:	2a00      	cmp	r2, #0
     1f6:	d002      	beq.n	1fe <i2c_master_init+0xee>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_LOWTOUTEN;
     1f8:	2280      	movs	r2, #128	; 0x80
     1fa:	05d2      	lsls	r2, r2, #23
     1fc:	4313      	orrs	r3, r2
	}

	/* Check and set inactive bus timeout. */
	if (config->inactive_timeout != I2C_MASTER_INACTIVE_TIMEOUT_DISABLED) {
     1fe:	6aaa      	ldr	r2, [r5, #40]	; 0x28
     200:	2a00      	cmp	r2, #0
     202:	d000      	beq.n	206 <i2c_master_init+0xf6>
		tmp_ctrla |= config->inactive_timeout;
     204:	4313      	orrs	r3, r2
	}

	/* Check and set SCL clock stretch mode. */
	if (config->scl_stretch_only_after_ack_bit) {
     206:	222c      	movs	r2, #44	; 0x2c
     208:	5caa      	ldrb	r2, [r5, r2]
     20a:	2a00      	cmp	r2, #0
     20c:	d002      	beq.n	214 <i2c_master_init+0x104>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SCLSM;
     20e:	2280      	movs	r2, #128	; 0x80
     210:	0512      	lsls	r2, r2, #20
     212:	4313      	orrs	r3, r2
	}

	/* Check and set slave SCL low extend timeout. */
	if (config->slave_scl_low_extend_timeout) {
     214:	222d      	movs	r2, #45	; 0x2d
     216:	5caa      	ldrb	r2, [r5, r2]
     218:	2a00      	cmp	r2, #0
     21a:	d002      	beq.n	222 <i2c_master_init+0x112>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SEXTTOEN;
     21c:	2280      	movs	r2, #128	; 0x80
     21e:	0412      	lsls	r2, r2, #16
     220:	4313      	orrs	r3, r2
	}

	/* Check and set master SCL low extend timeout. */
	if (config->master_scl_low_extend_timeout) {
     222:	222e      	movs	r2, #46	; 0x2e
     224:	5caa      	ldrb	r2, [r5, r2]
     226:	2a00      	cmp	r2, #0
     228:	d002      	beq.n	230 <i2c_master_init+0x120>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_MEXTTOEN;
     22a:	2280      	movs	r2, #128	; 0x80
     22c:	03d2      	lsls	r2, r2, #15
     22e:	4313      	orrs	r3, r2
	}

	/* Write config to register CTRLA. */
	i2c_module->CTRLA.reg |= tmp_ctrla;
     230:	6822      	ldr	r2, [r4, #0]
     232:	4313      	orrs	r3, r2
     234:	6023      	str	r3, [r4, #0]

	/* Set configurations in CTRLB. */
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
     236:	2380      	movs	r3, #128	; 0x80
     238:	005b      	lsls	r3, r3, #1
     23a:	6063      	str	r3, [r4, #4]

	/* Find and set baudrate. */
	tmp_baud = (int32_t)(div_ceil(
     23c:	4646      	mov	r6, r8
     23e:	3614      	adds	r6, #20
     240:	b2f6      	uxtb	r6, r6
     242:	1c30      	adds	r0, r6, #0
     244:	4b1c      	ldr	r3, [pc, #112]	; (2b8 <i2c_master_init+0x1a8>)
     246:	4798      	blx	r3
     248:	21fa      	movs	r1, #250	; 0xfa
     24a:	00c9      	lsls	r1, r1, #3
     24c:	682b      	ldr	r3, [r5, #0]
     24e:	4359      	muls	r1, r3
     250:	1e4b      	subs	r3, r1, #1
     252:	1818      	adds	r0, r3, r0
     254:	4b19      	ldr	r3, [pc, #100]	; (2bc <i2c_master_init+0x1ac>)
     256:	4798      	blx	r3
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate))) - 5);
     258:	1f47      	subs	r7, r0, #5

	/* Check that baudrate is supported at current speed. */
	if (tmp_baud > 255 || tmp_baud < 0) {
     25a:	2fff      	cmp	r7, #255	; 0xff
     25c:	d80d      	bhi.n	27a <i2c_master_init+0x16a>
		/* Baud rate not supported. */
		tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		/* Find baudrate for high speed */
		tmp_baud_hs = (int32_t)(div_ceil(
     25e:	1c30      	adds	r0, r6, #0
     260:	4b15      	ldr	r3, [pc, #84]	; (2b8 <i2c_master_init+0x1a8>)
     262:	4798      	blx	r3
     264:	686b      	ldr	r3, [r5, #4]
     266:	21fa      	movs	r1, #250	; 0xfa
     268:	00c9      	lsls	r1, r1, #3
     26a:	4359      	muls	r1, r3
     26c:	1e4b      	subs	r3, r1, #1
     26e:	1818      	adds	r0, r3, r0
     270:	4b12      	ldr	r3, [pc, #72]	; (2bc <i2c_master_init+0x1ac>)
     272:	4798      	blx	r3
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate_high_speed))) - 1);
     274:	3801      	subs	r0, #1

		/* Check that baudrate is supported at current speed. */
		if (tmp_baud_hs > 255 || tmp_baud_hs < 0) {
     276:	28ff      	cmp	r0, #255	; 0xff
     278:	d901      	bls.n	27e <i2c_master_init+0x16e>
	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
     27a:	2040      	movs	r0, #64	; 0x40
     27c:	e008      	b.n	290 <i2c_master_init+0x180>
		}
	}
	if (tmp_status_code != STATUS_ERR_BAUDRATE_UNAVAILABLE) {
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
			SERCOM_I2CM_BAUD_HSBAUD(tmp_baud_hs);
     27e:	0400      	lsls	r0, r0, #16
     280:	23ff      	movs	r3, #255	; 0xff
     282:	041b      	lsls	r3, r3, #16
     284:	4018      	ands	r0, r3
			tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
	}
	if (tmp_status_code != STATUS_ERR_BAUDRATE_UNAVAILABLE) {
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
     286:	23ff      	movs	r3, #255	; 0xff
     288:	401f      	ands	r7, r3
     28a:	4307      	orrs	r7, r0
     28c:	60e7      	str	r7, [r4, #12]

	/* Temporary variables. */
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;
     28e:	2000      	movs	r0, #0
	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);

	/* Set config and return status. */
	return _i2c_master_set_config(module, config);
}
     290:	b002      	add	sp, #8
     292:	bc04      	pop	{r2}
     294:	4690      	mov	r8, r2
     296:	bdf0      	pop	{r4, r5, r6, r7, pc}
     298:	00000d41 	.word	0x00000d41
     29c:	40000400 	.word	0x40000400
     2a0:	00002105 	.word	0x00002105
     2a4:	00002079 	.word	0x00002079
     2a8:	00000b69 	.word	0x00000b69
     2ac:	00000bb9 	.word	0x00000bb9
     2b0:	000021e1 	.word	0x000021e1
     2b4:	41002000 	.word	0x41002000
     2b8:	00002121 	.word	0x00002121
     2bc:	000024b1 	.word	0x000024b1

000002c0 <Cal_Disp2Points>:
	{"10.Gaseous Flow    "},	//9
};



void Cal_Disp2Points(volatile nAZSensors *Sensor){
     2c0:	b5f0      	push	{r4, r5, r6, r7, lr}
     2c2:	b083      	sub	sp, #12
     2c4:	1c05      	adds	r5, r0, #0
	//Lower Count
	LCD_DispVariable(Sensor->ADCLower,0,5,3,7);
     2c6:	6840      	ldr	r0, [r0, #4]
     2c8:	2707      	movs	r7, #7
     2ca:	9700      	str	r7, [sp, #0]
     2cc:	2100      	movs	r1, #0
     2ce:	2205      	movs	r2, #5
     2d0:	2303      	movs	r3, #3
     2d2:	4c0d      	ldr	r4, [pc, #52]	; (308 <Cal_Disp2Points+0x48>)
     2d4:	47a0      	blx	r4
	//STD LOWER
	LCD_DispVariable(Sensor->STDLower,0,3,3,18);
     2d6:	8928      	ldrh	r0, [r5, #8]
     2d8:	b280      	uxth	r0, r0
     2da:	2612      	movs	r6, #18
     2dc:	9600      	str	r6, [sp, #0]
     2de:	2100      	movs	r1, #0
     2e0:	2203      	movs	r2, #3
     2e2:	2303      	movs	r3, #3
     2e4:	47a0      	blx	r4
	
	//Upper Count
	LCD_DispVariable(Sensor->ADCUpper, 0,5,4,7);
     2e6:	8968      	ldrh	r0, [r5, #10]
     2e8:	b280      	uxth	r0, r0
     2ea:	9700      	str	r7, [sp, #0]
     2ec:	2100      	movs	r1, #0
     2ee:	2205      	movs	r2, #5
     2f0:	2304      	movs	r3, #4
     2f2:	47a0      	blx	r4
	
	//Std Upper
	LCD_DispVariable(Sensor->STDUpper,0,3,4,18);
     2f4:	89a8      	ldrh	r0, [r5, #12]
     2f6:	b280      	uxth	r0, r0
     2f8:	9600      	str	r6, [sp, #0]
     2fa:	2100      	movs	r1, #0
     2fc:	2203      	movs	r2, #3
     2fe:	2304      	movs	r3, #4
     300:	47a0      	blx	r4
};
     302:	b003      	add	sp, #12
     304:	bdf0      	pop	{r4, r5, r6, r7, pc}
     306:	46c0      	nop			; (mov r8, r8)
     308:	000006d9 	.word	0x000006d9

0000030c <Cal_AbsEdit>:
	
	RETWoSaving:
	return;
}

void Cal_AbsEdit(void){		//Absolute Pres Edit Cal
     30c:	b510      	push	{r4, lr}
     30e:	b082      	sub	sp, #8
	int32_t EnteredData=0;
	Cal_Disp2Points(&Absolute_Pres);
     310:	4c1d      	ldr	r4, [pc, #116]	; (388 <Cal_AbsEdit+0x7c>)
     312:	1c20      	adds	r0, r4, #0
     314:	4b1d      	ldr	r3, [pc, #116]	; (38c <Cal_AbsEdit+0x80>)
     316:	4798      	blx	r3
	EnteredData=GetNumDataFromUserWithESC(Absolute_Pres.ADCLower,0,5,3,7);
     318:	6860      	ldr	r0, [r4, #4]
     31a:	2307      	movs	r3, #7
     31c:	9300      	str	r3, [sp, #0]
     31e:	2100      	movs	r1, #0
     320:	2205      	movs	r2, #5
     322:	2303      	movs	r3, #3
     324:	4c1a      	ldr	r4, [pc, #104]	; (390 <Cal_AbsEdit+0x84>)
     326:	47a0      	blx	r4
	if (EnteredData==-1)	//ESC key is pressed
     328:	1c43      	adds	r3, r0, #1
     32a:	d02b      	beq.n	384 <Cal_AbsEdit+0x78>
	goto RETWoSaving;
	else
	{	//ENTER KEY IS PRESSED, save value in EEP
		Absolute_Pres.ADCLower=EnteredData;	//store ADC lower Data in respective sensors variable
     32c:	4b16      	ldr	r3, [pc, #88]	; (388 <Cal_AbsEdit+0x7c>)
     32e:	6058      	str	r0, [r3, #4]
		
	}
	
	
	EnteredData=GetNumDataFromUserWithESC(Absolute_Pres.STDLower, 0, 3, 3,18);
     330:	8918      	ldrh	r0, [r3, #8]
     332:	b280      	uxth	r0, r0
     334:	2312      	movs	r3, #18
     336:	9300      	str	r3, [sp, #0]
     338:	2100      	movs	r1, #0
     33a:	2203      	movs	r2, #3
     33c:	2303      	movs	r3, #3
     33e:	4c14      	ldr	r4, [pc, #80]	; (390 <Cal_AbsEdit+0x84>)
     340:	47a0      	blx	r4
	if (EnteredData==-1)
     342:	1c43      	adds	r3, r0, #1
     344:	d01e      	beq.n	384 <Cal_AbsEdit+0x78>
	goto RETWoSaving;
	else
	{
		Absolute_Pres.STDLower=EnteredData;	//Store Std Lower Data
     346:	b280      	uxth	r0, r0
     348:	4b0f      	ldr	r3, [pc, #60]	; (388 <Cal_AbsEdit+0x7c>)
     34a:	8118      	strh	r0, [r3, #8]
	}
	EnteredData=GetNumDataFromUserWithESC(Absolute_Pres.ADCUpper, 0, 5, 4, 7);
     34c:	8958      	ldrh	r0, [r3, #10]
     34e:	b280      	uxth	r0, r0
     350:	2307      	movs	r3, #7
     352:	9300      	str	r3, [sp, #0]
     354:	2100      	movs	r1, #0
     356:	2205      	movs	r2, #5
     358:	2304      	movs	r3, #4
     35a:	4c0d      	ldr	r4, [pc, #52]	; (390 <Cal_AbsEdit+0x84>)
     35c:	47a0      	blx	r4
	if (EnteredData==-1)
     35e:	1c43      	adds	r3, r0, #1
     360:	d010      	beq.n	384 <Cal_AbsEdit+0x78>
	goto RETWoSaving;
	else
	{
		Absolute_Pres.ADCUpper=EnteredData;	//store ADCUpper counts
     362:	b280      	uxth	r0, r0
     364:	4b08      	ldr	r3, [pc, #32]	; (388 <Cal_AbsEdit+0x7c>)
     366:	8158      	strh	r0, [r3, #10]
	}
	
	EnteredData=GetNumDataFromUserWithESC(Absolute_Pres.STDUpper, 0, 3, 4, 18);
     368:	8998      	ldrh	r0, [r3, #12]
     36a:	b280      	uxth	r0, r0
     36c:	2312      	movs	r3, #18
     36e:	9300      	str	r3, [sp, #0]
     370:	2100      	movs	r1, #0
     372:	2203      	movs	r2, #3
     374:	2304      	movs	r3, #4
     376:	4c06      	ldr	r4, [pc, #24]	; (390 <Cal_AbsEdit+0x84>)
     378:	47a0      	blx	r4
	if (EnteredData==-1)
     37a:	1c43      	adds	r3, r0, #1
     37c:	d002      	beq.n	384 <Cal_AbsEdit+0x78>
	goto RETWoSaving;
	else
	{
		Absolute_Pres.STDUpper=EnteredData;	//store StdUpper counts
     37e:	b280      	uxth	r0, r0
     380:	4b01      	ldr	r3, [pc, #4]	; (388 <Cal_AbsEdit+0x7c>)
     382:	8198      	strh	r0, [r3, #12]
	}
	
	RETWoSaving:
	return;
}
     384:	b002      	add	sp, #8
     386:	bd10      	pop	{r4, pc}
     388:	20000108 	.word	0x20000108
     38c:	000002c1 	.word	0x000002c1
     390:	000009cd 	.word	0x000009cd

00000394 <Calibrate_AbsPres>:

void Calibrate_AbsPres(void){
     394:	b5f0      	push	{r4, r5, r6, r7, lr}
     396:	4647      	mov	r7, r8
     398:	b480      	push	{r7}
     39a:	b084      	sub	sp, #16
	
	int8_t SelOpt=0;
	do
	{
		LCD_FullDisp(	"  Calibration of:   ",
     39c:	4f21      	ldr	r7, [pc, #132]	; (424 <Calibrate_AbsPres+0x90>)
     39e:	4e22      	ldr	r6, [pc, #136]	; (428 <Calibrate_AbsPres+0x94>)
     3a0:	4b22      	ldr	r3, [pc, #136]	; (42c <Calibrate_AbsPres+0x98>)
     3a2:	4698      	mov	r8, r3
     3a4:	1c38      	adds	r0, r7, #0
     3a6:	1c31      	adds	r1, r6, #0
     3a8:	4642      	mov	r2, r8
     3aa:	4b21      	ldr	r3, [pc, #132]	; (430 <Calibrate_AbsPres+0x9c>)
     3ac:	4c21      	ldr	r4, [pc, #132]	; (434 <Calibrate_AbsPres+0xa0>)
     3ae:	47a0      	blx	r4
		" Absolute Pressure  ",
		"Scan / Edit /Execute",
		"                    ");
		SelOpt =LCD_HorizontalScroll(1, 3,1,3,8,3,14);
     3b0:	2308      	movs	r3, #8
     3b2:	9300      	str	r3, [sp, #0]
     3b4:	2303      	movs	r3, #3
     3b6:	9301      	str	r3, [sp, #4]
     3b8:	230e      	movs	r3, #14
     3ba:	9302      	str	r3, [sp, #8]
     3bc:	2001      	movs	r0, #1
     3be:	2103      	movs	r1, #3
     3c0:	2201      	movs	r2, #1
     3c2:	2303      	movs	r3, #3
     3c4:	4c1c      	ldr	r4, [pc, #112]	; (438 <Calibrate_AbsPres+0xa4>)
     3c6:	47a0      	blx	r4
     3c8:	b2c4      	uxtb	r4, r0
		ReleaseKey();
     3ca:	4b1c      	ldr	r3, [pc, #112]	; (43c <Calibrate_AbsPres+0xa8>)
     3cc:	4798      	blx	r3
		if (SelOpt==1)
     3ce:	2c01      	cmp	r4, #1
     3d0:	d10d      	bne.n	3ee <Calibrate_AbsPres+0x5a>
		{	//Scan mode selected.
			LCD_FullDisp(	"Scan Mode: Abs.Pres.",
     3d2:	481b      	ldr	r0, [pc, #108]	; (440 <Calibrate_AbsPres+0xac>)
     3d4:	491b      	ldr	r1, [pc, #108]	; (444 <Calibrate_AbsPres+0xb0>)
     3d6:	4a1c      	ldr	r2, [pc, #112]	; (448 <Calibrate_AbsPres+0xb4>)
     3d8:	4b1c      	ldr	r3, [pc, #112]	; (44c <Calibrate_AbsPres+0xb8>)
     3da:	4d16      	ldr	r5, [pc, #88]	; (434 <Calibrate_AbsPres+0xa0>)
     3dc:	47a8      	blx	r5
			"Calibration(in mmHg)",
			"Lower:       Std:   ",
			"Upper:       Std:   ");
			//display the calibration values.
			Cal_Disp2Points(&Absolute_Pres);
     3de:	481c      	ldr	r0, [pc, #112]	; (450 <Calibrate_AbsPres+0xbc>)
     3e0:	4b1c      	ldr	r3, [pc, #112]	; (454 <Calibrate_AbsPres+0xc0>)
     3e2:	4798      	blx	r3
			WaitforAnyKey();
     3e4:	4b1c      	ldr	r3, [pc, #112]	; (458 <Calibrate_AbsPres+0xc4>)
     3e6:	4798      	blx	r3
			ReleaseKey();
     3e8:	4b14      	ldr	r3, [pc, #80]	; (43c <Calibrate_AbsPres+0xa8>)
     3ea:	4798      	blx	r3
     3ec:	e013      	b.n	416 <Calibrate_AbsPres+0x82>
		}
		
		if (SelOpt==2)
     3ee:	2c02      	cmp	r4, #2
     3f0:	d108      	bne.n	404 <Calibrate_AbsPres+0x70>
		{
			LCD_FullDisp(	"Scan Mode: Abs.Pres.",
     3f2:	4813      	ldr	r0, [pc, #76]	; (440 <Calibrate_AbsPres+0xac>)
     3f4:	4913      	ldr	r1, [pc, #76]	; (444 <Calibrate_AbsPres+0xb0>)
     3f6:	4a14      	ldr	r2, [pc, #80]	; (448 <Calibrate_AbsPres+0xb4>)
     3f8:	4b14      	ldr	r3, [pc, #80]	; (44c <Calibrate_AbsPres+0xb8>)
     3fa:	4c0e      	ldr	r4, [pc, #56]	; (434 <Calibrate_AbsPres+0xa0>)
     3fc:	47a0      	blx	r4
			"Calibration(in mmHg)",
			"Lower:       Std:   ",
			"Upper:       Std:   ");
			Cal_AbsEdit();
     3fe:	4b17      	ldr	r3, [pc, #92]	; (45c <Calibrate_AbsPres+0xc8>)
     400:	4798      	blx	r3
     402:	e7cf      	b.n	3a4 <Calibrate_AbsPres+0x10>
		}
		
		if (SelOpt==3)
     404:	2c03      	cmp	r4, #3
     406:	d106      	bne.n	416 <Calibrate_AbsPres+0x82>
		{
			LCD_OneLine(2,"ONLINE NOT IMPLEMENT");
     408:	2002      	movs	r0, #2
     40a:	4915      	ldr	r1, [pc, #84]	; (460 <Calibrate_AbsPres+0xcc>)
     40c:	4b15      	ldr	r3, [pc, #84]	; (464 <Calibrate_AbsPres+0xd0>)
     40e:	4798      	blx	r3
			AnykeyPulse();
     410:	4b15      	ldr	r3, [pc, #84]	; (468 <Calibrate_AbsPres+0xd4>)
     412:	4798      	blx	r3
     414:	e7c6      	b.n	3a4 <Calibrate_AbsPres+0x10>
		}
	} while (SelOpt);
     416:	2c00      	cmp	r4, #0
     418:	d1c4      	bne.n	3a4 <Calibrate_AbsPres+0x10>
}
     41a:	b004      	add	sp, #16
     41c:	bc04      	pop	{r2}
     41e:	4690      	mov	r8, r2
     420:	bdf0      	pop	{r4, r5, r6, r7, pc}
     422:	46c0      	nop			; (mov r8, r8)
     424:	00002664 	.word	0x00002664
     428:	0000267c 	.word	0x0000267c
     42c:	00002694 	.word	0x00002694
     430:	000026ac 	.word	0x000026ac
     434:	00000fc5 	.word	0x00000fc5
     438:	000014c9 	.word	0x000014c9
     43c:	00001851 	.word	0x00001851
     440:	000026c4 	.word	0x000026c4
     444:	000026dc 	.word	0x000026dc
     448:	000026f4 	.word	0x000026f4
     44c:	0000270c 	.word	0x0000270c
     450:	20000108 	.word	0x20000108
     454:	000002c1 	.word	0x000002c1
     458:	00001871 	.word	0x00001871
     45c:	0000030d 	.word	0x0000030d
     460:	00002724 	.word	0x00002724
     464:	00001005 	.word	0x00001005
     468:	00001891 	.word	0x00001891

0000046c <DoCalibration>:

void DoCalibration(){
     46c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int8_t selected=0;
	LCD_CursorOff();
     46e:	4b0f      	ldr	r3, [pc, #60]	; (4ac <DoCalibration+0x40>)
     470:	4798      	blx	r3
	do
	{
		selected =LCD_MenuHandle(MenuSize(CalibrationMenu),CalibrationMenu);
     472:	4f0f      	ldr	r7, [pc, #60]	; (4b0 <DoCalibration+0x44>)
     474:	4e0f      	ldr	r6, [pc, #60]	; (4b4 <DoCalibration+0x48>)
		
		switch(selected){
			case 1:
			Calibrate_AbsPres();
     476:	4d10      	ldr	r5, [pc, #64]	; (4b8 <DoCalibration+0x4c>)
void DoCalibration(){
	int8_t selected=0;
	LCD_CursorOff();
	do
	{
		selected =LCD_MenuHandle(MenuSize(CalibrationMenu),CalibrationMenu);
     478:	200a      	movs	r0, #10
     47a:	1c39      	adds	r1, r7, #0
     47c:	47b0      	blx	r6
     47e:	b2c4      	uxtb	r4, r0
		
		switch(selected){
     480:	2c01      	cmp	r4, #1
     482:	d009      	beq.n	498 <DoCalibration+0x2c>
     484:	b263      	sxtb	r3, r4
     486:	2b01      	cmp	r3, #1
     488:	dc02      	bgt.n	490 <DoCalibration+0x24>
     48a:	2c00      	cmp	r4, #0
     48c:	d00a      	beq.n	4a4 <DoCalibration+0x38>
     48e:	e005      	b.n	49c <DoCalibration+0x30>
     490:	b263      	sxtb	r3, r4
     492:	2b0a      	cmp	r3, #10
     494:	dc02      	bgt.n	49c <DoCalibration+0x30>
     496:	e005      	b.n	4a4 <DoCalibration+0x38>
			case 1:
			Calibrate_AbsPres();
     498:	47a8      	blx	r5
     49a:	e7ed      	b.n	478 <DoCalibration+0xc>
			//		Calibrate_GasFlow();
			break;
			case 0:
			break;
			default:
			LCD_OneLine(2,"Invalid Cal Option");
     49c:	2002      	movs	r0, #2
     49e:	4907      	ldr	r1, [pc, #28]	; (4bc <DoCalibration+0x50>)
     4a0:	4b07      	ldr	r3, [pc, #28]	; (4c0 <DoCalibration+0x54>)
     4a2:	4798      	blx	r3
		}
	} while (selected!=0);
     4a4:	2c00      	cmp	r4, #0
     4a6:	d1e7      	bne.n	478 <DoCalibration+0xc>
}
     4a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     4aa:	46c0      	nop			; (mov r8, r8)
     4ac:	000010fd 	.word	0x000010fd
     4b0:	0000259c 	.word	0x0000259c
     4b4:	00001349 	.word	0x00001349
     4b8:	00000395 	.word	0x00000395
     4bc:	0000273c 	.word	0x0000273c
     4c0:	00001005 	.word	0x00001005

000004c4 <CalibrationModeChk>:





void CalibrationModeChk(){	//chk for key combo and password
     4c4:	b5f0      	push	{r4, r5, r6, r7, lr}
     4c6:	b083      	sub	sp, #12
	//check if key combo is pressed and proceed with calibration
	int32_t EnteredPass=0;
	if (KeyDetected())
     4c8:	4b28      	ldr	r3, [pc, #160]	; (56c <CalibrationModeChk+0xa8>)
     4ca:	4798      	blx	r3
     4cc:	2800      	cmp	r0, #0
     4ce:	d04b      	beq.n	568 <CalibrationModeChk+0xa4>
	{ //chk for key combo is any key press is detected
		KeyscanWORelese();
     4d0:	4b27      	ldr	r3, [pc, #156]	; (570 <CalibrationModeChk+0xac>)
     4d2:	4798      	blx	r3
		if ((ParaKey&&UpdateKey)&&!(RunKey||StopKey||StartKey||EnterKey)) //enter cal only when para and update key is pressed
     4d4:	4b27      	ldr	r3, [pc, #156]	; (574 <CalibrationModeChk+0xb0>)
     4d6:	781b      	ldrb	r3, [r3, #0]
     4d8:	2b00      	cmp	r3, #0
     4da:	d045      	beq.n	568 <CalibrationModeChk+0xa4>
     4dc:	4b26      	ldr	r3, [pc, #152]	; (578 <CalibrationModeChk+0xb4>)
     4de:	781b      	ldrb	r3, [r3, #0]
     4e0:	2b00      	cmp	r3, #0
     4e2:	d041      	beq.n	568 <CalibrationModeChk+0xa4>
     4e4:	4b25      	ldr	r3, [pc, #148]	; (57c <CalibrationModeChk+0xb8>)
     4e6:	781b      	ldrb	r3, [r3, #0]
     4e8:	2b00      	cmp	r3, #0
     4ea:	d13d      	bne.n	568 <CalibrationModeChk+0xa4>
     4ec:	4b24      	ldr	r3, [pc, #144]	; (580 <CalibrationModeChk+0xbc>)
     4ee:	781b      	ldrb	r3, [r3, #0]
     4f0:	2b00      	cmp	r3, #0
     4f2:	d139      	bne.n	568 <CalibrationModeChk+0xa4>
     4f4:	4b23      	ldr	r3, [pc, #140]	; (584 <CalibrationModeChk+0xc0>)
     4f6:	781b      	ldrb	r3, [r3, #0]
     4f8:	2b00      	cmp	r3, #0
     4fa:	d135      	bne.n	568 <CalibrationModeChk+0xa4>
     4fc:	4b22      	ldr	r3, [pc, #136]	; (588 <CalibrationModeChk+0xc4>)
     4fe:	781b      	ldrb	r3, [r3, #0]
     500:	2b00      	cmp	r3, #0
     502:	d131      	bne.n	568 <CalibrationModeChk+0xa4>
		{	//calibration key combination  detected
			
			LCD_Clrscr();
     504:	4b21      	ldr	r3, [pc, #132]	; (58c <CalibrationModeChk+0xc8>)
     506:	4798      	blx	r3
			LCD_OneLine(1,"  Calibration Mode  ");
     508:	2001      	movs	r0, #1
     50a:	4921      	ldr	r1, [pc, #132]	; (590 <CalibrationModeChk+0xcc>)
     50c:	4b21      	ldr	r3, [pc, #132]	; (594 <CalibrationModeChk+0xd0>)
     50e:	4798      	blx	r3
			//wait for key combo to be released
			Release(ParaKey||UpdateKey);
     510:	4d21      	ldr	r5, [pc, #132]	; (598 <CalibrationModeChk+0xd4>)
     512:	4c18      	ldr	r4, [pc, #96]	; (574 <CalibrationModeChk+0xb0>)
     514:	4e18      	ldr	r6, [pc, #96]	; (578 <CalibrationModeChk+0xb4>)
     516:	47a8      	blx	r5
     518:	7823      	ldrb	r3, [r4, #0]
     51a:	2b00      	cmp	r3, #0
     51c:	d1fb      	bne.n	516 <CalibrationModeChk+0x52>
     51e:	7833      	ldrb	r3, [r6, #0]
     520:	2b00      	cmp	r3, #0
     522:	d1f8      	bne.n	516 <CalibrationModeChk+0x52>
			do
			{
				LCD_FullDisp(	"  Calibration Mode  ",
     524:	4f1a      	ldr	r7, [pc, #104]	; (590 <CalibrationModeChk+0xcc>)
     526:	4e1d      	ldr	r6, [pc, #116]	; (59c <CalibrationModeChk+0xd8>)
     528:	4c1d      	ldr	r4, [pc, #116]	; (5a0 <CalibrationModeChk+0xdc>)
     52a:	1c38      	adds	r0, r7, #0
     52c:	1c31      	adds	r1, r6, #0
     52e:	1c22      	adds	r2, r4, #0
     530:	1c23      	adds	r3, r4, #0
     532:	4d1c      	ldr	r5, [pc, #112]	; (5a4 <CalibrationModeChk+0xe0>)
     534:	47a8      	blx	r5
				"   Enter Password   ",
				LCD_BLANK_LINE_MACRO,
				LCD_BLANK_LINE_MACRO);
				
				EnteredPass=GetNumDataFromUserWithESC(0,0,7,3,8);
     536:	2308      	movs	r3, #8
     538:	9300      	str	r3, [sp, #0]
     53a:	2000      	movs	r0, #0
     53c:	2100      	movs	r1, #0
     53e:	2207      	movs	r2, #7
     540:	2303      	movs	r3, #3
     542:	4d19      	ldr	r5, [pc, #100]	; (5a8 <CalibrationModeChk+0xe4>)
     544:	47a8      	blx	r5
				if (EnteredPass==-1)	//-1 is just  used to check when esc key is pressed
     546:	1c43      	adds	r3, r0, #1
     548:	d00e      	beq.n	568 <CalibrationModeChk+0xa4>
				{
					return;			//exit cal mode if para/ESC key is pressed
				}
				
				else if (EnteredPass!=Passw)
     54a:	2801      	cmp	r0, #1
     54c:	d00a      	beq.n	564 <CalibrationModeChk+0xa0>
				{
					LCD_OneLine(4,"   Wrong Password!! ");
     54e:	2004      	movs	r0, #4
     550:	4916      	ldr	r1, [pc, #88]	; (5ac <CalibrationModeChk+0xe8>)
     552:	4d10      	ldr	r5, [pc, #64]	; (594 <CalibrationModeChk+0xd0>)
     554:	47a8      	blx	r5
					delay_sec(1);
     556:	2001      	movs	r0, #1
     558:	4b15      	ldr	r3, [pc, #84]	; (5b0 <CalibrationModeChk+0xec>)
     55a:	4798      	blx	r3
					LCD_OneLine(4,LCD_BLANK_LINE_MACRO);
     55c:	2004      	movs	r0, #4
     55e:	4910      	ldr	r1, [pc, #64]	; (5a0 <CalibrationModeChk+0xdc>)
     560:	47a8      	blx	r5
     562:	e7e2      	b.n	52a <CalibrationModeChk+0x66>
				}
			}while(EnteredPass!=Passw);
			
			if (EnteredPass==Passw)
			DoCalibration();
     564:	4b13      	ldr	r3, [pc, #76]	; (5b4 <CalibrationModeChk+0xf0>)
     566:	4798      	blx	r3

		}	//if (keycombo chk) close brac
	}	//if (keydetect) close brac
}	//function close brac
     568:	b003      	add	sp, #12
     56a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     56c:	00001635 	.word	0x00001635
     570:	00001769 	.word	0x00001769
     574:	200000cc 	.word	0x200000cc
     578:	20000094 	.word	0x20000094
     57c:	200000ec 	.word	0x200000ec
     580:	20000138 	.word	0x20000138
     584:	20000105 	.word	0x20000105
     588:	20000104 	.word	0x20000104
     58c:	0000110d 	.word	0x0000110d
     590:	00002750 	.word	0x00002750
     594:	00001005 	.word	0x00001005
     598:	00001671 	.word	0x00001671
     59c:	00002768 	.word	0x00002768
     5a0:	000026ac 	.word	0x000026ac
     5a4:	00000fc5 	.word	0x00000fc5
     5a8:	000009cd 	.word	0x000009cd
     5ac:	00002780 	.word	0x00002780
     5b0:	0000129d 	.word	0x0000129d
     5b4:	0000046d 	.word	0x0000046d

000005b8 <_i2c_master_wait_for_sync>:
{
	/* Sanity check. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
     5b8:	6801      	ldr	r1, [r0, #0]

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
     5ba:	2207      	movs	r2, #7
     5bc:	69cb      	ldr	r3, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check. */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
     5be:	421a      	tst	r2, r3
     5c0:	d1fc      	bne.n	5bc <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
     5c2:	4770      	bx	lr

000005c4 <configure_EEPROM>:



//! [initialize_i2c]
void configure_EEPROM(void)
{
     5c4:	b530      	push	{r4, r5, lr}
     5c6:	b08d      	sub	sp, #52	; 0x34
	
	pinMode(WP, OUTPUT);
     5c8:	200f      	movs	r0, #15
     5ca:	2100      	movs	r1, #0
     5cc:	4b21      	ldr	r3, [pc, #132]	; (654 <configure_EEPROM+0x90>)
     5ce:	4798      	blx	r3
	PinSet(WP);
     5d0:	2280      	movs	r2, #128	; 0x80
     5d2:	0212      	lsls	r2, r2, #8
     5d4:	4b20      	ldr	r3, [pc, #128]	; (658 <configure_EEPROM+0x94>)
     5d6:	601a      	str	r2, [r3, #0]
static inline void i2c_master_get_config_defaults(
		struct i2c_master_config *const config)
{
	/*Sanity check argument. */
	Assert(config);
	config->baud_rate        = I2C_MASTER_BAUD_RATE_100KHZ;
     5d8:	2364      	movs	r3, #100	; 0x64
     5da:	9300      	str	r3, [sp, #0]
#ifdef FEATURE_I2C_FAST_MODE_PLUS_AND_HIGH_SPEED
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
     5dc:	4b1f      	ldr	r3, [pc, #124]	; (65c <configure_EEPROM+0x98>)
     5de:	9301      	str	r3, [sp, #4]
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
     5e0:	2300      	movs	r3, #0
     5e2:	9302      	str	r3, [sp, #8]
#endif
	config->generator_source = GCLK_GENERATOR_0;
     5e4:	4669      	mov	r1, sp
     5e6:	730b      	strb	r3, [r1, #12]
	config->run_in_standby   = false;
     5e8:	760b      	strb	r3, [r1, #24]
	config->start_hold_time  = I2C_MASTER_START_HOLD_TIME_300NS_600NS;
     5ea:	2280      	movs	r2, #128	; 0x80
     5ec:	0392      	lsls	r2, r2, #14
     5ee:	9204      	str	r2, [sp, #16]
	config->buffer_timeout   = 65535;
	config->unknown_bus_state_timeout = 65535;
     5f0:	2201      	movs	r2, #1
     5f2:	4252      	negs	r2, r2
     5f4:	828a      	strh	r2, [r1, #20]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->scl_low_timeout  = false;
     5f6:	2224      	movs	r2, #36	; 0x24
     5f8:	548b      	strb	r3, [r1, r2]
	config->inactive_timeout = I2C_MASTER_INACTIVE_TIMEOUT_DISABLED;
     5fa:	930a      	str	r3, [sp, #40]	; 0x28
#ifdef FEATURE_I2C_SCL_STRETCH_MODE
	config->scl_stretch_only_after_ack_bit = false;
     5fc:	222c      	movs	r2, #44	; 0x2c
     5fe:	548b      	strb	r3, [r1, r2]
#endif
#ifdef FEATURE_I2C_SCL_EXTEND_TIMEOUT
	config->slave_scl_low_extend_timeout   = false;
     600:	222d      	movs	r2, #45	; 0x2d
     602:	548b      	strb	r3, [r1, r2]
	config->master_scl_low_extend_timeout  = false;
     604:	222e      	movs	r2, #46	; 0x2e
     606:	548b      	strb	r3, [r1, r2]
	i2c_master_get_config_defaults(&config_i2c_master);
	//! [init_conf]

	/* Change buffer timeout to something longer. */
	//! [conf_change]
	config_i2c_master.buffer_timeout = 10000;
     608:	4b15      	ldr	r3, [pc, #84]	; (660 <configure_EEPROM+0x9c>)
     60a:	466a      	mov	r2, sp
     60c:	82cb      	strh	r3, [r1, #22]
	config_i2c_master.generator_source=GCLK_GENERATOR_0;
	config_i2c_master.pinmux_pad0=PINMUX_PA12C_SERCOM2_PAD0;
     60e:	4b15      	ldr	r3, [pc, #84]	; (664 <configure_EEPROM+0xa0>)
     610:	9307      	str	r3, [sp, #28]
	config_i2c_master.pinmux_pad1=PINMUX_PA13C_SERCOM2_PAD1;
     612:	4b15      	ldr	r3, [pc, #84]	; (668 <configure_EEPROM+0xa4>)
     614:	9308      	str	r3, [sp, #32]
	//! [conf_change]

	/* Initialize and enable device with config. */
	//! [init_module]
	i2c_master_init(&i2c_master_instance, SERCOM2, &config_i2c_master);
     616:	4d15      	ldr	r5, [pc, #84]	; (66c <configure_EEPROM+0xa8>)
     618:	1c28      	adds	r0, r5, #0
     61a:	4915      	ldr	r1, [pc, #84]	; (670 <configure_EEPROM+0xac>)
     61c:	4b15      	ldr	r3, [pc, #84]	; (674 <configure_EEPROM+0xb0>)
     61e:	4798      	blx	r3
	
	/*BAUD=GCLK0freq(48Mhz)*Thigh
	/i.e SCLfreq=GCLK/(2*Baud)*/
	REG_SERCOM2_I2CM_BAUD=200;				//force baud rate after above setting gives around 100Khz
     620:	22c8      	movs	r2, #200	; 0xc8
     622:	4b15      	ldr	r3, [pc, #84]	; (678 <configure_EEPROM+0xb4>)
     624:	601a      	str	r2, [r3, #0]
{
	/* Sanity check of arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     626:	682c      	ldr	r4, [r5, #0]

	/* Timeout counter used to force bus state. */
	uint32_t timeout_counter = 0;

	/* Wait for module to sync. */
	_i2c_master_wait_for_sync(module);
     628:	1c28      	adds	r0, r5, #0
     62a:	4b14      	ldr	r3, [pc, #80]	; (67c <configure_EEPROM+0xb8>)
     62c:	4798      	blx	r3

	/* Enable module. */
	i2c_module->CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
     62e:	6822      	ldr	r2, [r4, #0]
     630:	2302      	movs	r3, #2
     632:	4313      	orrs	r3, r2
     634:	6023      	str	r3, [r4, #0]
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown. */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
		timeout_counter++;
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
     636:	88e8      	ldrh	r0, [r5, #6]
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Timeout counter used to force bus state. */
	uint32_t timeout_counter = 0;
     638:	2300      	movs	r3, #0
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown. */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
     63a:	2110      	movs	r1, #16
     63c:	e005      	b.n	64a <configure_EEPROM+0x86>
		timeout_counter++;
     63e:	3301      	adds	r3, #1
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
     640:	4283      	cmp	r3, r0
     642:	d302      	bcc.n	64a <configure_EEPROM+0x86>
			/* Timeout, force bus state to idle. */
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
     644:	2310      	movs	r3, #16
     646:	8363      	strh	r3, [r4, #26]
     648:	e002      	b.n	650 <configure_EEPROM+0x8c>
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown. */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
     64a:	8b62      	ldrh	r2, [r4, #26]
     64c:	420a      	tst	r2, r1
     64e:	d0f6      	beq.n	63e <configure_EEPROM+0x7a>

	//! [enable_module]
	i2c_master_enable(&i2c_master_instance);
	//! [enable_module]
	
}
     650:	b00d      	add	sp, #52	; 0x34
     652:	bd30      	pop	{r4, r5, pc}
     654:	000018a5 	.word	0x000018a5
     658:	41004418 	.word	0x41004418
     65c:	00000d48 	.word	0x00000d48
     660:	00002710 	.word	0x00002710
     664:	000c0002 	.word	0x000c0002
     668:	000d0002 	.word	0x000d0002
     66c:	20000150 	.word	0x20000150
     670:	42001000 	.word	0x42001000
     674:	00000111 	.word	0x00000111
     678:	4200100c 	.word	0x4200100c
     67c:	000005b9 	.word	0x000005b9

00000680 <CheckDigitBound>:
/************************************************************************/
/* When a Digit is incremented or decremented by User, it should not go above 9 or below 0
This function takes care of proper bounds off.*/
/************************************************************************/
int8_t CheckDigitBound(int8_t Num){
	if (Num<0)
     680:	2800      	cmp	r0, #0
     682:	db07      	blt.n	694 <CheckDigitBound+0x14>
	Num=9;			//roll to 10
	if (Num>9)
	Num=0;			//roll to 0
     684:	2309      	movs	r3, #9
     686:	0fc1      	lsrs	r1, r0, #31
     688:	17da      	asrs	r2, r3, #31
     68a:	4283      	cmp	r3, r0
     68c:	4151      	adcs	r1, r2
     68e:	424b      	negs	r3, r1
     690:	4018      	ands	r0, r3
     692:	e000      	b.n	696 <CheckDigitBound+0x16>
/* When a Digit is incremented or decremented by User, it should not go above 9 or below 0
This function takes care of proper bounds off.*/
/************************************************************************/
int8_t CheckDigitBound(int8_t Num){
	if (Num<0)
	Num=9;			//roll to 10
     694:	2009      	movs	r0, #9
	if (Num>9)
	Num=0;			//roll to 0
	
	return Num;
}
     696:	4770      	bx	lr

00000698 <SplitNumbertoDigits>:
the Splitted BCD digits are stored in DigitArray that is passed to the function
Usage:
int8_t BCDarray;	//Initialize and array to Store the BCD digits
SplitNumbertoDigits(Variable, BCDarray, 5);*/
/************************************************************************/
void SplitNumbertoDigits(uint32_t Num, int8_t DigitArray[], int8_t NoofDigits){
     698:	b5f0      	push	{r4, r5, r6, r7, lr}
     69a:	4647      	mov	r7, r8
     69c:	b480      	push	{r7}
     69e:	1c05      	adds	r5, r0, #0
	
	int8_t i=0, val=0;
	uint32_t Temp=Num;
	
	while (i<NoofDigits)
     6a0:	2a00      	cmp	r2, #0
     6a2:	dd12      	ble.n	6ca <SplitNumbertoDigits+0x32>
     6a4:	1c0c      	adds	r4, r1, #0
     6a6:	3101      	adds	r1, #1
     6a8:	3a01      	subs	r2, #1
     6aa:	b2d2      	uxtb	r2, r2
     6ac:	1889      	adds	r1, r1, r2
     6ae:	4688      	mov	r8, r1
	{
		val=Temp%10;
     6b0:	4f07      	ldr	r7, [pc, #28]	; (6d0 <SplitNumbertoDigits+0x38>)
		DigitArray[i]= val;
		Temp=Temp/10;
     6b2:	4e08      	ldr	r6, [pc, #32]	; (6d4 <SplitNumbertoDigits+0x3c>)
	int8_t i=0, val=0;
	uint32_t Temp=Num;
	
	while (i<NoofDigits)
	{
		val=Temp%10;
     6b4:	1c28      	adds	r0, r5, #0
     6b6:	210a      	movs	r1, #10
     6b8:	47b8      	blx	r7
     6ba:	7021      	strb	r1, [r4, #0]
		DigitArray[i]= val;
		Temp=Temp/10;
     6bc:	1c28      	adds	r0, r5, #0
     6be:	210a      	movs	r1, #10
     6c0:	47b0      	blx	r6
     6c2:	1c05      	adds	r5, r0, #0
     6c4:	3401      	adds	r4, #1
void SplitNumbertoDigits(uint32_t Num, int8_t DigitArray[], int8_t NoofDigits){
	
	int8_t i=0, val=0;
	uint32_t Temp=Num;
	
	while (i<NoofDigits)
     6c6:	4544      	cmp	r4, r8
     6c8:	d1f4      	bne.n	6b4 <SplitNumbertoDigits+0x1c>
		DigitArray[i]= val;
		Temp=Temp/10;
		i++;
	}
	
}
     6ca:	bc04      	pop	{r2}
     6cc:	4690      	mov	r8, r2
     6ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
     6d0:	00002539 	.word	0x00002539
     6d4:	000024b1 	.word	0x000024b1

000006d8 <LCD_DispVariable>:

Usage: LCD_DispVariable(12345, 2, 4, 1, 10);
23.45 will be displayed on LCD at 1st Row and 10th Column.
MSd will be neglected since only 4 digit are asked to be displayed */
/*********************************************************************************************************************/
void LCD_DispVariable(uint32_t Number, char DecimalPos, uint8_t NoofDigitsToDisplay, char Row, char Col){
     6d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     6da:	464f      	mov	r7, r9
     6dc:	4646      	mov	r6, r8
     6de:	b4c0      	push	{r6, r7}
     6e0:	af00      	add	r7, sp, #0
     6e2:	1c0d      	adds	r5, r1, #0
     6e4:	1c14      	adds	r4, r2, #0
     6e6:	4699      	mov	r9, r3
     6e8:	2220      	movs	r2, #32
     6ea:	5dd2      	ldrb	r2, [r2, r7]
     6ec:	4690      	mov	r8, r2
	int8_t Digit[NoofDigitsToDisplay];	//temporary array to store BCD
     6ee:	1de3      	adds	r3, r4, #7
     6f0:	08db      	lsrs	r3, r3, #3
     6f2:	00db      	lsls	r3, r3, #3
     6f4:	466a      	mov	r2, sp
     6f6:	1ad2      	subs	r2, r2, r3
     6f8:	4695      	mov	sp, r2
     6fa:	466e      	mov	r6, sp
	SplitNumbertoDigits(Number,  Digit, NoofDigitsToDisplay);
     6fc:	b262      	sxtb	r2, r4
     6fe:	4669      	mov	r1, sp
     700:	4b25      	ldr	r3, [pc, #148]	; (798 <LCD_DispVariable+0xc0>)
     702:	4798      	blx	r3
	
	LCD_Setcursor(Row, Col);	
     704:	4648      	mov	r0, r9
     706:	4641      	mov	r1, r8
     708:	4b24      	ldr	r3, [pc, #144]	; (79c <LCD_DispVariable+0xc4>)
     70a:	4798      	blx	r3
	if (NoofDigitsToDisplay>=7)
     70c:	2c06      	cmp	r4, #6
     70e:	d902      	bls.n	716 <LCD_DispVariable+0x3e>
	LCD_DispAscii(Digit[6]);				//LSB
     710:	79b0      	ldrb	r0, [r6, #6]
     712:	4b23      	ldr	r3, [pc, #140]	; (7a0 <LCD_DispVariable+0xc8>)
     714:	4798      	blx	r3
	if (DecimalPos==6)
     716:	2d06      	cmp	r5, #6
     718:	d102      	bne.n	720 <LCD_DispVariable+0x48>
	LCD_DataWrite('.');
     71a:	202e      	movs	r0, #46	; 0x2e
     71c:	4b21      	ldr	r3, [pc, #132]	; (7a4 <LCD_DispVariable+0xcc>)
     71e:	4798      	blx	r3
	
	
	if (NoofDigitsToDisplay>=6)
     720:	2c05      	cmp	r4, #5
     722:	d902      	bls.n	72a <LCD_DispVariable+0x52>
	LCD_DispAscii(Digit[5]);
     724:	7970      	ldrb	r0, [r6, #5]
     726:	4b1e      	ldr	r3, [pc, #120]	; (7a0 <LCD_DispVariable+0xc8>)
     728:	4798      	blx	r3
	if (DecimalPos==5)
     72a:	2d05      	cmp	r5, #5
     72c:	d102      	bne.n	734 <LCD_DispVariable+0x5c>
	LCD_DataWrite('.');
     72e:	202e      	movs	r0, #46	; 0x2e
     730:	4b1c      	ldr	r3, [pc, #112]	; (7a4 <LCD_DispVariable+0xcc>)
     732:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=5)
     734:	2c04      	cmp	r4, #4
     736:	d902      	bls.n	73e <LCD_DispVariable+0x66>
	LCD_DispAscii(Digit[4]);
     738:	7930      	ldrb	r0, [r6, #4]
     73a:	4b19      	ldr	r3, [pc, #100]	; (7a0 <LCD_DispVariable+0xc8>)
     73c:	4798      	blx	r3
	if (DecimalPos==4)
     73e:	2d04      	cmp	r5, #4
     740:	d102      	bne.n	748 <LCD_DispVariable+0x70>
	LCD_DataWrite('.');
     742:	202e      	movs	r0, #46	; 0x2e
     744:	4b17      	ldr	r3, [pc, #92]	; (7a4 <LCD_DispVariable+0xcc>)
     746:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=4)
     748:	2c03      	cmp	r4, #3
     74a:	d902      	bls.n	752 <LCD_DispVariable+0x7a>
	LCD_DispAscii(Digit[3]);
     74c:	78f0      	ldrb	r0, [r6, #3]
     74e:	4b14      	ldr	r3, [pc, #80]	; (7a0 <LCD_DispVariable+0xc8>)
     750:	4798      	blx	r3
	if (DecimalPos==3)
     752:	2d03      	cmp	r5, #3
     754:	d102      	bne.n	75c <LCD_DispVariable+0x84>
	LCD_DataWrite('.');
     756:	202e      	movs	r0, #46	; 0x2e
     758:	4b12      	ldr	r3, [pc, #72]	; (7a4 <LCD_DispVariable+0xcc>)
     75a:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=3)
     75c:	2c02      	cmp	r4, #2
     75e:	d902      	bls.n	766 <LCD_DispVariable+0x8e>
	LCD_DispAscii(Digit[2]);
     760:	78b0      	ldrb	r0, [r6, #2]
     762:	4b0f      	ldr	r3, [pc, #60]	; (7a0 <LCD_DispVariable+0xc8>)
     764:	4798      	blx	r3
	if (DecimalPos==2)
     766:	2d02      	cmp	r5, #2
     768:	d102      	bne.n	770 <LCD_DispVariable+0x98>
	LCD_DataWrite('.');
     76a:	202e      	movs	r0, #46	; 0x2e
     76c:	4b0d      	ldr	r3, [pc, #52]	; (7a4 <LCD_DispVariable+0xcc>)
     76e:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=2)
     770:	2c01      	cmp	r4, #1
     772:	d902      	bls.n	77a <LCD_DispVariable+0xa2>
	LCD_DispAscii(Digit[1]);
     774:	7870      	ldrb	r0, [r6, #1]
     776:	4b0a      	ldr	r3, [pc, #40]	; (7a0 <LCD_DispVariable+0xc8>)
     778:	4798      	blx	r3
	if (DecimalPos==1)
     77a:	2d01      	cmp	r5, #1
     77c:	d102      	bne.n	784 <LCD_DispVariable+0xac>
	LCD_DataWrite('.');
     77e:	202e      	movs	r0, #46	; 0x2e
     780:	4b08      	ldr	r3, [pc, #32]	; (7a4 <LCD_DispVariable+0xcc>)
     782:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=1)
     784:	2c00      	cmp	r4, #0
     786:	d002      	beq.n	78e <LCD_DispVariable+0xb6>
	LCD_DispAscii(Digit[0]);
     788:	7830      	ldrb	r0, [r6, #0]
     78a:	4b05      	ldr	r3, [pc, #20]	; (7a0 <LCD_DispVariable+0xc8>)
     78c:	4798      	blx	r3

}
     78e:	46bd      	mov	sp, r7
     790:	bc0c      	pop	{r2, r3}
     792:	4690      	mov	r8, r2
     794:	4699      	mov	r9, r3
     796:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     798:	00000699 	.word	0x00000699
     79c:	00000f81 	.word	0x00000f81
     7a0:	00000f41 	.word	0x00000f41
     7a4:	00000ef1 	.word	0x00000ef1

000007a8 <CombineDigitstoNumber>:
Array Index=  0 1 2 3 4 
Say Digit[5]={2,4,5,6,8}; is the array of 5 element containing 5 BCD digit
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
     7a8:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
	
		
	if (NoofDigits>0)
     7aa:	2900      	cmp	r1, #0
     7ac:	dd02      	ble.n	7b4 <CombineDigitstoNumber+0xc>
		BCD1 = Digit[0];
     7ae:	2700      	movs	r7, #0
     7b0:	57c7      	ldrsb	r7, [r0, r7]
     7b2:	e000      	b.n	7b6 <CombineDigitstoNumber+0xe>
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     7b4:	2700      	movs	r7, #0
	
		
	if (NoofDigits>0)
		BCD1 = Digit[0];
	
	if (NoofDigits>1)
     7b6:	2901      	cmp	r1, #1
     7b8:	dd06      	ble.n	7c8 <CombineDigitstoNumber+0x20>
		BCD2 = Digit[1]*10;
     7ba:	2301      	movs	r3, #1
     7bc:	56c3      	ldrsb	r3, [r0, r3]
     7be:	009e      	lsls	r6, r3, #2
     7c0:	18f3      	adds	r3, r6, r3
     7c2:	005b      	lsls	r3, r3, #1
     7c4:	469c      	mov	ip, r3
     7c6:	e001      	b.n	7cc <CombineDigitstoNumber+0x24>
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     7c8:	2300      	movs	r3, #0
     7ca:	469c      	mov	ip, r3
     7cc:	2600      	movs	r6, #0
		BCD1 = Digit[0];
	
	if (NoofDigits>1)
		BCD2 = Digit[1]*10;
		
	if (NoofDigits>2)
     7ce:	2902      	cmp	r1, #2
     7d0:	dd03      	ble.n	7da <CombineDigitstoNumber+0x32>
		BCD3 = Digit[2]*100;
     7d2:	2302      	movs	r3, #2
     7d4:	56c3      	ldrsb	r3, [r0, r3]
     7d6:	2664      	movs	r6, #100	; 0x64
     7d8:	435e      	muls	r6, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     7da:	2500      	movs	r5, #0
		BCD2 = Digit[1]*10;
		
	if (NoofDigits>2)
		BCD3 = Digit[2]*100;
		
	if (NoofDigits>3)
     7dc:	2903      	cmp	r1, #3
     7de:	dd04      	ble.n	7ea <CombineDigitstoNumber+0x42>
		BCD4 = Digit[3]*1000;
     7e0:	2303      	movs	r3, #3
     7e2:	56c3      	ldrsb	r3, [r0, r3]
     7e4:	25fa      	movs	r5, #250	; 0xfa
     7e6:	00ad      	lsls	r5, r5, #2
     7e8:	435d      	muls	r5, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     7ea:	2400      	movs	r4, #0
		BCD3 = Digit[2]*100;
		
	if (NoofDigits>3)
		BCD4 = Digit[3]*1000;
		
	if (NoofDigits>4)
     7ec:	2904      	cmp	r1, #4
     7ee:	dd03      	ble.n	7f8 <CombineDigitstoNumber+0x50>
		BCD5 = Digit[4]*10000;
     7f0:	2304      	movs	r3, #4
     7f2:	56c3      	ldrsb	r3, [r0, r3]
     7f4:	4c0b      	ldr	r4, [pc, #44]	; (824 <CombineDigitstoNumber+0x7c>)
     7f6:	435c      	muls	r4, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     7f8:	2200      	movs	r2, #0
		BCD4 = Digit[3]*1000;
		
	if (NoofDigits>4)
		BCD5 = Digit[4]*10000;
	
	if (NoofDigits>5)
     7fa:	2905      	cmp	r1, #5
     7fc:	dd03      	ble.n	806 <CombineDigitstoNumber+0x5e>
		BCD6 = Digit[5]*100000;
     7fe:	2305      	movs	r3, #5
     800:	56c3      	ldrsb	r3, [r0, r3]
     802:	4a09      	ldr	r2, [pc, #36]	; (828 <CombineDigitstoNumber+0x80>)
     804:	435a      	muls	r2, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     806:	2300      	movs	r3, #0
		BCD5 = Digit[4]*10000;
	
	if (NoofDigits>5)
		BCD6 = Digit[5]*100000;
		
	if (NoofDigits>6)
     808:	2906      	cmp	r1, #6
     80a:	dd03      	ble.n	814 <CombineDigitstoNumber+0x6c>
		BCD7 = Digit[6]*1000000;
     80c:	2306      	movs	r3, #6
     80e:	56c3      	ldrsb	r3, [r0, r3]
     810:	4906      	ldr	r1, [pc, #24]	; (82c <CombineDigitstoNumber+0x84>)
     812:	434b      	muls	r3, r1
		

	return (BCD7+BCD6+BCD5+BCD4+BCD3+BCD2+BCD1);
     814:	4661      	mov	r1, ip
     816:	19c8      	adds	r0, r1, r7
     818:	1986      	adds	r6, r0, r6
     81a:	1975      	adds	r5, r6, r5
     81c:	192c      	adds	r4, r5, r4
     81e:	18a2      	adds	r2, r4, r2
     820:	18d0      	adds	r0, r2, r3
}
     822:	bdf0      	pop	{r4, r5, r6, r7, pc}
     824:	00002710 	.word	0x00002710
     828:	000186a0 	.word	0x000186a0
     82c:	000f4240 	.word	0x000f4240

00000830 <GetNumDataFromUser>:
uint32_t ans=GetNumDataFromUser(32768,4,5,2,10);      
Current value of variable will be displayed on LCD with given decimal point 
and user can edit the value and press enter to store new value of variable
5 digit is mostly used and this function can handle maximum of 7 Digits */
/************************************************************************/
uint32_t GetNumDataFromUser(uint32_t CurrentNum, uint8_t DecimalPos, uint8_t NoofDigit,  char Row, char Col){
     830:	b5f0      	push	{r4, r5, r6, r7, lr}
     832:	465f      	mov	r7, fp
     834:	4656      	mov	r6, sl
     836:	464d      	mov	r5, r9
     838:	4644      	mov	r4, r8
     83a:	b4f0      	push	{r4, r5, r6, r7}
     83c:	b089      	sub	sp, #36	; 0x24
     83e:	af02      	add	r7, sp, #8
     840:	6078      	str	r0, [r7, #4]
     842:	6139      	str	r1, [r7, #16]
     844:	4692      	mov	sl, r2
     846:	469b      	mov	fp, r3
     848:	2140      	movs	r1, #64	; 0x40
     84a:	5dc9      	ldrb	r1, [r1, r7]
     84c:	6179      	str	r1, [r7, #20]
	int8_t Digit[NoofDigit];
     84e:	1c13      	adds	r3, r2, #0
     850:	3307      	adds	r3, #7
     852:	08db      	lsrs	r3, r3, #3
     854:	00db      	lsls	r3, r3, #3
     856:	466a      	mov	r2, sp
     858:	1ad2      	subs	r2, r2, r3
     85a:	4695      	mov	sp, r2
     85c:	ab02      	add	r3, sp, #8
     85e:	60bb      	str	r3, [r7, #8]
     860:	4698      	mov	r8, r3
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
     862:	9100      	str	r1, [sp, #0]
     864:	6878      	ldr	r0, [r7, #4]
     866:	6939      	ldr	r1, [r7, #16]
     868:	4652      	mov	r2, sl
     86a:	465b      	mov	r3, fp
     86c:	4c47      	ldr	r4, [pc, #284]	; (98c <GetNumDataFromUser+0x15c>)
     86e:	47a0      	blx	r4
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
     870:	4652      	mov	r2, sl
     872:	b2d2      	uxtb	r2, r2
     874:	603a      	str	r2, [r7, #0]
     876:	b252      	sxtb	r2, r2
     878:	6878      	ldr	r0, [r7, #4]
     87a:	68b9      	ldr	r1, [r7, #8]
     87c:	4b44      	ldr	r3, [pc, #272]	; (990 <GetNumDataFromUser+0x160>)
     87e:	4798      	blx	r3
	LCD_CursorOn();
     880:	4b44      	ldr	r3, [pc, #272]	; (994 <GetNumDataFromUser+0x164>)
     882:	4798      	blx	r3
	int8_t i=NoofDigit-1;
     884:	4653      	mov	r3, sl
     886:	3b01      	subs	r3, #1
     888:	b2db      	uxtb	r3, r3
     88a:	60fb      	str	r3, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
     88c:	4658      	mov	r0, fp
     88e:	6979      	ldr	r1, [r7, #20]
     890:	4b41      	ldr	r3, [pc, #260]	; (998 <GetNumDataFromUser+0x168>)
     892:	4798      	blx	r3
	ReleaseKey();
     894:	4b41      	ldr	r3, [pc, #260]	; (99c <GetNumDataFromUser+0x16c>)
     896:	4798      	blx	r3
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
	uint8_t NewCol=Col;
     898:	697e      	ldr	r6, [r7, #20]
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
     89a:	68fd      	ldr	r5, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
	ReleaseKey();
	while(1){
		if (KeyDetected())
     89c:	4c40      	ldr	r4, [pc, #256]	; (9a0 <GetNumDataFromUser+0x170>)
     89e:	47a0      	blx	r4
     8a0:	2800      	cmp	r0, #0
     8a2:	d0fc      	beq.n	89e <GetNumDataFromUser+0x6e>
		{
			Keyscan();
     8a4:	4b3f      	ldr	r3, [pc, #252]	; (9a4 <GetNumDataFromUser+0x174>)
     8a6:	4798      	blx	r3
			if (IncrKey)
     8a8:	493f      	ldr	r1, [pc, #252]	; (9a8 <GetNumDataFromUser+0x178>)
     8aa:	780b      	ldrb	r3, [r1, #0]
     8ac:	2b00      	cmp	r3, #0
     8ae:	d00b      	beq.n	8c8 <GetNumDataFromUser+0x98>
			{
				Digit[i]++;
     8b0:	b26a      	sxtb	r2, r5
     8b2:	4691      	mov	r9, r2
     8b4:	4643      	mov	r3, r8
     8b6:	444b      	add	r3, r9
     8b8:	7818      	ldrb	r0, [r3, #0]
     8ba:	3001      	adds	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     8bc:	b240      	sxtb	r0, r0
     8be:	4b3b      	ldr	r3, [pc, #236]	; (9ac <GetNumDataFromUser+0x17c>)
     8c0:	4798      	blx	r3
     8c2:	4641      	mov	r1, r8
     8c4:	4449      	add	r1, r9
     8c6:	7008      	strb	r0, [r1, #0]
			}
			
			if (DecrKey)
     8c8:	4b39      	ldr	r3, [pc, #228]	; (9b0 <GetNumDataFromUser+0x180>)
     8ca:	781b      	ldrb	r3, [r3, #0]
     8cc:	2b00      	cmp	r3, #0
     8ce:	d00b      	beq.n	8e8 <GetNumDataFromUser+0xb8>
			{
				Digit[i]--;
     8d0:	b26a      	sxtb	r2, r5
     8d2:	4691      	mov	r9, r2
     8d4:	4643      	mov	r3, r8
     8d6:	444b      	add	r3, r9
     8d8:	7818      	ldrb	r0, [r3, #0]
     8da:	3801      	subs	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     8dc:	b240      	sxtb	r0, r0
     8de:	4b33      	ldr	r3, [pc, #204]	; (9ac <GetNumDataFromUser+0x17c>)
     8e0:	4798      	blx	r3
     8e2:	4641      	mov	r1, r8
     8e4:	4449      	add	r1, r9
     8e6:	7008      	strb	r0, [r1, #0]
			}
			
			if (NextKey || PrevKey)		//shift cursor to right or left with press of Next or Prev key respectively
     8e8:	4b32      	ldr	r3, [pc, #200]	; (9b4 <GetNumDataFromUser+0x184>)
     8ea:	781b      	ldrb	r3, [r3, #0]
     8ec:	2b00      	cmp	r3, #0
     8ee:	d103      	bne.n	8f8 <GetNumDataFromUser+0xc8>
     8f0:	4b31      	ldr	r3, [pc, #196]	; (9b8 <GetNumDataFromUser+0x188>)
     8f2:	781b      	ldrb	r3, [r3, #0]
     8f4:	2b00      	cmp	r3, #0
     8f6:	d023      	beq.n	940 <GetNumDataFromUser+0x110>
			{
				if (NextKey)
     8f8:	4b2e      	ldr	r3, [pc, #184]	; (9b4 <GetNumDataFromUser+0x184>)
     8fa:	781b      	ldrb	r3, [r3, #0]
     8fc:	2b00      	cmp	r3, #0
     8fe:	d001      	beq.n	904 <GetNumDataFromUser+0xd4>
				i--;
     900:	3d01      	subs	r5, #1
     902:	b2ed      	uxtb	r5, r5
				if (PrevKey)
     904:	4b2c      	ldr	r3, [pc, #176]	; (9b8 <GetNumDataFromUser+0x188>)
     906:	781b      	ldrb	r3, [r3, #0]
     908:	2b00      	cmp	r3, #0
     90a:	d001      	beq.n	910 <GetNumDataFromUser+0xe0>
				i++;
     90c:	3501      	adds	r5, #1
     90e:	b2ed      	uxtb	r5, r5
				
				if (i>(NoofDigit-1))
     910:	b26b      	sxtb	r3, r5
     912:	4652      	mov	r2, sl
     914:	3a01      	subs	r2, #1
     916:	4293      	cmp	r3, r2
     918:	dc02      	bgt.n	920 <GetNumDataFromUser+0xf0>
				i=0;
				if (i<0)
     91a:	2b00      	cmp	r3, #0
     91c:	db02      	blt.n	924 <GetNumDataFromUser+0xf4>
     91e:	e002      	b.n	926 <GetNumDataFromUser+0xf6>
				i--;
				if (PrevKey)
				i++;
				
				if (i>(NoofDigit-1))
				i=0;
     920:	2500      	movs	r5, #0
     922:	e000      	b.n	926 <GetNumDataFromUser+0xf6>
				if (i<0)
				i=NoofDigit-1;
     924:	68fd      	ldr	r5, [r7, #12]
				NewCol=Col+NoofDigit-1-i;
     926:	697a      	ldr	r2, [r7, #20]
     928:	1c16      	adds	r6, r2, #0
     92a:	4456      	add	r6, sl
     92c:	1b76      	subs	r6, r6, r5
     92e:	b2f6      	uxtb	r6, r6
     930:	1e73      	subs	r3, r6, #1
     932:	b2db      	uxtb	r3, r3
				if (NewCol>=(Col+NoofDigit-DecimalPos))
     934:	4452      	add	r2, sl
     936:	6939      	ldr	r1, [r7, #16]
     938:	1a52      	subs	r2, r2, r1
     93a:	4293      	cmp	r3, r2
     93c:	da00      	bge.n	940 <GetNumDataFromUser+0x110>
				
				if (i>(NoofDigit-1))
				i=0;
				if (i<0)
				i=NoofDigit-1;
				NewCol=Col+NoofDigit-1-i;
     93e:	1c1e      	adds	r6, r3, #0
				if (NewCol>=(Col+NoofDigit-DecimalPos))
				NewCol++;
			}
			
			if (EnterKey)
     940:	4b1e      	ldr	r3, [pc, #120]	; (9bc <GetNumDataFromUser+0x18c>)
     942:	781b      	ldrb	r3, [r3, #0]
     944:	2b00      	cmp	r3, #0
     946:	d005      	beq.n	954 <GetNumDataFromUser+0x124>
			return CombineDigitstoNumber(Digit,NoofDigit);
     948:	683a      	ldr	r2, [r7, #0]
     94a:	b251      	sxtb	r1, r2
     94c:	68b8      	ldr	r0, [r7, #8]
     94e:	4b1c      	ldr	r3, [pc, #112]	; (9c0 <GetNumDataFromUser+0x190>)
     950:	4798      	blx	r3
     952:	e012      	b.n	97a <GetNumDataFromUser+0x14a>
			
			if (EscKey)
     954:	4b1b      	ldr	r3, [pc, #108]	; (9c4 <GetNumDataFromUser+0x194>)
     956:	781b      	ldrb	r3, [r3, #0]
     958:	2b00      	cmp	r3, #0
     95a:	d10d      	bne.n	978 <GetNumDataFromUser+0x148>
			return CurrentNum;
			
			LCD_Setcursor(Row,NewCol);
     95c:	4658      	mov	r0, fp
     95e:	1c31      	adds	r1, r6, #0
     960:	4b0d      	ldr	r3, [pc, #52]	; (998 <GetNumDataFromUser+0x168>)
     962:	4699      	mov	r9, r3
     964:	4798      	blx	r3
			LCD_DispAscii(Digit[i]);
     966:	b26b      	sxtb	r3, r5
     968:	4641      	mov	r1, r8
     96a:	5cc8      	ldrb	r0, [r1, r3]
     96c:	4b16      	ldr	r3, [pc, #88]	; (9c8 <GetNumDataFromUser+0x198>)
     96e:	4798      	blx	r3
			LCD_Setcursor(Row,NewCol);
     970:	4658      	mov	r0, fp
     972:	1c31      	adds	r1, r6, #0
     974:	47c8      	blx	r9
     976:	e792      	b.n	89e <GetNumDataFromUser+0x6e>
			
			if (EnterKey)
			return CombineDigitstoNumber(Digit,NoofDigit);
			
			if (EscKey)
			return CurrentNum;
     978:	6878      	ldr	r0, [r7, #4]
			LCD_Setcursor(Row,NewCol);
			LCD_DispAscii(Digit[i]);
			LCD_Setcursor(Row,NewCol);
		}
	}
}
     97a:	46bd      	mov	sp, r7
     97c:	b007      	add	sp, #28
     97e:	bc3c      	pop	{r2, r3, r4, r5}
     980:	4690      	mov	r8, r2
     982:	4699      	mov	r9, r3
     984:	46a2      	mov	sl, r4
     986:	46ab      	mov	fp, r5
     988:	bdf0      	pop	{r4, r5, r6, r7, pc}
     98a:	46c0      	nop			; (mov r8, r8)
     98c:	000006d9 	.word	0x000006d9
     990:	00000699 	.word	0x00000699
     994:	000010ed 	.word	0x000010ed
     998:	00000f81 	.word	0x00000f81
     99c:	00001851 	.word	0x00001851
     9a0:	00001635 	.word	0x00001635
     9a4:	00001671 	.word	0x00001671
     9a8:	20000105 	.word	0x20000105
     9ac:	00000681 	.word	0x00000681
     9b0:	20000138 	.word	0x20000138
     9b4:	20000094 	.word	0x20000094
     9b8:	200000ec 	.word	0x200000ec
     9bc:	20000104 	.word	0x20000104
     9c0:	000007a9 	.word	0x000007a9
     9c4:	200000cc 	.word	0x200000cc
     9c8:	00000f41 	.word	0x00000f41

000009cc <GetNumDataFromUserWithESC>:
/***********************************************************************************/
/* Gets Numeric data Input from user with the help of Incr, Decr, Next and Prev Key
When ESC key is pressed it returns -1 instead of current no.
Made this function to serve the purpose of CALIBRATION PASSWORD CHK.	*/
/***********************************************************************************/
int32_t GetNumDataFromUserWithESC(int32_t CurrentNum, uint8_t DecimalPos, uint8_t NoofDigit,  char Row, char Col){
     9cc:	b5f0      	push	{r4, r5, r6, r7, lr}
     9ce:	465f      	mov	r7, fp
     9d0:	4656      	mov	r6, sl
     9d2:	464d      	mov	r5, r9
     9d4:	4644      	mov	r4, r8
     9d6:	b4f0      	push	{r4, r5, r6, r7}
     9d8:	b089      	sub	sp, #36	; 0x24
     9da:	af02      	add	r7, sp, #8
     9dc:	1c04      	adds	r4, r0, #0
     9de:	6139      	str	r1, [r7, #16]
     9e0:	4692      	mov	sl, r2
     9e2:	469b      	mov	fp, r3
     9e4:	2140      	movs	r1, #64	; 0x40
     9e6:	5dc9      	ldrb	r1, [r1, r7]
     9e8:	6179      	str	r1, [r7, #20]
	int8_t Digit[NoofDigit];
     9ea:	1c13      	adds	r3, r2, #0
     9ec:	3307      	adds	r3, #7
     9ee:	08db      	lsrs	r3, r3, #3
     9f0:	00db      	lsls	r3, r3, #3
     9f2:	466a      	mov	r2, sp
     9f4:	1ad2      	subs	r2, r2, r3
     9f6:	4695      	mov	sp, r2
     9f8:	ab02      	add	r3, sp, #8
     9fa:	60bb      	str	r3, [r7, #8]
     9fc:	4698      	mov	r8, r3
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
     9fe:	9100      	str	r1, [sp, #0]
     a00:	6939      	ldr	r1, [r7, #16]
     a02:	4652      	mov	r2, sl
     a04:	465b      	mov	r3, fp
     a06:	4d48      	ldr	r5, [pc, #288]	; (b28 <GetNumDataFromUserWithESC+0x15c>)
     a08:	47a8      	blx	r5
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
     a0a:	4652      	mov	r2, sl
     a0c:	b2d2      	uxtb	r2, r2
     a0e:	607a      	str	r2, [r7, #4]
     a10:	b252      	sxtb	r2, r2
     a12:	1c20      	adds	r0, r4, #0
     a14:	68b9      	ldr	r1, [r7, #8]
     a16:	4b45      	ldr	r3, [pc, #276]	; (b2c <GetNumDataFromUserWithESC+0x160>)
     a18:	4798      	blx	r3
	LCD_CursorOn();
     a1a:	4b45      	ldr	r3, [pc, #276]	; (b30 <GetNumDataFromUserWithESC+0x164>)
     a1c:	4798      	blx	r3
	int8_t i=NoofDigit-1;
     a1e:	4653      	mov	r3, sl
     a20:	3b01      	subs	r3, #1
     a22:	b2db      	uxtb	r3, r3
     a24:	60fb      	str	r3, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
     a26:	4658      	mov	r0, fp
     a28:	6979      	ldr	r1, [r7, #20]
     a2a:	4b42      	ldr	r3, [pc, #264]	; (b34 <GetNumDataFromUserWithESC+0x168>)
     a2c:	4798      	blx	r3
	ReleaseKey();
     a2e:	4b42      	ldr	r3, [pc, #264]	; (b38 <GetNumDataFromUserWithESC+0x16c>)
     a30:	4798      	blx	r3
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
	uint8_t NewCol=Col;
     a32:	697e      	ldr	r6, [r7, #20]
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
     a34:	68fd      	ldr	r5, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
	ReleaseKey();
	while(1){
		if (KeyDetected())
     a36:	4c41      	ldr	r4, [pc, #260]	; (b3c <GetNumDataFromUserWithESC+0x170>)
     a38:	47a0      	blx	r4
     a3a:	2800      	cmp	r0, #0
     a3c:	d0fc      	beq.n	a38 <GetNumDataFromUserWithESC+0x6c>
		{
			Keyscan();
     a3e:	4b40      	ldr	r3, [pc, #256]	; (b40 <GetNumDataFromUserWithESC+0x174>)
     a40:	4798      	blx	r3
			if (IncrKey)
     a42:	4940      	ldr	r1, [pc, #256]	; (b44 <GetNumDataFromUserWithESC+0x178>)
     a44:	780b      	ldrb	r3, [r1, #0]
     a46:	2b00      	cmp	r3, #0
     a48:	d00b      	beq.n	a62 <GetNumDataFromUserWithESC+0x96>
			{
				Digit[i]++;
     a4a:	b26a      	sxtb	r2, r5
     a4c:	4691      	mov	r9, r2
     a4e:	4643      	mov	r3, r8
     a50:	444b      	add	r3, r9
     a52:	7818      	ldrb	r0, [r3, #0]
     a54:	3001      	adds	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     a56:	b240      	sxtb	r0, r0
     a58:	4b3b      	ldr	r3, [pc, #236]	; (b48 <GetNumDataFromUserWithESC+0x17c>)
     a5a:	4798      	blx	r3
     a5c:	4641      	mov	r1, r8
     a5e:	4449      	add	r1, r9
     a60:	7008      	strb	r0, [r1, #0]
			}
			
			if (DecrKey)
     a62:	4b3a      	ldr	r3, [pc, #232]	; (b4c <GetNumDataFromUserWithESC+0x180>)
     a64:	781b      	ldrb	r3, [r3, #0]
     a66:	2b00      	cmp	r3, #0
     a68:	d00b      	beq.n	a82 <GetNumDataFromUserWithESC+0xb6>
			{
				Digit[i]--;
     a6a:	b26a      	sxtb	r2, r5
     a6c:	4691      	mov	r9, r2
     a6e:	4643      	mov	r3, r8
     a70:	444b      	add	r3, r9
     a72:	7818      	ldrb	r0, [r3, #0]
     a74:	3801      	subs	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     a76:	b240      	sxtb	r0, r0
     a78:	4b33      	ldr	r3, [pc, #204]	; (b48 <GetNumDataFromUserWithESC+0x17c>)
     a7a:	4798      	blx	r3
     a7c:	4641      	mov	r1, r8
     a7e:	4449      	add	r1, r9
     a80:	7008      	strb	r0, [r1, #0]
			}
			
			if (NextKey || PrevKey)		//shift cursor to right or left with press of Next or Prev key respectively
     a82:	4b33      	ldr	r3, [pc, #204]	; (b50 <GetNumDataFromUserWithESC+0x184>)
     a84:	781b      	ldrb	r3, [r3, #0]
     a86:	2b00      	cmp	r3, #0
     a88:	d103      	bne.n	a92 <GetNumDataFromUserWithESC+0xc6>
     a8a:	4b32      	ldr	r3, [pc, #200]	; (b54 <GetNumDataFromUserWithESC+0x188>)
     a8c:	781b      	ldrb	r3, [r3, #0]
     a8e:	2b00      	cmp	r3, #0
     a90:	d023      	beq.n	ada <GetNumDataFromUserWithESC+0x10e>
			{
				if (NextKey)
     a92:	4b2f      	ldr	r3, [pc, #188]	; (b50 <GetNumDataFromUserWithESC+0x184>)
     a94:	781b      	ldrb	r3, [r3, #0]
     a96:	2b00      	cmp	r3, #0
     a98:	d001      	beq.n	a9e <GetNumDataFromUserWithESC+0xd2>
				i--;
     a9a:	3d01      	subs	r5, #1
     a9c:	b2ed      	uxtb	r5, r5
				if (PrevKey)
     a9e:	4b2d      	ldr	r3, [pc, #180]	; (b54 <GetNumDataFromUserWithESC+0x188>)
     aa0:	781b      	ldrb	r3, [r3, #0]
     aa2:	2b00      	cmp	r3, #0
     aa4:	d001      	beq.n	aaa <GetNumDataFromUserWithESC+0xde>
				i++;
     aa6:	3501      	adds	r5, #1
     aa8:	b2ed      	uxtb	r5, r5
				
				if (i>(NoofDigit-1))
     aaa:	b26b      	sxtb	r3, r5
     aac:	4652      	mov	r2, sl
     aae:	3a01      	subs	r2, #1
     ab0:	4293      	cmp	r3, r2
     ab2:	dc02      	bgt.n	aba <GetNumDataFromUserWithESC+0xee>
				i=0;
				if (i<0)
     ab4:	2b00      	cmp	r3, #0
     ab6:	db02      	blt.n	abe <GetNumDataFromUserWithESC+0xf2>
     ab8:	e002      	b.n	ac0 <GetNumDataFromUserWithESC+0xf4>
				i--;
				if (PrevKey)
				i++;
				
				if (i>(NoofDigit-1))
				i=0;
     aba:	2500      	movs	r5, #0
     abc:	e000      	b.n	ac0 <GetNumDataFromUserWithESC+0xf4>
				if (i<0)
				i=NoofDigit-1;
     abe:	68fd      	ldr	r5, [r7, #12]
				NewCol=Col+NoofDigit-1-i;
     ac0:	697a      	ldr	r2, [r7, #20]
     ac2:	1c16      	adds	r6, r2, #0
     ac4:	4456      	add	r6, sl
     ac6:	1b76      	subs	r6, r6, r5
     ac8:	b2f6      	uxtb	r6, r6
     aca:	1e73      	subs	r3, r6, #1
     acc:	b2db      	uxtb	r3, r3
				if (NewCol>=(Col+NoofDigit-DecimalPos))
     ace:	4452      	add	r2, sl
     ad0:	6939      	ldr	r1, [r7, #16]
     ad2:	1a52      	subs	r2, r2, r1
     ad4:	4293      	cmp	r3, r2
     ad6:	da00      	bge.n	ada <GetNumDataFromUserWithESC+0x10e>
				
				if (i>(NoofDigit-1))
				i=0;
				if (i<0)
				i=NoofDigit-1;
				NewCol=Col+NoofDigit-1-i;
     ad8:	1c1e      	adds	r6, r3, #0
				if (NewCol>=(Col+NoofDigit-DecimalPos))
				NewCol++;
			}
			
			if (EnterKey)
     ada:	4b1f      	ldr	r3, [pc, #124]	; (b58 <GetNumDataFromUserWithESC+0x18c>)
     adc:	781b      	ldrb	r3, [r3, #0]
     ade:	2b00      	cmp	r3, #0
     ae0:	d005      	beq.n	aee <GetNumDataFromUserWithESC+0x122>
			return CombineDigitstoNumber(Digit,NoofDigit);
     ae2:	687a      	ldr	r2, [r7, #4]
     ae4:	b251      	sxtb	r1, r2
     ae6:	68b8      	ldr	r0, [r7, #8]
     ae8:	4b1c      	ldr	r3, [pc, #112]	; (b5c <GetNumDataFromUserWithESC+0x190>)
     aea:	4798      	blx	r3
     aec:	e013      	b.n	b16 <GetNumDataFromUserWithESC+0x14a>
			
			if (EscKey)
     aee:	4b1c      	ldr	r3, [pc, #112]	; (b60 <GetNumDataFromUserWithESC+0x194>)
     af0:	781b      	ldrb	r3, [r3, #0]
     af2:	2b00      	cmp	r3, #0
     af4:	d10d      	bne.n	b12 <GetNumDataFromUserWithESC+0x146>
			return(-1);
			
			LCD_Setcursor(Row,NewCol);
     af6:	4658      	mov	r0, fp
     af8:	1c31      	adds	r1, r6, #0
     afa:	4b0e      	ldr	r3, [pc, #56]	; (b34 <GetNumDataFromUserWithESC+0x168>)
     afc:	4699      	mov	r9, r3
     afe:	4798      	blx	r3
			LCD_DispAscii(Digit[i]);
     b00:	b26b      	sxtb	r3, r5
     b02:	4641      	mov	r1, r8
     b04:	5cc8      	ldrb	r0, [r1, r3]
     b06:	4b17      	ldr	r3, [pc, #92]	; (b64 <GetNumDataFromUserWithESC+0x198>)
     b08:	4798      	blx	r3
			LCD_Setcursor(Row,NewCol);
     b0a:	4658      	mov	r0, fp
     b0c:	1c31      	adds	r1, r6, #0
     b0e:	47c8      	blx	r9
     b10:	e792      	b.n	a38 <GetNumDataFromUserWithESC+0x6c>
			
			if (EnterKey)
			return CombineDigitstoNumber(Digit,NoofDigit);
			
			if (EscKey)
			return(-1);
     b12:	2001      	movs	r0, #1
     b14:	4240      	negs	r0, r0
			LCD_Setcursor(Row,NewCol);
			LCD_DispAscii(Digit[i]);
			LCD_Setcursor(Row,NewCol);
		}
	}
     b16:	46bd      	mov	sp, r7
     b18:	b007      	add	sp, #28
     b1a:	bc3c      	pop	{r2, r3, r4, r5}
     b1c:	4690      	mov	r8, r2
     b1e:	4699      	mov	r9, r3
     b20:	46a2      	mov	sl, r4
     b22:	46ab      	mov	fp, r5
     b24:	bdf0      	pop	{r4, r5, r6, r7, pc}
     b26:	46c0      	nop			; (mov r8, r8)
     b28:	000006d9 	.word	0x000006d9
     b2c:	00000699 	.word	0x00000699
     b30:	000010ed 	.word	0x000010ed
     b34:	00000f81 	.word	0x00000f81
     b38:	00001851 	.word	0x00001851
     b3c:	00001635 	.word	0x00001635
     b40:	00001671 	.word	0x00001671
     b44:	20000105 	.word	0x20000105
     b48:	00000681 	.word	0x00000681
     b4c:	20000138 	.word	0x20000138
     b50:	20000094 	.word	0x20000094
     b54:	200000ec 	.word	0x200000ec
     b58:	20000104 	.word	0x20000104
     b5c:	000007a9 	.word	0x000007a9
     b60:	200000cc 	.word	0x200000cc
     b64:	00000f41 	.word	0x00000f41

00000b68 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
     b68:	b510      	push	{r4, lr}
     b6a:	b082      	sub	sp, #8
     b6c:	1c04      	adds	r4, r0, #0
	/* Check if valid option. */
	if (!_sercom_config.generator_is_set || force_change) {
     b6e:	4b0f      	ldr	r3, [pc, #60]	; (bac <sercom_set_gclk_generator+0x44>)
     b70:	781b      	ldrb	r3, [r3, #0]
     b72:	2b00      	cmp	r3, #0
     b74:	d001      	beq.n	b7a <sercom_set_gclk_generator+0x12>
     b76:	2900      	cmp	r1, #0
     b78:	d00d      	beq.n	b96 <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config. */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
     b7a:	a901      	add	r1, sp, #4
     b7c:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
     b7e:	2013      	movs	r0, #19
     b80:	4b0b      	ldr	r3, [pc, #44]	; (bb0 <sercom_set_gclk_generator+0x48>)
     b82:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
     b84:	2013      	movs	r0, #19
     b86:	4b0b      	ldr	r3, [pc, #44]	; (bb4 <sercom_set_gclk_generator+0x4c>)
     b88:	4798      	blx	r3

		/* Save config. */
		_sercom_config.generator_source = generator_source;
     b8a:	4b08      	ldr	r3, [pc, #32]	; (bac <sercom_set_gclk_generator+0x44>)
     b8c:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
     b8e:	2201      	movs	r2, #1
     b90:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
     b92:	2000      	movs	r0, #0
     b94:	e007      	b.n	ba6 <sercom_set_gclk_generator+0x3e>
	} else if (generator_source == _sercom_config.generator_source) {
     b96:	4b05      	ldr	r3, [pc, #20]	; (bac <sercom_set_gclk_generator+0x44>)
     b98:	785a      	ldrb	r2, [r3, #1]
		/* Return status OK if same config. */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK. */
	return STATUS_ERR_ALREADY_INITIALIZED;
     b9a:	201d      	movs	r0, #29
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config. */
		return STATUS_OK;
     b9c:	1b14      	subs	r4, r2, r4
     b9e:	1e62      	subs	r2, r4, #1
     ba0:	4194      	sbcs	r4, r2
     ba2:	4264      	negs	r4, r4
     ba4:	4020      	ands	r0, r4
	}

	/* Return invalid config to already initialized GCLK. */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
     ba6:	b002      	add	sp, #8
     ba8:	bd10      	pop	{r4, pc}
     baa:	46c0      	nop			; (mov r8, r8)
     bac:	20000038 	.word	0x20000038
     bb0:	00002105 	.word	0x00002105
     bb4:	00002079 	.word	0x00002079

00000bb8 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
     bb8:	4b44      	ldr	r3, [pc, #272]	; (ccc <_sercom_get_default_pad+0x114>)
     bba:	4298      	cmp	r0, r3
     bbc:	d033      	beq.n	c26 <_sercom_get_default_pad+0x6e>
     bbe:	d806      	bhi.n	bce <_sercom_get_default_pad+0x16>
     bc0:	4b43      	ldr	r3, [pc, #268]	; (cd0 <_sercom_get_default_pad+0x118>)
     bc2:	4298      	cmp	r0, r3
     bc4:	d00d      	beq.n	be2 <_sercom_get_default_pad+0x2a>
     bc6:	4b43      	ldr	r3, [pc, #268]	; (cd4 <_sercom_get_default_pad+0x11c>)
     bc8:	4298      	cmp	r0, r3
     bca:	d01b      	beq.n	c04 <_sercom_get_default_pad+0x4c>
     bcc:	e06f      	b.n	cae <_sercom_get_default_pad+0xf6>
     bce:	4b42      	ldr	r3, [pc, #264]	; (cd8 <_sercom_get_default_pad+0x120>)
     bd0:	4298      	cmp	r0, r3
     bd2:	d04a      	beq.n	c6a <_sercom_get_default_pad+0xb2>
     bd4:	4b41      	ldr	r3, [pc, #260]	; (cdc <_sercom_get_default_pad+0x124>)
     bd6:	4298      	cmp	r0, r3
     bd8:	d058      	beq.n	c8c <_sercom_get_default_pad+0xd4>
     bda:	4b41      	ldr	r3, [pc, #260]	; (ce0 <_sercom_get_default_pad+0x128>)
     bdc:	4298      	cmp	r0, r3
     bde:	d166      	bne.n	cae <_sercom_get_default_pad+0xf6>
     be0:	e032      	b.n	c48 <_sercom_get_default_pad+0x90>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     be2:	2901      	cmp	r1, #1
     be4:	d065      	beq.n	cb2 <_sercom_get_default_pad+0xfa>
     be6:	2900      	cmp	r1, #0
     be8:	d004      	beq.n	bf4 <_sercom_get_default_pad+0x3c>
     bea:	2902      	cmp	r1, #2
     bec:	d006      	beq.n	bfc <_sercom_get_default_pad+0x44>
     bee:	2903      	cmp	r1, #3
     bf0:	d006      	beq.n	c00 <_sercom_get_default_pad+0x48>
     bf2:	e001      	b.n	bf8 <_sercom_get_default_pad+0x40>
     bf4:	483b      	ldr	r0, [pc, #236]	; (ce4 <_sercom_get_default_pad+0x12c>)
     bf6:	e067      	b.n	cc8 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     bf8:	2000      	movs	r0, #0
     bfa:	e065      	b.n	cc8 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     bfc:	483a      	ldr	r0, [pc, #232]	; (ce8 <_sercom_get_default_pad+0x130>)
     bfe:	e063      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c00:	483a      	ldr	r0, [pc, #232]	; (cec <_sercom_get_default_pad+0x134>)
     c02:	e061      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c04:	2901      	cmp	r1, #1
     c06:	d056      	beq.n	cb6 <_sercom_get_default_pad+0xfe>
     c08:	2900      	cmp	r1, #0
     c0a:	d004      	beq.n	c16 <_sercom_get_default_pad+0x5e>
     c0c:	2902      	cmp	r1, #2
     c0e:	d006      	beq.n	c1e <_sercom_get_default_pad+0x66>
     c10:	2903      	cmp	r1, #3
     c12:	d006      	beq.n	c22 <_sercom_get_default_pad+0x6a>
     c14:	e001      	b.n	c1a <_sercom_get_default_pad+0x62>
     c16:	2003      	movs	r0, #3
     c18:	e056      	b.n	cc8 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     c1a:	2000      	movs	r0, #0
     c1c:	e054      	b.n	cc8 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     c1e:	4834      	ldr	r0, [pc, #208]	; (cf0 <_sercom_get_default_pad+0x138>)
     c20:	e052      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c22:	4834      	ldr	r0, [pc, #208]	; (cf4 <_sercom_get_default_pad+0x13c>)
     c24:	e050      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c26:	2901      	cmp	r1, #1
     c28:	d047      	beq.n	cba <_sercom_get_default_pad+0x102>
     c2a:	2900      	cmp	r1, #0
     c2c:	d004      	beq.n	c38 <_sercom_get_default_pad+0x80>
     c2e:	2902      	cmp	r1, #2
     c30:	d006      	beq.n	c40 <_sercom_get_default_pad+0x88>
     c32:	2903      	cmp	r1, #3
     c34:	d006      	beq.n	c44 <_sercom_get_default_pad+0x8c>
     c36:	e001      	b.n	c3c <_sercom_get_default_pad+0x84>
     c38:	482f      	ldr	r0, [pc, #188]	; (cf8 <_sercom_get_default_pad+0x140>)
     c3a:	e045      	b.n	cc8 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     c3c:	2000      	movs	r0, #0
     c3e:	e043      	b.n	cc8 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     c40:	482e      	ldr	r0, [pc, #184]	; (cfc <_sercom_get_default_pad+0x144>)
     c42:	e041      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c44:	482e      	ldr	r0, [pc, #184]	; (d00 <_sercom_get_default_pad+0x148>)
     c46:	e03f      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c48:	2901      	cmp	r1, #1
     c4a:	d038      	beq.n	cbe <_sercom_get_default_pad+0x106>
     c4c:	2900      	cmp	r1, #0
     c4e:	d004      	beq.n	c5a <_sercom_get_default_pad+0xa2>
     c50:	2902      	cmp	r1, #2
     c52:	d006      	beq.n	c62 <_sercom_get_default_pad+0xaa>
     c54:	2903      	cmp	r1, #3
     c56:	d006      	beq.n	c66 <_sercom_get_default_pad+0xae>
     c58:	e001      	b.n	c5e <_sercom_get_default_pad+0xa6>
     c5a:	482a      	ldr	r0, [pc, #168]	; (d04 <_sercom_get_default_pad+0x14c>)
     c5c:	e034      	b.n	cc8 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     c5e:	2000      	movs	r0, #0
     c60:	e032      	b.n	cc8 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     c62:	4829      	ldr	r0, [pc, #164]	; (d08 <_sercom_get_default_pad+0x150>)
     c64:	e030      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c66:	4829      	ldr	r0, [pc, #164]	; (d0c <_sercom_get_default_pad+0x154>)
     c68:	e02e      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c6a:	2901      	cmp	r1, #1
     c6c:	d029      	beq.n	cc2 <_sercom_get_default_pad+0x10a>
     c6e:	2900      	cmp	r1, #0
     c70:	d004      	beq.n	c7c <_sercom_get_default_pad+0xc4>
     c72:	2902      	cmp	r1, #2
     c74:	d006      	beq.n	c84 <_sercom_get_default_pad+0xcc>
     c76:	2903      	cmp	r1, #3
     c78:	d006      	beq.n	c88 <_sercom_get_default_pad+0xd0>
     c7a:	e001      	b.n	c80 <_sercom_get_default_pad+0xc8>
     c7c:	4824      	ldr	r0, [pc, #144]	; (d10 <_sercom_get_default_pad+0x158>)
     c7e:	e023      	b.n	cc8 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     c80:	2000      	movs	r0, #0
     c82:	e021      	b.n	cc8 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     c84:	4823      	ldr	r0, [pc, #140]	; (d14 <_sercom_get_default_pad+0x15c>)
     c86:	e01f      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c88:	4823      	ldr	r0, [pc, #140]	; (d18 <_sercom_get_default_pad+0x160>)
     c8a:	e01d      	b.n	cc8 <_sercom_get_default_pad+0x110>
     c8c:	2901      	cmp	r1, #1
     c8e:	d01a      	beq.n	cc6 <_sercom_get_default_pad+0x10e>
     c90:	2900      	cmp	r1, #0
     c92:	d004      	beq.n	c9e <_sercom_get_default_pad+0xe6>
     c94:	2902      	cmp	r1, #2
     c96:	d006      	beq.n	ca6 <_sercom_get_default_pad+0xee>
     c98:	2903      	cmp	r1, #3
     c9a:	d006      	beq.n	caa <_sercom_get_default_pad+0xf2>
     c9c:	e001      	b.n	ca2 <_sercom_get_default_pad+0xea>
     c9e:	481f      	ldr	r0, [pc, #124]	; (d1c <_sercom_get_default_pad+0x164>)
     ca0:	e012      	b.n	cc8 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     ca2:	2000      	movs	r0, #0
     ca4:	e010      	b.n	cc8 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     ca6:	481e      	ldr	r0, [pc, #120]	; (d20 <_sercom_get_default_pad+0x168>)
     ca8:	e00e      	b.n	cc8 <_sercom_get_default_pad+0x110>
     caa:	481e      	ldr	r0, [pc, #120]	; (d24 <_sercom_get_default_pad+0x16c>)
     cac:	e00c      	b.n	cc8 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     cae:	2000      	movs	r0, #0
     cb0:	e00a      	b.n	cc8 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     cb2:	481d      	ldr	r0, [pc, #116]	; (d28 <_sercom_get_default_pad+0x170>)
     cb4:	e008      	b.n	cc8 <_sercom_get_default_pad+0x110>
     cb6:	481d      	ldr	r0, [pc, #116]	; (d2c <_sercom_get_default_pad+0x174>)
     cb8:	e006      	b.n	cc8 <_sercom_get_default_pad+0x110>
     cba:	481d      	ldr	r0, [pc, #116]	; (d30 <_sercom_get_default_pad+0x178>)
     cbc:	e004      	b.n	cc8 <_sercom_get_default_pad+0x110>
     cbe:	481d      	ldr	r0, [pc, #116]	; (d34 <_sercom_get_default_pad+0x17c>)
     cc0:	e002      	b.n	cc8 <_sercom_get_default_pad+0x110>
     cc2:	481d      	ldr	r0, [pc, #116]	; (d38 <_sercom_get_default_pad+0x180>)
     cc4:	e000      	b.n	cc8 <_sercom_get_default_pad+0x110>
     cc6:	481d      	ldr	r0, [pc, #116]	; (d3c <_sercom_get_default_pad+0x184>)
	}

	Assert(false);
	return 0;
}
     cc8:	4770      	bx	lr
     cca:	46c0      	nop			; (mov r8, r8)
     ccc:	42001000 	.word	0x42001000
     cd0:	42000800 	.word	0x42000800
     cd4:	42000c00 	.word	0x42000c00
     cd8:	42001800 	.word	0x42001800
     cdc:	42001c00 	.word	0x42001c00
     ce0:	42001400 	.word	0x42001400
     ce4:	00040003 	.word	0x00040003
     ce8:	00060003 	.word	0x00060003
     cec:	00070003 	.word	0x00070003
     cf0:	001e0003 	.word	0x001e0003
     cf4:	001f0003 	.word	0x001f0003
     cf8:	00080003 	.word	0x00080003
     cfc:	000a0003 	.word	0x000a0003
     d00:	000b0003 	.word	0x000b0003
     d04:	00100003 	.word	0x00100003
     d08:	00120003 	.word	0x00120003
     d0c:	00130003 	.word	0x00130003
     d10:	000c0003 	.word	0x000c0003
     d14:	000e0003 	.word	0x000e0003
     d18:	000f0003 	.word	0x000f0003
     d1c:	00160003 	.word	0x00160003
     d20:	00180003 	.word	0x00180003
     d24:	00190003 	.word	0x00190003
     d28:	00050003 	.word	0x00050003
     d2c:	00010003 	.word	0x00010003
     d30:	00090003 	.word	0x00090003
     d34:	00110003 	.word	0x00110003
     d38:	000d0003 	.word	0x000d0003
     d3c:	00170003 	.word	0x00170003

00000d40 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
     d40:	b570      	push	{r4, r5, r6, lr}
     d42:	b086      	sub	sp, #24
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
     d44:	4a0c      	ldr	r2, [pc, #48]	; (d78 <_sercom_get_sercom_inst_index+0x38>)
     d46:	466b      	mov	r3, sp
     d48:	ca70      	ldmia	r2!, {r4, r5, r6}
     d4a:	c370      	stmia	r3!, {r4, r5, r6}
     d4c:	ca32      	ldmia	r2!, {r1, r4, r5}
     d4e:	c332      	stmia	r3!, {r1, r4, r5}

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
     d50:	9e00      	ldr	r6, [sp, #0]
     d52:	4286      	cmp	r6, r0
     d54:	d006      	beq.n	d64 <_sercom_get_sercom_inst_index+0x24>
{
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     d56:	2301      	movs	r3, #1
     d58:	009a      	lsls	r2, r3, #2
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
     d5a:	4669      	mov	r1, sp
     d5c:	5852      	ldr	r2, [r2, r1]
     d5e:	4282      	cmp	r2, r0
     d60:	d103      	bne.n	d6a <_sercom_get_sercom_inst_index+0x2a>
     d62:	e000      	b.n	d66 <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     d64:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     d66:	b2d8      	uxtb	r0, r3
     d68:	e003      	b.n	d72 <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     d6a:	3301      	adds	r3, #1
     d6c:	2b06      	cmp	r3, #6
     d6e:	d1f3      	bne.n	d58 <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
     d70:	2000      	movs	r0, #0
}
     d72:	b006      	add	sp, #24
     d74:	bd70      	pop	{r4, r5, r6, pc}
     d76:	46c0      	nop			; (mov r8, r8)
     d78:	00002798 	.word	0x00002798

00000d7c <SERCOM0_Handler>:
	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
}

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
     d7c:	b508      	push	{r3, lr}
     d7e:	4b02      	ldr	r3, [pc, #8]	; (d88 <SERCOM0_Handler+0xc>)
     d80:	681b      	ldr	r3, [r3, #0]
     d82:	2000      	movs	r0, #0
     d84:	4798      	blx	r3
     d86:	bd08      	pop	{r3, pc}
     d88:	2000003c 	.word	0x2000003c

00000d8c <SERCOM1_Handler>:
     d8c:	b508      	push	{r3, lr}
     d8e:	4b02      	ldr	r3, [pc, #8]	; (d98 <SERCOM1_Handler+0xc>)
     d90:	685b      	ldr	r3, [r3, #4]
     d92:	2001      	movs	r0, #1
     d94:	4798      	blx	r3
     d96:	bd08      	pop	{r3, pc}
     d98:	2000003c 	.word	0x2000003c

00000d9c <SERCOM2_Handler>:
     d9c:	b508      	push	{r3, lr}
     d9e:	4b02      	ldr	r3, [pc, #8]	; (da8 <SERCOM2_Handler+0xc>)
     da0:	689b      	ldr	r3, [r3, #8]
     da2:	2002      	movs	r0, #2
     da4:	4798      	blx	r3
     da6:	bd08      	pop	{r3, pc}
     da8:	2000003c 	.word	0x2000003c

00000dac <SERCOM3_Handler>:
     dac:	b508      	push	{r3, lr}
     dae:	4b02      	ldr	r3, [pc, #8]	; (db8 <SERCOM3_Handler+0xc>)
     db0:	68db      	ldr	r3, [r3, #12]
     db2:	2003      	movs	r0, #3
     db4:	4798      	blx	r3
     db6:	bd08      	pop	{r3, pc}
     db8:	2000003c 	.word	0x2000003c

00000dbc <SERCOM4_Handler>:
     dbc:	b508      	push	{r3, lr}
     dbe:	4b02      	ldr	r3, [pc, #8]	; (dc8 <SERCOM4_Handler+0xc>)
     dc0:	691b      	ldr	r3, [r3, #16]
     dc2:	2004      	movs	r0, #4
     dc4:	4798      	blx	r3
     dc6:	bd08      	pop	{r3, pc}
     dc8:	2000003c 	.word	0x2000003c

00000dcc <SERCOM5_Handler>:
     dcc:	b508      	push	{r3, lr}
     dce:	4b02      	ldr	r3, [pc, #8]	; (dd8 <SERCOM5_Handler+0xc>)
     dd0:	695b      	ldr	r3, [r3, #20]
     dd2:	2005      	movs	r0, #5
     dd4:	4798      	blx	r3
     dd6:	bd08      	pop	{r3, pc}
     dd8:	2000003c 	.word	0x2000003c

00000ddc <PulseLCD_EN>:
	LCD_CmdWrite(0x80);
	checkbusy();			// Move the Cursor to First line First Position
	LCD_PowerOn();
}

void PulseLCD_EN(void){
     ddc:	b510      	push	{r4, lr}
	PinSet(LCD_EN);
     dde:	2480      	movs	r4, #128	; 0x80
     de0:	0364      	lsls	r4, r4, #13
     de2:	4b04      	ldr	r3, [pc, #16]	; (df4 <PulseLCD_EN+0x18>)
     de4:	601c      	str	r4, [r3, #0]
	delay_us(ENPulse);
     de6:	2002      	movs	r0, #2
     de8:	4b03      	ldr	r3, [pc, #12]	; (df8 <PulseLCD_EN+0x1c>)
     dea:	4798      	blx	r3
	PinClr(LCD_EN);
     dec:	4b03      	ldr	r3, [pc, #12]	; (dfc <PulseLCD_EN+0x20>)
     dee:	601c      	str	r4, [r3, #0]
}
     df0:	bd10      	pop	{r4, pc}
     df2:	46c0      	nop			; (mov r8, r8)
     df4:	41004418 	.word	0x41004418
     df8:	00001241 	.word	0x00001241
     dfc:	41004414 	.word	0x41004414

00000e00 <write4bits>:
			break;
	}
}

void write4bits(uint8_t value)
{
     e00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     e02:	464f      	mov	r7, r9
     e04:	4646      	mov	r6, r8
     e06:	b4c0      	push	{r6, r7}
     e08:	4681      	mov	r9, r0
	for (int i = 0; i < 4; i++)
     e0a:	2400      	movs	r4, #0
	{
		pinMode(_data_pins[i], OUTPUT);
     e0c:	4b0d      	ldr	r3, [pc, #52]	; (e44 <write4bits+0x44>)
     e0e:	4698      	mov	r8, r3
     e10:	4f0d      	ldr	r7, [pc, #52]	; (e48 <write4bits+0x48>)
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
     e12:	4e0e      	ldr	r6, [pc, #56]	; (e4c <write4bits+0x4c>)

void write4bits(uint8_t value)
{
	for (int i = 0; i < 4; i++)
	{
		pinMode(_data_pins[i], OUTPUT);
     e14:	4643      	mov	r3, r8
     e16:	18e5      	adds	r5, r4, r3
     e18:	7828      	ldrb	r0, [r5, #0]
     e1a:	2100      	movs	r1, #0
     e1c:	47b8      	blx	r7
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
     e1e:	7828      	ldrb	r0, [r5, #0]
     e20:	464b      	mov	r3, r9
     e22:	4123      	asrs	r3, r4
     e24:	2101      	movs	r1, #1
     e26:	4019      	ands	r1, r3
     e28:	47b0      	blx	r6
	}
}

void write4bits(uint8_t value)
{
	for (int i = 0; i < 4; i++)
     e2a:	3401      	adds	r4, #1
     e2c:	2c04      	cmp	r4, #4
     e2e:	d1f1      	bne.n	e14 <write4bits+0x14>
	{
		pinMode(_data_pins[i], OUTPUT);
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
	}
	delay_us(5);
     e30:	2005      	movs	r0, #5
     e32:	4b07      	ldr	r3, [pc, #28]	; (e50 <write4bits+0x50>)
     e34:	4798      	blx	r3
	PulseLCD_EN();
     e36:	4b07      	ldr	r3, [pc, #28]	; (e54 <write4bits+0x54>)
     e38:	4798      	blx	r3
}
     e3a:	bc0c      	pop	{r2, r3}
     e3c:	4690      	mov	r8, r2
     e3e:	4699      	mov	r9, r3
     e40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     e42:	46c0      	nop			; (mov r8, r8)
     e44:	200000c8 	.word	0x200000c8
     e48:	000018a5 	.word	0x000018a5
     e4c:	000019a9 	.word	0x000019a9
     e50:	00001241 	.word	0x00001241
     e54:	00000ddd 	.word	0x00000ddd

00000e58 <checkbusy>:
	
}


void checkbusy()		//waits until LCD is busy
{
     e58:	b5f0      	push	{r4, r5, r6, r7, lr}
     e5a:	464f      	mov	r7, r9
     e5c:	4646      	mov	r6, r8
     e5e:	b4c0      	push	{r6, r7}
     e60:	b083      	sub	sp, #12
#ifndef BypassLCD
//delay_ms(2);
	volatile bool p27=1;			// temporary boolean bit var.
     e62:	466c      	mov	r4, sp
     e64:	2301      	movs	r3, #1
     e66:	71e3      	strb	r3, [r4, #7]

//	WritePin(LCD_D7,1);
	pinMode(LCD_D7, INPUT);		//configure lcd_d7 as input
     e68:	2013      	movs	r0, #19
     e6a:	2102      	movs	r1, #2
     e6c:	4b1b      	ldr	r3, [pc, #108]	; (edc <checkbusy+0x84>)
     e6e:	4798      	blx	r3
	PinClr(LCD_RS);
     e70:	2280      	movs	r2, #128	; 0x80
     e72:	00d2      	lsls	r2, r2, #3
     e74:	4b1a      	ldr	r3, [pc, #104]	; (ee0 <checkbusy+0x88>)
     e76:	601a      	str	r2, [r3, #0]
	PinSet(LCD_RWb);	//RWb=1 indicates read operation.
     e78:	2280      	movs	r2, #128	; 0x80
     e7a:	0392      	lsls	r2, r2, #14
     e7c:	4b19      	ldr	r3, [pc, #100]	; (ee4 <checkbusy+0x8c>)
     e7e:	601a      	str	r2, [r3, #0]
	
	while(p27) 
     e80:	79e3      	ldrb	r3, [r4, #7]
     e82:	2b00      	cmp	r3, #0
     e84:	d01a      	beq.n	ebc <checkbusy+0x64>
	{
	PinClr(LCD_EN);
     e86:	4a16      	ldr	r2, [pc, #88]	; (ee0 <checkbusy+0x88>)
     e88:	4690      	mov	r8, r2
     e8a:	2480      	movs	r4, #128	; 0x80
     e8c:	0364      	lsls	r4, r4, #13
     e8e:	46a1      	mov	r9, r4
     e90:	464b      	mov	r3, r9
     e92:	4642      	mov	r2, r8
     e94:	6013      	str	r3, [r2, #0]
	delay_us(ENPulse);
     e96:	2002      	movs	r0, #2
     e98:	4f13      	ldr	r7, [pc, #76]	; (ee8 <checkbusy+0x90>)
     e9a:	47b8      	blx	r7
	PinSet(LCD_EN);
     e9c:	4e11      	ldr	r6, [pc, #68]	; (ee4 <checkbusy+0x8c>)
     e9e:	6034      	str	r4, [r6, #0]

		p27=PinRead(LCD_D7);
     ea0:	4b12      	ldr	r3, [pc, #72]	; (eec <checkbusy+0x94>)
     ea2:	681b      	ldr	r3, [r3, #0]
     ea4:	031b      	lsls	r3, r3, #12
     ea6:	0fdb      	lsrs	r3, r3, #31
     ea8:	466d      	mov	r5, sp
     eaa:	71eb      	strb	r3, [r5, #7]
		
	PinClr(LCD_EN);
     eac:	4643      	mov	r3, r8
     eae:	601c      	str	r4, [r3, #0]
	delay_us(ENPulse);
     eb0:	2002      	movs	r0, #2
     eb2:	47b8      	blx	r7
	PinSet(LCD_EN);
     eb4:	6034      	str	r4, [r6, #0]
//	WritePin(LCD_D7,1);
	pinMode(LCD_D7, INPUT);		//configure lcd_d7 as input
	PinClr(LCD_RS);
	PinSet(LCD_RWb);	//RWb=1 indicates read operation.
	
	while(p27) 
     eb6:	79eb      	ldrb	r3, [r5, #7]
     eb8:	2b00      	cmp	r3, #0
     eba:	d1e9      	bne.n	e90 <checkbusy+0x38>
		
	PinClr(LCD_EN);
	delay_us(ENPulse);
	PinSet(LCD_EN);
	}
	PinClr(LCD_EN);
     ebc:	4b08      	ldr	r3, [pc, #32]	; (ee0 <checkbusy+0x88>)
     ebe:	2280      	movs	r2, #128	; 0x80
     ec0:	0352      	lsls	r2, r2, #13
     ec2:	601a      	str	r2, [r3, #0]
	PinClr(LCD_RWb);
     ec4:	2280      	movs	r2, #128	; 0x80
     ec6:	0392      	lsls	r2, r2, #14
     ec8:	601a      	str	r2, [r3, #0]
	pinMode(LCD_D7,OUT);	//reconfigure LCD_D7 as output
     eca:	2013      	movs	r0, #19
     ecc:	2100      	movs	r1, #0
     ece:	4b03      	ldr	r3, [pc, #12]	; (edc <checkbusy+0x84>)
     ed0:	4798      	blx	r3
#endif
}
     ed2:	b003      	add	sp, #12
     ed4:	bc0c      	pop	{r2, r3}
     ed6:	4690      	mov	r8, r2
     ed8:	4699      	mov	r9, r3
     eda:	bdf0      	pop	{r4, r5, r6, r7, pc}
     edc:	000018a5 	.word	0x000018a5
     ee0:	41004414 	.word	0x41004414
     ee4:	41004418 	.word	0x41004418
     ee8:	00001241 	.word	0x00001241
     eec:	41004420 	.word	0x41004420

00000ef0 <LCD_DataWrite>:
	}
	delay_us(5);
	PulseLCD_EN();
}

void LCD_DataWrite(uint8_t Data){
     ef0:	b538      	push	{r3, r4, r5, lr}
     ef2:	1c05      	adds	r5, r0, #0
	// Select the Data Register by pulling RS High
	PinSet(LCD_RS);
     ef4:	2280      	movs	r2, #128	; 0x80
     ef6:	00d2      	lsls	r2, r2, #3
     ef8:	4b06      	ldr	r3, [pc, #24]	; (f14 <LCD_DataWrite+0x24>)
     efa:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW LOW
	PinClr(LCD_RWb);
     efc:	2280      	movs	r2, #128	; 0x80
     efe:	0392      	lsls	r2, r2, #14
     f00:	4b05      	ldr	r3, [pc, #20]	; (f18 <LCD_DataWrite+0x28>)
     f02:	601a      	str	r2, [r3, #0]
	  
	  write4bits(Data>>4);
     f04:	0900      	lsrs	r0, r0, #4
     f06:	4c05      	ldr	r4, [pc, #20]	; (f1c <LCD_DataWrite+0x2c>)
     f08:	47a0      	blx	r4
	  write4bits(Data);
     f0a:	1c28      	adds	r0, r5, #0
     f0c:	47a0      	blx	r4
	  checkbusy();
     f0e:	4b04      	ldr	r3, [pc, #16]	; (f20 <LCD_DataWrite+0x30>)
     f10:	4798      	blx	r3
}
     f12:	bd38      	pop	{r3, r4, r5, pc}
     f14:	41004418 	.word	0x41004418
     f18:	41004414 	.word	0x41004414
     f1c:	00000e01 	.word	0x00000e01
     f20:	00000e59 	.word	0x00000e59

00000f24 <LCD_Print>:
	checkbusy();
}


void LCD_Print(const char *str)	//usage: LCD_disp("Hello World");
{
     f24:	b538      	push	{r3, r4, r5, lr}
     f26:	1c04      	adds	r4, r0, #0
	while(*str) 			//Till string ends
     f28:	7800      	ldrb	r0, [r0, #0]
     f2a:	2800      	cmp	r0, #0
     f2c:	d005      	beq.n	f3a <LCD_Print+0x16>
	LCD_DataWrite(*str++); 	//Send characters one by one
     f2e:	4d03      	ldr	r5, [pc, #12]	; (f3c <LCD_Print+0x18>)
     f30:	3401      	adds	r4, #1
     f32:	47a8      	blx	r5
}


void LCD_Print(const char *str)	//usage: LCD_disp("Hello World");
{
	while(*str) 			//Till string ends
     f34:	7820      	ldrb	r0, [r4, #0]
     f36:	2800      	cmp	r0, #0
     f38:	d1fa      	bne.n	f30 <LCD_Print+0xc>
	LCD_DataWrite(*str++); 	//Send characters one by one
}
     f3a:	bd38      	pop	{r3, r4, r5, pc}
     f3c:	00000ef1 	.word	0x00000ef1

00000f40 <LCD_DispAscii>:
	while(*str) 			//Till string ends
	LCD_DataWrite(*str++); 	//Send characters one by one
}


void LCD_DispAscii(char a){	//adds 48 offset to data before sending to LCD, can be used to print single digit no on LCD
     f40:	b508      	push	{r3, lr}
	LCD_DataWrite(a+48);
     f42:	3030      	adds	r0, #48	; 0x30
     f44:	b2c0      	uxtb	r0, r0
     f46:	4b01      	ldr	r3, [pc, #4]	; (f4c <LCD_DispAscii+0xc>)
     f48:	4798      	blx	r3
}
     f4a:	bd08      	pop	{r3, pc}
     f4c:	00000ef1 	.word	0x00000ef1

00000f50 <LCD_CmdWrite>:
	write4bits(Data>>4);
	write4bits(Data);
	checkbusy();
}

void LCD_CmdWrite(uint8_t Command){
     f50:	b538      	push	{r3, r4, r5, lr}
     f52:	1c05      	adds	r5, r0, #0
	// Select the Command Register by pulling RS pin LOW
	PinClr(LCD_RS);
     f54:	4b07      	ldr	r3, [pc, #28]	; (f74 <LCD_CmdWrite+0x24>)
     f56:	2280      	movs	r2, #128	; 0x80
     f58:	00d2      	lsls	r2, r2, #3
     f5a:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW pin LOW
	PinClr(LCD_RWb);
     f5c:	2280      	movs	r2, #128	; 0x80
     f5e:	0392      	lsls	r2, r2, #14
     f60:	601a      	str	r2, [r3, #0]
	
	write4bits(Command>>4);
     f62:	0900      	lsrs	r0, r0, #4
     f64:	4c04      	ldr	r4, [pc, #16]	; (f78 <LCD_CmdWrite+0x28>)
     f66:	47a0      	blx	r4
	write4bits(Command);
     f68:	1c28      	adds	r0, r5, #0
     f6a:	47a0      	blx	r4
	checkbusy();
     f6c:	4b03      	ldr	r3, [pc, #12]	; (f7c <LCD_CmdWrite+0x2c>)
     f6e:	4798      	blx	r3
}
     f70:	bd38      	pop	{r3, r4, r5, pc}
     f72:	46c0      	nop			; (mov r8, r8)
     f74:	41004414 	.word	0x41004414
     f78:	00000e01 	.word	0x00000e01
     f7c:	00000e59 	.word	0x00000e59

00000f80 <LCD_Setcursor>:
}

void LCD_Setcursor(char Row, char Column)	
//pass row and column no to this function
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
     f80:	b508      	push	{r3, lr}
	switch(Row)		
     f82:	2802      	cmp	r0, #2
     f84:	d00d      	beq.n	fa2 <LCD_Setcursor+0x22>
     f86:	d802      	bhi.n	f8e <LCD_Setcursor+0xe>
     f88:	2801      	cmp	r0, #1
     f8a:	d005      	beq.n	f98 <LCD_Setcursor+0x18>
     f8c:	e017      	b.n	fbe <LCD_Setcursor+0x3e>
     f8e:	2803      	cmp	r0, #3
     f90:	d00c      	beq.n	fac <LCD_Setcursor+0x2c>
     f92:	2804      	cmp	r0, #4
     f94:	d00f      	beq.n	fb6 <LCD_Setcursor+0x36>
     f96:	e012      	b.n	fbe <LCD_Setcursor+0x3e>
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     f98:	317f      	adds	r1, #127	; 0x7f
     f9a:	b2c8      	uxtb	r0, r1
     f9c:	4b08      	ldr	r3, [pc, #32]	; (fc0 <LCD_Setcursor+0x40>)
     f9e:	4798      	blx	r3
			break;
     fa0:	e00d      	b.n	fbe <LCD_Setcursor+0x3e>
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     fa2:	3941      	subs	r1, #65	; 0x41
     fa4:	b2c8      	uxtb	r0, r1
     fa6:	4b06      	ldr	r3, [pc, #24]	; (fc0 <LCD_Setcursor+0x40>)
     fa8:	4798      	blx	r3
			break;
     faa:	e008      	b.n	fbe <LCD_Setcursor+0x3e>
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     fac:	396d      	subs	r1, #109	; 0x6d
     fae:	b2c8      	uxtb	r0, r1
     fb0:	4b03      	ldr	r3, [pc, #12]	; (fc0 <LCD_Setcursor+0x40>)
     fb2:	4798      	blx	r3
			break;
     fb4:	e003      	b.n	fbe <LCD_Setcursor+0x3e>
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     fb6:	392d      	subs	r1, #45	; 0x2d
     fb8:	b2c8      	uxtb	r0, r1
     fba:	4b01      	ldr	r3, [pc, #4]	; (fc0 <LCD_Setcursor+0x40>)
     fbc:	4798      	blx	r3
			break;
	}
}
     fbe:	bd08      	pop	{r3, pc}
     fc0:	00000f51 	.word	0x00000f51

00000fc4 <LCD_FullDisp>:
void LCD_DispAscii(char a){	//adds 48 offset to data before sending to LCD, can be used to print single digit no on LCD
	LCD_DataWrite(a+48);
}

void LCD_FullDisp(const char *str0,const char *str1,const char *str2,const char *str3 )	//pass a string for each row	
{			
     fc4:	b5f0      	push	{r4, r5, r6, r7, lr}
     fc6:	4647      	mov	r7, r8
     fc8:	b480      	push	{r7}
     fca:	1c04      	adds	r4, r0, #0
     fcc:	4688      	mov	r8, r1
     fce:	1c17      	adds	r7, r2, #0
     fd0:	1c1e      	adds	r6, r3, #0
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     fd2:	2080      	movs	r0, #128	; 0x80
     fd4:	4d09      	ldr	r5, [pc, #36]	; (ffc <LCD_FullDisp+0x38>)
     fd6:	47a8      	blx	r5
void LCD_FullDisp(const char *str0,const char *str1,const char *str2,const char *str3 )	//pass a string for each row	
{			
	
//Fills all four lines of LCD with the passed strings msg.
	LCD_Setcursor(1,1);
	LCD_Print(str0);
     fd8:	1c20      	adds	r0, r4, #0
     fda:	4c09      	ldr	r4, [pc, #36]	; (1000 <LCD_FullDisp+0x3c>)
     fdc:	47a0      	blx	r4
			case 1:
			LCD_CmdWrite(0x80+Column-1);
			break;
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     fde:	20c0      	movs	r0, #192	; 0xc0
     fe0:	47a8      	blx	r5
//Fills all four lines of LCD with the passed strings msg.
	LCD_Setcursor(1,1);
	LCD_Print(str0);

	LCD_Setcursor(2,1);
	LCD_Print(str1);
     fe2:	4640      	mov	r0, r8
     fe4:	47a0      	blx	r4
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
			break;
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     fe6:	2094      	movs	r0, #148	; 0x94
     fe8:	47a8      	blx	r5

	LCD_Setcursor(2,1);
	LCD_Print(str1);

	LCD_Setcursor(3,1);
	LCD_Print(str2);
     fea:	1c38      	adds	r0, r7, #0
     fec:	47a0      	blx	r4
			case 3:
			LCD_CmdWrite(0x94+Column-1);
			break;
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     fee:	20d4      	movs	r0, #212	; 0xd4
     ff0:	47a8      	blx	r5

	LCD_Setcursor(3,1);
	LCD_Print(str2);

	LCD_Setcursor(4,1);
	LCD_Print(str3);
     ff2:	1c30      	adds	r0, r6, #0
     ff4:	47a0      	blx	r4
	
	
}
     ff6:	bc04      	pop	{r2}
     ff8:	4690      	mov	r8, r2
     ffa:	bdf0      	pop	{r4, r5, r6, r7, pc}
     ffc:	00000f51 	.word	0x00000f51
    1000:	00000f25 	.word	0x00000f25

00001004 <LCD_OneLine>:
	while(*str) 			//Till string ends
	LCD_DataWrite(*str++); 	//Send characters one by one
}

void LCD_OneLine(uint8_t Row, const char *str)	//usage: LCD_disp(2, "Hello World"); to display on 2nd line
{
    1004:	b538      	push	{r3, r4, r5, lr}
    1006:	1c0c      	adds	r4, r1, #0

void LCD_Setcursor(char Row, char Column)	
//pass row and column no to this function
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
    1008:	2802      	cmp	r0, #2
    100a:	d00c      	beq.n	1026 <LCD_OneLine+0x22>
    100c:	d802      	bhi.n	1014 <LCD_OneLine+0x10>
    100e:	2801      	cmp	r0, #1
    1010:	d005      	beq.n	101e <LCD_OneLine+0x1a>
    1012:	e00b      	b.n	102c <LCD_OneLine+0x28>
    1014:	2803      	cmp	r0, #3
    1016:	d00d      	beq.n	1034 <LCD_OneLine+0x30>
    1018:	2804      	cmp	r0, #4
    101a:	d00f      	beq.n	103c <LCD_OneLine+0x38>
    101c:	e006      	b.n	102c <LCD_OneLine+0x28>
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
    101e:	2080      	movs	r0, #128	; 0x80
    1020:	4b0c      	ldr	r3, [pc, #48]	; (1054 <LCD_OneLine+0x50>)
    1022:	4798      	blx	r3
    1024:	e002      	b.n	102c <LCD_OneLine+0x28>
			break;
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
    1026:	20c0      	movs	r0, #192	; 0xc0
    1028:	4b0a      	ldr	r3, [pc, #40]	; (1054 <LCD_OneLine+0x50>)
    102a:	4798      	blx	r3
}

void LCD_OneLine(uint8_t Row, const char *str)	//usage: LCD_disp(2, "Hello World"); to display on 2nd line
{
	LCD_Setcursor(Row,1);
	while(*str) 			//Till string ends
    102c:	7820      	ldrb	r0, [r4, #0]
    102e:	2800      	cmp	r0, #0
    1030:	d108      	bne.n	1044 <LCD_OneLine+0x40>
    1032:	e00d      	b.n	1050 <LCD_OneLine+0x4c>
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
			break;
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
    1034:	2094      	movs	r0, #148	; 0x94
    1036:	4b07      	ldr	r3, [pc, #28]	; (1054 <LCD_OneLine+0x50>)
    1038:	4798      	blx	r3
    103a:	e7f7      	b.n	102c <LCD_OneLine+0x28>
			break;
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
    103c:	20d4      	movs	r0, #212	; 0xd4
    103e:	4b05      	ldr	r3, [pc, #20]	; (1054 <LCD_OneLine+0x50>)
    1040:	4798      	blx	r3
    1042:	e7f3      	b.n	102c <LCD_OneLine+0x28>

void LCD_OneLine(uint8_t Row, const char *str)	//usage: LCD_disp(2, "Hello World"); to display on 2nd line
{
	LCD_Setcursor(Row,1);
	while(*str) 			//Till string ends
	LCD_DataWrite(*str++); 	//Send characters one by one
    1044:	4d04      	ldr	r5, [pc, #16]	; (1058 <LCD_OneLine+0x54>)
    1046:	3401      	adds	r4, #1
    1048:	47a8      	blx	r5
}

void LCD_OneLine(uint8_t Row, const char *str)	//usage: LCD_disp(2, "Hello World"); to display on 2nd line
{
	LCD_Setcursor(Row,1);
	while(*str) 			//Till string ends
    104a:	7820      	ldrb	r0, [r4, #0]
    104c:	2800      	cmp	r0, #0
    104e:	d1fa      	bne.n	1046 <LCD_OneLine+0x42>
	LCD_DataWrite(*str++); 	//Send characters one by one
}
    1050:	bd38      	pop	{r3, r4, r5, pc}
    1052:	46c0      	nop			; (mov r8, r8)
    1054:	00000f51 	.word	0x00000f51
    1058:	00000ef1 	.word	0x00000ef1

0000105c <LCD_build>:
	PinClr(LCD_RWb);
	pinMode(LCD_D7,OUT);	//reconfigure LCD_D7 as output
#endif
}

void LCD_build(uint8_t location, uint8_t *ptr){		//character should be built before writing anything to lcd.
    105c:	b570      	push	{r4, r5, r6, lr}
    105e:	1c0e      	adds	r6, r1, #0
	uint8_t i;
	if(location<8){
    1060:	2807      	cmp	r0, #7
    1062:	d80c      	bhi.n	107e <LCD_build+0x22>
		LCD_CmdWrite(0x40+(location*8));	//since each symbol eats up 8 bytes, location is multiplied by 8
    1064:	3008      	adds	r0, #8
    1066:	00c0      	lsls	r0, r0, #3
    1068:	b2c0      	uxtb	r0, r0
    106a:	4b05      	ldr	r3, [pc, #20]	; (1080 <LCD_build+0x24>)
    106c:	4798      	blx	r3
    106e:	1c34      	adds	r4, r6, #0
    1070:	3608      	adds	r6, #8
		for(i=0;i<8;i++)
		LCD_DataWrite(ptr[ i ]);
    1072:	4d04      	ldr	r5, [pc, #16]	; (1084 <LCD_build+0x28>)
    1074:	7820      	ldrb	r0, [r4, #0]
    1076:	47a8      	blx	r5
    1078:	3401      	adds	r4, #1

void LCD_build(uint8_t location, uint8_t *ptr){		//character should be built before writing anything to lcd.
	uint8_t i;
	if(location<8){
		LCD_CmdWrite(0x40+(location*8));	//since each symbol eats up 8 bytes, location is multiplied by 8
		for(i=0;i<8;i++)
    107a:	42b4      	cmp	r4, r6
    107c:	d1fa      	bne.n	1074 <LCD_build+0x18>
		LCD_DataWrite(ptr[ i ]);
	}
	
}
    107e:	bd70      	pop	{r4, r5, r6, pc}
    1080:	00000f51 	.word	0x00000f51
    1084:	00000ef1 	.word	0x00000ef1

00001088 <LCD_Frame1>:
	LCD_DataWrite(0x10); //Load row 6 data
	LCD_DataWrite(0x10); //Load row 7 data
	LCD_DataWrite(0x00); //Load row 8 data
}

void LCD_Frame1(){
    1088:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
    108a:	2080      	movs	r0, #128	; 0x80
    108c:	4d13      	ldr	r5, [pc, #76]	; (10dc <LCD_Frame1+0x54>)
    108e:	47a8      	blx	r5
	LCD_DataWrite(0x00); //Load row 8 data
}

void LCD_Frame1(){
	LCD_Setcursor(1,1);
	LCD_DataWrite(255);
    1090:	20ff      	movs	r0, #255	; 0xff
    1092:	4c13      	ldr	r4, [pc, #76]	; (10e0 <LCD_Frame1+0x58>)
    1094:	47a0      	blx	r4
	LCD_Print("==================");
    1096:	4f13      	ldr	r7, [pc, #76]	; (10e4 <LCD_Frame1+0x5c>)
    1098:	1c38      	adds	r0, r7, #0
    109a:	4e13      	ldr	r6, [pc, #76]	; (10e8 <LCD_Frame1+0x60>)
    109c:	47b0      	blx	r6
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
    109e:	2093      	movs	r0, #147	; 0x93
    10a0:	47a8      	blx	r5
void LCD_Frame1(){
	LCD_Setcursor(1,1);
	LCD_DataWrite(255);
	LCD_Print("==================");
	LCD_Setcursor(1,20);
	LCD_DataWrite(255);		//block symbol
    10a2:	20ff      	movs	r0, #255	; 0xff
    10a4:	47a0      	blx	r4
			case 3:
			LCD_CmdWrite(0x94+Column-1);
			break;
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
    10a6:	20d4      	movs	r0, #212	; 0xd4
    10a8:	47a8      	blx	r5
	LCD_Print("==================");
	LCD_Setcursor(1,20);
	LCD_DataWrite(255);		//block symbol
	
	LCD_Setcursor(4,1);
	LCD_DataWrite(255);
    10aa:	20ff      	movs	r0, #255	; 0xff
    10ac:	47a0      	blx	r4
	LCD_Print("==================");
    10ae:	1c38      	adds	r0, r7, #0
    10b0:	47b0      	blx	r6
			case 3:
			LCD_CmdWrite(0x94+Column-1);
			break;
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
    10b2:	20e7      	movs	r0, #231	; 0xe7
    10b4:	47a8      	blx	r5
	
	LCD_Setcursor(4,1);
	LCD_DataWrite(255);
	LCD_Print("==================");
	LCD_Setcursor(4,20);
	LCD_DataWrite(255);
    10b6:	20ff      	movs	r0, #255	; 0xff
    10b8:	47a0      	blx	r4
			case 1:
			LCD_CmdWrite(0x80+Column-1);
			break;
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
    10ba:	20c0      	movs	r0, #192	; 0xc0
    10bc:	47a8      	blx	r5
	LCD_Print("==================");
	LCD_Setcursor(4,20);
	LCD_DataWrite(255);
	
	LCD_Setcursor(2,1);
	LCD_DataWrite(0);		// '||' symbol
    10be:	2000      	movs	r0, #0
    10c0:	47a0      	blx	r4
			case 1:
			LCD_CmdWrite(0x80+Column-1);
			break;
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
    10c2:	20d3      	movs	r0, #211	; 0xd3
    10c4:	47a8      	blx	r5
	
	LCD_Setcursor(2,1);
	LCD_DataWrite(0);		// '||' symbol
	
	LCD_Setcursor(2,20);
	LCD_DataWrite(0);
    10c6:	2000      	movs	r0, #0
    10c8:	47a0      	blx	r4
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
			break;
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
    10ca:	2094      	movs	r0, #148	; 0x94
    10cc:	47a8      	blx	r5
	LCD_DataWrite(0);		// '||' symbol
	
	LCD_Setcursor(2,20);
	LCD_DataWrite(0);
	LCD_Setcursor(3,1);
	LCD_DataWrite(0);
    10ce:	2000      	movs	r0, #0
    10d0:	47a0      	blx	r4
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
			break;
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
    10d2:	20a7      	movs	r0, #167	; 0xa7
    10d4:	47a8      	blx	r5
	LCD_Setcursor(2,20);
	LCD_DataWrite(0);
	LCD_Setcursor(3,1);
	LCD_DataWrite(0);
	LCD_Setcursor(3,20);
	LCD_DataWrite(0);
    10d6:	2000      	movs	r0, #0
    10d8:	47a0      	blx	r4
}
    10da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    10dc:	00000f51 	.word	0x00000f51
    10e0:	00000ef1 	.word	0x00000ef1
    10e4:	000027b0 	.word	0x000027b0
    10e8:	00000f25 	.word	0x00000f25

000010ec <LCD_CursorOn>:
	//LCD_DataWrite('|');
	//LCD_Setcursor(3,20);
	//LCD_DataWrite('|');
}

void LCD_CursorOn(){
    10ec:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x0E);
    10ee:	200e      	movs	r0, #14
    10f0:	4b01      	ldr	r3, [pc, #4]	; (10f8 <LCD_CursorOn+0xc>)
    10f2:	4798      	blx	r3
}
    10f4:	bd08      	pop	{r3, pc}
    10f6:	46c0      	nop			; (mov r8, r8)
    10f8:	00000f51 	.word	0x00000f51

000010fc <LCD_CursorOff>:

void LCD_CursorOff(){
    10fc:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x0C);
    10fe:	200c      	movs	r0, #12
    1100:	4b01      	ldr	r3, [pc, #4]	; (1108 <LCD_CursorOff+0xc>)
    1102:	4798      	blx	r3
}
    1104:	bd08      	pop	{r3, pc}
    1106:	46c0      	nop			; (mov r8, r8)
    1108:	00000f51 	.word	0x00000f51

0000110c <LCD_Clrscr>:

void LCD_CursorBlink(){
	LCD_CmdWrite(0x0F);
}

void LCD_Clrscr(){
    110c:	b510      	push	{r4, lr}
	LCD_CmdWrite(0x01);
    110e:	2001      	movs	r0, #1
    1110:	4c02      	ldr	r4, [pc, #8]	; (111c <LCD_Clrscr+0x10>)
    1112:	47a0      	blx	r4
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
    1114:	2080      	movs	r0, #128	; 0x80
    1116:	47a0      	blx	r4
}

void LCD_Clrscr(){
	LCD_CmdWrite(0x01);
	LCD_Setcursor(1,1);
}
    1118:	bd10      	pop	{r4, pc}
    111a:	46c0      	nop			; (mov r8, r8)
    111c:	00000f51 	.word	0x00000f51

00001120 <LCD_PowerOff>:
void LCD_PowerOff(){
    1120:	b508      	push	{r3, lr}
//  [7/25/2015 sajid]
	LCD_CmdWrite(0x13);	//sets internal power off
    1122:	2013      	movs	r0, #19
    1124:	4b02      	ldr	r3, [pc, #8]	; (1130 <LCD_PowerOff+0x10>)
    1126:	4798      	blx	r3
	checkbusy();  
    1128:	4b02      	ldr	r3, [pc, #8]	; (1134 <LCD_PowerOff+0x14>)
    112a:	4798      	blx	r3
//---
}
    112c:	bd08      	pop	{r3, pc}
    112e:	46c0      	nop			; (mov r8, r8)
    1130:	00000f51 	.word	0x00000f51
    1134:	00000e59 	.word	0x00000e59

00001138 <LCD_PowerOn>:
void LCD_PowerOn(){
    1138:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x17);	//sets internal power ON
    113a:	2017      	movs	r0, #23
    113c:	4b02      	ldr	r3, [pc, #8]	; (1148 <LCD_PowerOn+0x10>)
    113e:	4798      	blx	r3
	checkbusy();
    1140:	4b02      	ldr	r3, [pc, #8]	; (114c <LCD_PowerOn+0x14>)
    1142:	4798      	blx	r3
}
    1144:	bd08      	pop	{r3, pc}
    1146:	46c0      	nop			; (mov r8, r8)
    1148:	00000f51 	.word	0x00000f51
    114c:	00000e59 	.word	0x00000e59

00001150 <LCD_Init>:
#include "CharLCD.h"
#include "Delay.h"

	
void LCD_Init(void)
{
    1150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
//First Setup All port pins properly
//Setup port as output and pin LCD_D7 as output with input read enable.
pinMode(LCD_EN, OUTPUT);
    1152:	2014      	movs	r0, #20
    1154:	2100      	movs	r1, #0
    1156:	4c2a      	ldr	r4, [pc, #168]	; (1200 <LCD_Init+0xb0>)
    1158:	47a0      	blx	r4
PinClr(LCD_EN);
    115a:	4d2a      	ldr	r5, [pc, #168]	; (1204 <LCD_Init+0xb4>)
    115c:	2380      	movs	r3, #128	; 0x80
    115e:	035b      	lsls	r3, r3, #13
    1160:	602b      	str	r3, [r5, #0]
pinMode(LCD_D4, OUTPUT);		//D4
    1162:	2010      	movs	r0, #16
    1164:	2100      	movs	r1, #0
    1166:	47a0      	blx	r4
pinMode(LCD_D5, OUTPUT);		//D5
    1168:	2011      	movs	r0, #17
    116a:	2100      	movs	r1, #0
    116c:	47a0      	blx	r4
pinMode(LCD_D6, OUTPUT);		//D6
    116e:	2012      	movs	r0, #18
    1170:	2100      	movs	r1, #0
    1172:	47a0      	blx	r4
pinMode(LCD_D7, OUTPUT);		//D7, will be changed when we need to read back busy flag
    1174:	2013      	movs	r0, #19
    1176:	2100      	movs	r1, #0
    1178:	47a0      	blx	r4

pinMode(LCD_RS, OUTPUT);
    117a:	200a      	movs	r0, #10
    117c:	2100      	movs	r1, #0
    117e:	47a0      	blx	r4
pinMode(LCD_RWb, OUTPUT);
    1180:	2015      	movs	r0, #21
    1182:	2100      	movs	r1, #0
    1184:	47a0      	blx	r4

//------------------------------------------------------------------------

 _data_pins[0] = LCD_D4;
    1186:	4b20      	ldr	r3, [pc, #128]	; (1208 <LCD_Init+0xb8>)
    1188:	2210      	movs	r2, #16
    118a:	701a      	strb	r2, [r3, #0]
 _data_pins[1] = LCD_D5;
    118c:	2211      	movs	r2, #17
    118e:	705a      	strb	r2, [r3, #1]
 _data_pins[2] = LCD_D6;
    1190:	2212      	movs	r2, #18
    1192:	709a      	strb	r2, [r3, #2]
 _data_pins[3] = LCD_D7;
    1194:	2213      	movs	r2, #19
    1196:	70da      	strb	r2, [r3, #3]
 
	
	// Select the Command Register by pulling RS pin LOW
	PinClr(LCD_RS);
    1198:	2380      	movs	r3, #128	; 0x80
    119a:	00db      	lsls	r3, r3, #3
    119c:	602b      	str	r3, [r5, #0]
	// Select the Write Operation  by pulling RW pin LOW
	PinClr(LCD_RWb);
    119e:	2380      	movs	r3, #128	; 0x80
    11a0:	039b      	lsls	r3, r3, #14
    11a2:	602b      	str	r3, [r5, #0]
	

//LCD commands start here

	delay_ms(100);		//w8 for power rail to stabilize
    11a4:	2064      	movs	r0, #100	; 0x64
    11a6:	4e19      	ldr	r6, [pc, #100]	; (120c <LCD_Init+0xbc>)
    11a8:	47b0      	blx	r6
	
		LCD_CmdWrite(0x08);		//Turn off display, very important for OLED
    11aa:	2008      	movs	r0, #8
    11ac:	4d18      	ldr	r5, [pc, #96]	; (1210 <LCD_Init+0xc0>)
    11ae:	47a8      	blx	r5
		checkbusy();
    11b0:	4c18      	ldr	r4, [pc, #96]	; (1214 <LCD_Init+0xc4>)
    11b2:	47a0      	blx	r4
		
	write4bits(0x03);	//put LCD in 8 bit mode
    11b4:	2003      	movs	r0, #3
    11b6:	4f18      	ldr	r7, [pc, #96]	; (1218 <LCD_Init+0xc8>)
    11b8:	47b8      	blx	r7
	delay_ms(100);
    11ba:	2064      	movs	r0, #100	; 0x64
    11bc:	47b0      	blx	r6
	
	write4bits(0x03);	//again
    11be:	2003      	movs	r0, #3
    11c0:	47b8      	blx	r7
	delay_ms(100);
    11c2:	2064      	movs	r0, #100	; 0x64
    11c4:	47b0      	blx	r6
	
	write4bits(0x03);	//again
    11c6:	2003      	movs	r0, #3
    11c8:	47b8      	blx	r7
	delay_ms(100);
    11ca:	2064      	movs	r0, #100	; 0x64
    11cc:	47b0      	blx	r6
	
	write4bits(0x02);  //Initialize the LCD in 4bit Mode
    11ce:	2002      	movs	r0, #2
    11d0:	47b8      	blx	r7
	delay_ms(100);
    11d2:	2064      	movs	r0, #100	; 0x64
    11d4:	47b0      	blx	r6
			
	LCD_CmdWrite(0x28);	//LCD in 4 bit, 2 lines, 5x8 dots 
    11d6:	2028      	movs	r0, #40	; 0x28
    11d8:	47a8      	blx	r5
	checkbusy();
    11da:	47a0      	blx	r4

	//  [7/25/2015 sajid]
	LCD_CmdWrite(0x08);		//Turn off display, very important for OLED
    11dc:	2008      	movs	r0, #8
    11de:	47a8      	blx	r5
	checkbusy();	
    11e0:	47a0      	blx	r4
	//  [7/25/2015 sajid]
	//LCD_PowerOff();
	
	LCD_CmdWrite(0x06);		//Entry mode:Increment, No display shift
    11e2:	2006      	movs	r0, #6
    11e4:	47a8      	blx	r5
	checkbusy();
    11e6:	47a0      	blx	r4
	
	LCD_CmdWrite(0x0E);		// Display ON, cursor ON, Blink Off
    11e8:	200e      	movs	r0, #14
    11ea:	47a8      	blx	r5
	checkbusy();  
    11ec:	47a0      	blx	r4
	
	LCD_CmdWrite(0x01);
    11ee:	2001      	movs	r0, #1
    11f0:	47a8      	blx	r5
	checkbusy();			// Clear the LCD
    11f2:	47a0      	blx	r4
	
	LCD_CmdWrite(0x80);
    11f4:	2080      	movs	r0, #128	; 0x80
    11f6:	47a8      	blx	r5
	checkbusy();			// Move the Cursor to First line First Position
    11f8:	47a0      	blx	r4
	LCD_PowerOn();
    11fa:	4b08      	ldr	r3, [pc, #32]	; (121c <LCD_Init+0xcc>)
    11fc:	4798      	blx	r3
}
    11fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1200:	000018a5 	.word	0x000018a5
    1204:	41004414 	.word	0x41004414
    1208:	200000c8 	.word	0x200000c8
    120c:	00001279 	.word	0x00001279
    1210:	00000f51 	.word	0x00000f51
    1214:	00000e59 	.word	0x00000e59
    1218:	00000e01 	.word	0x00000e01
    121c:	00001139 	.word	0x00001139

00001220 <delay_1us>:
#include "compiler.h"

#include "Delay.h"


 void delay_1us() {			//gives 1 us delay
    1220:	b082      	sub	sp, #8
	 for (volatile int iter=0; iter<2;iter++)
    1222:	2300      	movs	r3, #0
    1224:	9301      	str	r3, [sp, #4]
    1226:	9b01      	ldr	r3, [sp, #4]
    1228:	2b01      	cmp	r3, #1
    122a:	dc07      	bgt.n	123c <delay_1us+0x1c>
	 {
		 asm("NOP");		 
    122c:	46c0      	nop			; (mov r8, r8)
		 asm("NOP");		 
    122e:	46c0      	nop			; (mov r8, r8)

#include "Delay.h"


 void delay_1us() {			//gives 1 us delay
	 for (volatile int iter=0; iter<2;iter++)
    1230:	9b01      	ldr	r3, [sp, #4]
    1232:	3301      	adds	r3, #1
    1234:	9301      	str	r3, [sp, #4]
    1236:	9b01      	ldr	r3, [sp, #4]
    1238:	2b01      	cmp	r3, #1
    123a:	ddf7      	ble.n	122c <delay_1us+0xc>
	 {
		 asm("NOP");		 
		 asm("NOP");		 
	 }
 }
    123c:	b002      	add	sp, #8
    123e:	4770      	bx	lr

00001240 <delay_us>:

void delay_us(volatile uint32_t iter_us){	//gives us delay
    1240:	b510      	push	{r4, lr}
    1242:	b082      	sub	sp, #8
    1244:	9001      	str	r0, [sp, #4]
	while(iter_us!=0){
    1246:	9b01      	ldr	r3, [sp, #4]
    1248:	2b00      	cmp	r3, #0
    124a:	d007      	beq.n	125c <delay_us+0x1c>
		delay_1us();
    124c:	4c04      	ldr	r4, [pc, #16]	; (1260 <delay_us+0x20>)
    124e:	47a0      	blx	r4
		iter_us--;
    1250:	9b01      	ldr	r3, [sp, #4]
    1252:	3b01      	subs	r3, #1
    1254:	9301      	str	r3, [sp, #4]
		 asm("NOP");		 
	 }
 }

void delay_us(volatile uint32_t iter_us){	//gives us delay
	while(iter_us!=0){
    1256:	9b01      	ldr	r3, [sp, #4]
    1258:	2b00      	cmp	r3, #0
    125a:	d1f8      	bne.n	124e <delay_us+0xe>
		delay_1us();
		iter_us--;
	}
}
    125c:	b002      	add	sp, #8
    125e:	bd10      	pop	{r4, pc}
    1260:	00001221 	.word	0x00001221

00001264 <delay_1ms>:

void delay_1ms() {
    1264:	b508      	push	{r3, lr}
		delay_us(1050);	//value adjusted to give 1ms delay
    1266:	4802      	ldr	r0, [pc, #8]	; (1270 <delay_1ms+0xc>)
    1268:	4b02      	ldr	r3, [pc, #8]	; (1274 <delay_1ms+0x10>)
    126a:	4798      	blx	r3

}
    126c:	bd08      	pop	{r3, pc}
    126e:	46c0      	nop			; (mov r8, r8)
    1270:	0000041a 	.word	0x0000041a
    1274:	00001241 	.word	0x00001241

00001278 <delay_ms>:

void delay_ms(volatile uint32_t iter_ms){
    1278:	b510      	push	{r4, lr}
    127a:	b082      	sub	sp, #8
    127c:	9001      	str	r0, [sp, #4]
	while (iter_ms)
    127e:	9b01      	ldr	r3, [sp, #4]
    1280:	2b00      	cmp	r3, #0
    1282:	d007      	beq.n	1294 <delay_ms+0x1c>
	{
		delay_1ms();
    1284:	4c04      	ldr	r4, [pc, #16]	; (1298 <delay_ms+0x20>)
    1286:	47a0      	blx	r4
		iter_ms--;
    1288:	9b01      	ldr	r3, [sp, #4]
    128a:	3b01      	subs	r3, #1
    128c:	9301      	str	r3, [sp, #4]
		delay_us(1050);	//value adjusted to give 1ms delay

}

void delay_ms(volatile uint32_t iter_ms){
	while (iter_ms)
    128e:	9b01      	ldr	r3, [sp, #4]
    1290:	2b00      	cmp	r3, #0
    1292:	d1f8      	bne.n	1286 <delay_ms+0xe>
	{
		delay_1ms();
		iter_ms--;
	}
}
    1294:	b002      	add	sp, #8
    1296:	bd10      	pop	{r4, pc}
    1298:	00001265 	.word	0x00001265

0000129c <delay_sec>:

void delay_sec(volatile uint16_t iter_s){
    129c:	b570      	push	{r4, r5, r6, lr}
    129e:	b082      	sub	sp, #8
    12a0:	466b      	mov	r3, sp
    12a2:	80d8      	strh	r0, [r3, #6]
    12a4:	3306      	adds	r3, #6
	while(iter_s!=0){
    12a6:	881b      	ldrh	r3, [r3, #0]
    12a8:	b29b      	uxth	r3, r3
    12aa:	2b00      	cmp	r3, #0
    12ac:	d00e      	beq.n	12cc <delay_sec+0x30>
		delay_ms(1000);
    12ae:	26fa      	movs	r6, #250	; 0xfa
    12b0:	00b6      	lsls	r6, r6, #2
    12b2:	4d07      	ldr	r5, [pc, #28]	; (12d0 <delay_sec+0x34>)
		iter_s--;
    12b4:	466c      	mov	r4, sp
    12b6:	3406      	adds	r4, #6
	}
}

void delay_sec(volatile uint16_t iter_s){
	while(iter_s!=0){
		delay_ms(1000);
    12b8:	1c30      	adds	r0, r6, #0
    12ba:	47a8      	blx	r5
		iter_s--;
    12bc:	8823      	ldrh	r3, [r4, #0]
    12be:	3b01      	subs	r3, #1
    12c0:	b29b      	uxth	r3, r3
    12c2:	8023      	strh	r3, [r4, #0]
		iter_ms--;
	}
}

void delay_sec(volatile uint16_t iter_s){
	while(iter_s!=0){
    12c4:	8823      	ldrh	r3, [r4, #0]
    12c6:	b29b      	uxth	r3, r3
    12c8:	2b00      	cmp	r3, #0
    12ca:	d1f5      	bne.n	12b8 <delay_sec+0x1c>
		delay_ms(1000);
		iter_s--;
	}
	
    12cc:	b002      	add	sp, #8
    12ce:	bd70      	pop	{r4, r5, r6, pc}
    12d0:	00001279 	.word	0x00001279

000012d4 <LCD_DispFourOptionsIncrementingFrom>:

/************************************************************************/
/* Has all high level function of LCD to Handle Menu based UI			*/
/************************************************************************/

void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
    12d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    12d6:	0085      	lsls	r5, r0, #2
    12d8:	1828      	adds	r0, r5, r0
    12da:	0080      	lsls	r0, r0, #2
    12dc:	180d      	adds	r5, r1, r0
	for (char i=0; i<=3; i++)
    12de:	2400      	movs	r4, #0
	{
		LCD_Setcursor(i+1,1);
    12e0:	4f06      	ldr	r7, [pc, #24]	; (12fc <LCD_DispFourOptionsIncrementingFrom+0x28>)
		LCD_Print(MenuOptions[StartLine+i]);
    12e2:	4e07      	ldr	r6, [pc, #28]	; (1300 <LCD_DispFourOptionsIncrementingFrom+0x2c>)
/************************************************************************/

void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
	for (char i=0; i<=3; i++)
	{
		LCD_Setcursor(i+1,1);
    12e4:	3401      	adds	r4, #1
    12e6:	b2e4      	uxtb	r4, r4
    12e8:	1c20      	adds	r0, r4, #0
    12ea:	2101      	movs	r1, #1
    12ec:	47b8      	blx	r7
		LCD_Print(MenuOptions[StartLine+i]);
    12ee:	1c28      	adds	r0, r5, #0
    12f0:	47b0      	blx	r6
    12f2:	3514      	adds	r5, #20
/************************************************************************/
/* Has all high level function of LCD to Handle Menu based UI			*/
/************************************************************************/

void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
	for (char i=0; i<=3; i++)
    12f4:	2c04      	cmp	r4, #4
    12f6:	d1f5      	bne.n	12e4 <LCD_DispFourOptionsIncrementingFrom+0x10>
	{
		LCD_Setcursor(i+1,1);
		LCD_Print(MenuOptions[StartLine+i]);
	}
	
}
    12f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    12fa:	46c0      	nop			; (mov r8, r8)
    12fc:	00000f81 	.word	0x00000f81
    1300:	00000f25 	.word	0x00000f25

00001304 <LCD_DispMenuArrow>:

void LCD_DispMenuArrow(uint8_t Row){
    1304:	b570      	push	{r4, r5, r6, lr}
    1306:	1c06      	adds	r6, r0, #0
	//arrow symbol pointing menu option is shown at extreme right on LCD
	//Clear other Rows
	LCD_Setcursor(1,20);
    1308:	2001      	movs	r0, #1
    130a:	2114      	movs	r1, #20
    130c:	4d0c      	ldr	r5, [pc, #48]	; (1340 <LCD_DispMenuArrow+0x3c>)
    130e:	47a8      	blx	r5
	LCD_DataWrite(' ');
    1310:	2020      	movs	r0, #32
    1312:	4c0c      	ldr	r4, [pc, #48]	; (1344 <LCD_DispMenuArrow+0x40>)
    1314:	47a0      	blx	r4
	LCD_Setcursor(2,20);
    1316:	2002      	movs	r0, #2
    1318:	2114      	movs	r1, #20
    131a:	47a8      	blx	r5
	LCD_DataWrite(' ');
    131c:	2020      	movs	r0, #32
    131e:	47a0      	blx	r4
	LCD_Setcursor(3,20);
    1320:	2003      	movs	r0, #3
    1322:	2114      	movs	r1, #20
    1324:	47a8      	blx	r5
	LCD_DataWrite(' ');
    1326:	2020      	movs	r0, #32
    1328:	47a0      	blx	r4
	LCD_Setcursor(4,20);
    132a:	2004      	movs	r0, #4
    132c:	2114      	movs	r1, #20
    132e:	47a8      	blx	r5
	LCD_DataWrite(' ');
    1330:	2020      	movs	r0, #32
    1332:	47a0      	blx	r4
	
	LCD_Setcursor(Row,20);
    1334:	1c30      	adds	r0, r6, #0
    1336:	2114      	movs	r1, #20
    1338:	47a8      	blx	r5
	LCD_DataWrite(ARROW);
    133a:	207f      	movs	r0, #127	; 0x7f
    133c:	47a0      	blx	r4
}
    133e:	bd70      	pop	{r4, r5, r6, pc}
    1340:	00000f81 	.word	0x00000f81
    1344:	00000ef1 	.word	0x00000ef1

00001348 <LCD_MenuHandle>:
	MenuIndex=1;
	return MenuIndex;
}

uint8_t LCD_MenuHandle(uint8_t TotalOptions, const char MenuOptions[][LCDCOLS])
{
    1348:	b5f0      	push	{r4, r5, r6, r7, lr}
    134a:	465f      	mov	r7, fp
    134c:	4656      	mov	r6, sl
    134e:	464d      	mov	r5, r9
    1350:	4644      	mov	r4, r8
    1352:	b4f0      	push	{r4, r5, r6, r7}
    1354:	b083      	sub	sp, #12
    1356:	4680      	mov	r8, r0
    1358:	4689      	mov	r9, r1
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
	//In LCD_DispOptionsIncrementingFrom(optionNo, OptionStringArray) DispOptionno is used to keep track of displayed MSG group
	int8_t DispOptionNo=0;
	LCD_DispFourOptionsIncrementingFrom(0, MenuOptions);	//displays Strings from 0 to 3 of the given string 2D array
    135a:	2000      	movs	r0, #0
    135c:	4b3d      	ldr	r3, [pc, #244]	; (1454 <LCD_MenuHandle+0x10c>)
    135e:	4798      	blx	r3
	//displays arrow symbol according to location on LCD at 20th Column and Row given by ArrowLoc
	LCD_DispMenuArrow(ArrowLoc);
    1360:	2001      	movs	r0, #1
    1362:	4b3d      	ldr	r3, [pc, #244]	; (1458 <LCD_MenuHandle+0x110>)
    1364:	4798      	blx	r3
	ReleaseKey();
    1366:	4b3d      	ldr	r3, [pc, #244]	; (145c <LCD_MenuHandle+0x114>)
    1368:	4798      	blx	r3
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
	//In LCD_DispOptionsIncrementingFrom(optionNo, OptionStringArray) DispOptionno is used to keep track of displayed MSG group
	int8_t DispOptionNo=0;
    136a:	2700      	movs	r7, #0
{
	//TotalOptions is nothing but no. of items in menu
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
    136c:	2501      	movs	r5, #1

uint8_t LCD_MenuHandle(uint8_t TotalOptions, const char MenuOptions[][LCDCOLS])
{
	//TotalOptions is nothing but no. of items in menu
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
    136e:	2601      	movs	r6, #1
				MenuIndex++;
				ArrowLoc++;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
				{
					if (DispOptionNo==(TotalOptions-4))
    1370:	2204      	movs	r2, #4
    1372:	4252      	negs	r2, r2
    1374:	4692      	mov	sl, r2
    1376:	44c2      	add	sl, r8
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
				if (ArrowLoc<1)
				{
					if (DispOptionNo==0)
					{
						DispOptionNo=TotalOptions-4;
    1378:	4653      	mov	r3, sl
    137a:	b2db      	uxtb	r3, r3
    137c:	469b      	mov	fp, r3
    137e:	b2da      	uxtb	r2, r3
    1380:	9201      	str	r2, [sp, #4]
	LCD_DispFourOptionsIncrementingFrom(0, MenuOptions);	//displays Strings from 0 to 3 of the given string 2D array
	//displays arrow symbol according to location on LCD at 20th Column and Row given by ArrowLoc
	LCD_DispMenuArrow(ArrowLoc);
	ReleaseKey();
	while(1){	//loop forever, this function will be exited by press EnterKey or ParaKey
		if(KeyDetected())
    1382:	4c37      	ldr	r4, [pc, #220]	; (1460 <LCD_MenuHandle+0x118>)
    1384:	47a0      	blx	r4
    1386:	2800      	cmp	r0, #0
    1388:	d0fc      	beq.n	1384 <LCD_MenuHandle+0x3c>
		{//comes here when key is pressed
			Keyscan();		//check which key is pressed
    138a:	4b36      	ldr	r3, [pc, #216]	; (1464 <LCD_MenuHandle+0x11c>)
    138c:	4798      	blx	r3
			if(IncrKey)		//increment key pressed
    138e:	4b36      	ldr	r3, [pc, #216]	; (1468 <LCD_MenuHandle+0x120>)
    1390:	781b      	ldrb	r3, [r3, #0]
    1392:	2b00      	cmp	r3, #0
    1394:	d021      	beq.n	13da <LCD_MenuHandle+0x92>
			{
				MenuIndex--;
    1396:	3e01      	subs	r6, #1
    1398:	b2f3      	uxtb	r3, r6
				ArrowLoc--;
    139a:	3d01      	subs	r5, #1
    139c:	b2ed      	uxtb	r5, r5
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
    139e:	4642      	mov	r2, r8
    13a0:	b2d6      	uxtb	r6, r2
	LCD_Setcursor(Row,20);
	LCD_DataWrite(ARROW);
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
    13a2:	b25a      	sxtb	r2, r3
    13a4:	2a00      	cmp	r2, #0
    13a6:	dd04      	ble.n	13b2 <LCD_MenuHandle+0x6a>
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
    13a8:	b271      	sxtb	r1, r6
	MenuIndex=1;
    13aa:	2601      	movs	r6, #1
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
    13ac:	428a      	cmp	r2, r1
    13ae:	dc00      	bgt.n	13b2 <LCD_MenuHandle+0x6a>
    13b0:	1c1e      	adds	r6, r3, #0
			if(IncrKey)		//increment key pressed
			{
				MenuIndex--;
				ArrowLoc--;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
				if (ArrowLoc<1)
    13b2:	b26b      	sxtb	r3, r5
    13b4:	2b00      	cmp	r3, #0
    13b6:	dc41      	bgt.n	143c <LCD_MenuHandle+0xf4>
				{
					if (DispOptionNo==0)
    13b8:	2f00      	cmp	r7, #0
    13ba:	d106      	bne.n	13ca <LCD_MenuHandle+0x82>
					{
						DispOptionNo=TotalOptions-4;
    13bc:	9f01      	ldr	r7, [sp, #4]
						ArrowLoc=4;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
    13be:	4658      	mov	r0, fp
    13c0:	4649      	mov	r1, r9
    13c2:	4b24      	ldr	r3, [pc, #144]	; (1454 <LCD_MenuHandle+0x10c>)
    13c4:	4798      	blx	r3
				if (ArrowLoc<1)
				{
					if (DispOptionNo==0)
					{
						DispOptionNo=TotalOptions-4;
						ArrowLoc=4;
    13c6:	2504      	movs	r5, #4
    13c8:	e038      	b.n	143c <LCD_MenuHandle+0xf4>
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
					}
					else
					{
						DispOptionNo--;
    13ca:	3f01      	subs	r7, #1
    13cc:	b2ff      	uxtb	r7, r7
						ArrowLoc=1;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
    13ce:	b2f8      	uxtb	r0, r7
    13d0:	4649      	mov	r1, r9
    13d2:	4b20      	ldr	r3, [pc, #128]	; (1454 <LCD_MenuHandle+0x10c>)
    13d4:	4798      	blx	r3
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
					}
					else
					{
						DispOptionNo--;
						ArrowLoc=1;
    13d6:	2501      	movs	r5, #1
    13d8:	e030      	b.n	143c <LCD_MenuHandle+0xf4>
					}
					
				}
			}

			else if(DecrKey)
    13da:	4b24      	ldr	r3, [pc, #144]	; (146c <LCD_MenuHandle+0x124>)
    13dc:	781b      	ldrb	r3, [r3, #0]
    13de:	2b00      	cmp	r3, #0
    13e0:	d022      	beq.n	1428 <LCD_MenuHandle+0xe0>
			{
				MenuIndex++;
    13e2:	1c73      	adds	r3, r6, #1
    13e4:	b2db      	uxtb	r3, r3
				ArrowLoc++;
    13e6:	3501      	adds	r5, #1
    13e8:	b2ed      	uxtb	r5, r5
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
    13ea:	4642      	mov	r2, r8
    13ec:	b2d6      	uxtb	r6, r2
	LCD_Setcursor(Row,20);
	LCD_DataWrite(ARROW);
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
    13ee:	b25a      	sxtb	r2, r3
    13f0:	2a00      	cmp	r2, #0
    13f2:	dd04      	ble.n	13fe <LCD_MenuHandle+0xb6>
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
    13f4:	b271      	sxtb	r1, r6
	MenuIndex=1;
    13f6:	2601      	movs	r6, #1
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
    13f8:	428a      	cmp	r2, r1
    13fa:	dc00      	bgt.n	13fe <LCD_MenuHandle+0xb6>
    13fc:	1c1e      	adds	r6, r3, #0
			else if(DecrKey)
			{
				MenuIndex++;
				ArrowLoc++;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
    13fe:	b26b      	sxtb	r3, r5
    1400:	2b04      	cmp	r3, #4
    1402:	dd1b      	ble.n	143c <LCD_MenuHandle+0xf4>
				{
					if (DispOptionNo==(TotalOptions-4))
    1404:	b27b      	sxtb	r3, r7
    1406:	4553      	cmp	r3, sl
    1408:	d106      	bne.n	1418 <LCD_MenuHandle+0xd0>
					{
						DispOptionNo=0;
						ArrowLoc=1;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
    140a:	2000      	movs	r0, #0
    140c:	4649      	mov	r1, r9
    140e:	4b11      	ldr	r3, [pc, #68]	; (1454 <LCD_MenuHandle+0x10c>)
    1410:	4798      	blx	r3
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
				{
					if (DispOptionNo==(TotalOptions-4))
					{
						DispOptionNo=0;
    1412:	2700      	movs	r7, #0
						ArrowLoc=1;
    1414:	2501      	movs	r5, #1
    1416:	e011      	b.n	143c <LCD_MenuHandle+0xf4>
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
						
					}
					else
					{
						DispOptionNo++;
    1418:	3701      	adds	r7, #1
    141a:	b2ff      	uxtb	r7, r7
						ArrowLoc=4;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
    141c:	b2f8      	uxtb	r0, r7
    141e:	4649      	mov	r1, r9
    1420:	4b0c      	ldr	r3, [pc, #48]	; (1454 <LCD_MenuHandle+0x10c>)
    1422:	4798      	blx	r3
						
					}
					else
					{
						DispOptionNo++;
						ArrowLoc=4;
    1424:	2504      	movs	r5, #4
    1426:	e009      	b.n	143c <LCD_MenuHandle+0xf4>
					}
					
				}
			}
			
			else if(EnterKey)
    1428:	4b11      	ldr	r3, [pc, #68]	; (1470 <LCD_MenuHandle+0x128>)
    142a:	781b      	ldrb	r3, [r3, #0]
    142c:	2b00      	cmp	r3, #0
    142e:	d001      	beq.n	1434 <LCD_MenuHandle+0xec>
			{
				return MenuIndex;
    1430:	b2f0      	uxtb	r0, r6
    1432:	e008      	b.n	1446 <LCD_MenuHandle+0xfe>
			}
			else if (ParaKey)
    1434:	4b0f      	ldr	r3, [pc, #60]	; (1474 <LCD_MenuHandle+0x12c>)
    1436:	781b      	ldrb	r3, [r3, #0]
    1438:	2b00      	cmp	r3, #0
    143a:	d103      	bne.n	1444 <LCD_MenuHandle+0xfc>
			{
				return 0;
			}
			LCD_DispMenuArrow(ArrowLoc);
    143c:	b2e8      	uxtb	r0, r5
    143e:	4b06      	ldr	r3, [pc, #24]	; (1458 <LCD_MenuHandle+0x110>)
    1440:	4798      	blx	r3
    1442:	e79e      	b.n	1382 <LCD_MenuHandle+0x3a>
			{
				return MenuIndex;
			}
			else if (ParaKey)
			{
				return 0;
    1444:	2000      	movs	r0, #0
			}
			LCD_DispMenuArrow(ArrowLoc);
		}
	}
}
    1446:	b003      	add	sp, #12
    1448:	bc3c      	pop	{r2, r3, r4, r5}
    144a:	4690      	mov	r8, r2
    144c:	4699      	mov	r9, r3
    144e:	46a2      	mov	sl, r4
    1450:	46ab      	mov	fp, r5
    1452:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1454:	000012d5 	.word	0x000012d5
    1458:	00001305 	.word	0x00001305
    145c:	00001851 	.word	0x00001851
    1460:	00001635 	.word	0x00001635
    1464:	00001671 	.word	0x00001671
    1468:	20000105 	.word	0x20000105
    146c:	20000138 	.word	0x20000138
    1470:	20000104 	.word	0x20000104
    1474:	200000cc 	.word	0x200000cc

00001478 <LCD_HorizCurPos>:
	}
}



void LCD_HorizCurPos(char CursorPos, char row1, char col1, char row2, char col2, char row3, char col3){
    1478:	b570      	push	{r4, r5, r6, lr}
    147a:	ac04      	add	r4, sp, #16
    147c:	7825      	ldrb	r5, [r4, #0]
    147e:	ac05      	add	r4, sp, #20
    1480:	7826      	ldrb	r6, [r4, #0]
    1482:	ac06      	add	r4, sp, #24
    1484:	7824      	ldrb	r4, [r4, #0]
	
	switch(CursorPos){
    1486:	2802      	cmp	r0, #2
    1488:	d008      	beq.n	149c <LCD_HorizCurPos+0x24>
    148a:	2803      	cmp	r0, #3
    148c:	d00b      	beq.n	14a6 <LCD_HorizCurPos+0x2e>
    148e:	2801      	cmp	r0, #1
    1490:	d10e      	bne.n	14b0 <LCD_HorizCurPos+0x38>
		case 1:
		LCD_Setcursor(row1,col1);
    1492:	1c08      	adds	r0, r1, #0
    1494:	1c11      	adds	r1, r2, #0
    1496:	4b09      	ldr	r3, [pc, #36]	; (14bc <LCD_HorizCurPos+0x44>)
    1498:	4798      	blx	r3
		break;
    149a:	e00d      	b.n	14b8 <LCD_HorizCurPos+0x40>
		
		case 2:
		LCD_Setcursor(row2,col2);
    149c:	1c18      	adds	r0, r3, #0
    149e:	1c29      	adds	r1, r5, #0
    14a0:	4b06      	ldr	r3, [pc, #24]	; (14bc <LCD_HorizCurPos+0x44>)
    14a2:	4798      	blx	r3
		break;
    14a4:	e008      	b.n	14b8 <LCD_HorizCurPos+0x40>
		
		case 3:
		LCD_Setcursor(row3,col3);
    14a6:	1c30      	adds	r0, r6, #0
    14a8:	1c21      	adds	r1, r4, #0
    14aa:	4b04      	ldr	r3, [pc, #16]	; (14bc <LCD_HorizCurPos+0x44>)
    14ac:	4798      	blx	r3
		break;
    14ae:	e003      	b.n	14b8 <LCD_HorizCurPos+0x40>
		
		default: //any other value will show error on LCD
		LCD_OneLine(2, "Bug: LCD_HorizCur");
    14b0:	2002      	movs	r0, #2
    14b2:	4903      	ldr	r1, [pc, #12]	; (14c0 <LCD_HorizCurPos+0x48>)
    14b4:	4b03      	ldr	r3, [pc, #12]	; (14c4 <LCD_HorizCurPos+0x4c>)
    14b6:	4798      	blx	r3
	}
}
    14b8:	bd70      	pop	{r4, r5, r6, pc}
    14ba:	46c0      	nop			; (mov r8, r8)
    14bc:	00000f81 	.word	0x00000f81
    14c0:	000027f4 	.word	0x000027f4
    14c4:	00001005 	.word	0x00001005

000014c8 <LCD_HorizontalScroll>:
/*	This function takes 2 or 3 options LCD positions and Scrolls 
	between them and returns selected value (1 or 2 or 3)
	row1, col1 corresponds to option1 and so on.
	If only 2 options are there then keep row3 and col3 zero*/
/*******************************************************************/
uint8_t LCD_HorizontalScroll(uint8_t DefaultPosition, char row1, char col1, char row2, char col2, char row3, char col3){
    14c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    14ca:	465f      	mov	r7, fp
    14cc:	4656      	mov	r6, sl
    14ce:	464d      	mov	r5, r9
    14d0:	4644      	mov	r4, r8
    14d2:	b4f0      	push	{r4, r5, r6, r7}
    14d4:	b087      	sub	sp, #28
    14d6:	1c04      	adds	r4, r0, #0
    14d8:	4689      	mov	r9, r1
    14da:	4690      	mov	r8, r2
    14dc:	1c1f      	adds	r7, r3, #0
    14de:	ab10      	add	r3, sp, #64	; 0x40
    14e0:	781b      	ldrb	r3, [r3, #0]
    14e2:	469b      	mov	fp, r3
    14e4:	ab11      	add	r3, sp, #68	; 0x44
    14e6:	781e      	ldrb	r6, [r3, #0]
    14e8:	ab12      	add	r3, sp, #72	; 0x48
    14ea:	781b      	ldrb	r3, [r3, #0]
    14ec:	469a      	mov	sl, r3
	LCD_CursorOn();	
    14ee:	4b30      	ldr	r3, [pc, #192]	; (15b0 <LCD_HorizontalScroll+0xe8>)
    14f0:	4798      	blx	r3
	int8_t NoOfOpt=3;	//by default 3 option are to be scrolled
    14f2:	4273      	negs	r3, r6
    14f4:	4173      	adcs	r3, r6
    14f6:	2203      	movs	r2, #3
    14f8:	1ad2      	subs	r2, r2, r3
    14fa:	9205      	str	r2, [sp, #20]
	//If row3 is 0 means only 2 options are to be scrolled
	if (row3==0)			
	NoOfOpt=2;	// modify no of options
	
	int8_t CurPoint=DefaultPosition;	
    14fc:	b2e5      	uxtb	r5, r4
	//Put cursor on default option position
	LCD_HorizCurPos(DefaultPosition, row1, col1, row2, col2, row3, col3);
    14fe:	4658      	mov	r0, fp
    1500:	9000      	str	r0, [sp, #0]
    1502:	9601      	str	r6, [sp, #4]
    1504:	4651      	mov	r1, sl
    1506:	9102      	str	r1, [sp, #8]
    1508:	1c20      	adds	r0, r4, #0
    150a:	4649      	mov	r1, r9
    150c:	4642      	mov	r2, r8
    150e:	1c3b      	adds	r3, r7, #0
    1510:	4c28      	ldr	r4, [pc, #160]	; (15b4 <LCD_HorizontalScroll+0xec>)
    1512:	47a0      	blx	r4
	ReleaseKey();
    1514:	4b28      	ldr	r3, [pc, #160]	; (15b8 <LCD_HorizontalScroll+0xf0>)
    1516:	4798      	blx	r3
	while(1){	//loop forever, this function will be exited by press EnterKey or ParaKey
		if(KeyDetected())
    1518:	4c28      	ldr	r4, [pc, #160]	; (15bc <LCD_HorizontalScroll+0xf4>)
		{//comes here when key is pressed
			Keyscan();		//check which key is pressed
			if(NextKey)		//increment key pressed
    151a:	1c3b      	adds	r3, r7, #0
    151c:	4647      	mov	r7, r8
    151e:	1c32      	adds	r2, r6, #0
    1520:	4648      	mov	r0, r9
    1522:	9004      	str	r0, [sp, #16]
    1524:	4691      	mov	r9, r2
    1526:	4698      	mov	r8, r3
    1528:	9e04      	ldr	r6, [sp, #16]
	int8_t CurPoint=DefaultPosition;	
	//Put cursor on default option position
	LCD_HorizCurPos(DefaultPosition, row1, col1, row2, col2, row3, col3);
	ReleaseKey();
	while(1){	//loop forever, this function will be exited by press EnterKey or ParaKey
		if(KeyDetected())
    152a:	47a0      	blx	r4
    152c:	2800      	cmp	r0, #0
    152e:	d0fc      	beq.n	152a <LCD_HorizontalScroll+0x62>
    1530:	9604      	str	r6, [sp, #16]
		{//comes here when key is pressed
			Keyscan();		//check which key is pressed
    1532:	4e23      	ldr	r6, [pc, #140]	; (15c0 <LCD_HorizontalScroll+0xf8>)
    1534:	47b0      	blx	r6
			if(NextKey)		//increment key pressed
    1536:	4e23      	ldr	r6, [pc, #140]	; (15c4 <LCD_HorizontalScroll+0xfc>)
    1538:	7833      	ldrb	r3, [r6, #0]
    153a:	2b00      	cmp	r3, #0
    153c:	d007      	beq.n	154e <LCD_HorizontalScroll+0x86>
			{
				CurPoint++;
    153e:	3501      	adds	r5, #1
    1540:	b2ed      	uxtb	r5, r5
				if (CurPoint>NoOfOpt)
    1542:	9e05      	ldr	r6, [sp, #20]
    1544:	b273      	sxtb	r3, r6
    1546:	b26a      	sxtb	r2, r5
    1548:	4293      	cmp	r3, r2
    154a:	db1a      	blt.n	1582 <LCD_HorizontalScroll+0xba>
    154c:	e01c      	b.n	1588 <LCD_HorizontalScroll+0xc0>
					CurPoint=1; //if overflows			
			}

			else if(PrevKey)
    154e:	4b1e      	ldr	r3, [pc, #120]	; (15c8 <LCD_HorizontalScroll+0x100>)
    1550:	781b      	ldrb	r3, [r3, #0]
    1552:	2b00      	cmp	r3, #0
    1554:	d005      	beq.n	1562 <LCD_HorizontalScroll+0x9a>
			{
				CurPoint--;
    1556:	3d01      	subs	r5, #1
    1558:	b2ed      	uxtb	r5, r5
				if (CurPoint<1)
    155a:	b26b      	sxtb	r3, r5
    155c:	2b00      	cmp	r3, #0
    155e:	dc13      	bgt.n	1588 <LCD_HorizontalScroll+0xc0>
    1560:	e011      	b.n	1586 <LCD_HorizontalScroll+0xbe>
					CurPoint=NoOfOpt; //if overflows
			}
			
			else if(EnterKey)				//exit point
    1562:	4b1a      	ldr	r3, [pc, #104]	; (15cc <LCD_HorizontalScroll+0x104>)
    1564:	781b      	ldrb	r3, [r3, #0]
    1566:	2b00      	cmp	r3, #0
    1568:	d003      	beq.n	1572 <LCD_HorizontalScroll+0xaa>
			{
				LCD_CursorOff();
    156a:	4b19      	ldr	r3, [pc, #100]	; (15d0 <LCD_HorizontalScroll+0x108>)
    156c:	4798      	blx	r3
				return (CurPoint);
    156e:	b2e8      	uxtb	r0, r5
    1570:	e017      	b.n	15a2 <LCD_HorizontalScroll+0xda>
			}
			else if (ParaKey)				//exit point
    1572:	4b18      	ldr	r3, [pc, #96]	; (15d4 <LCD_HorizontalScroll+0x10c>)
    1574:	781b      	ldrb	r3, [r3, #0]
    1576:	2b00      	cmp	r3, #0
    1578:	d006      	beq.n	1588 <LCD_HorizontalScroll+0xc0>
			{
				LCD_CursorOff();
    157a:	4b15      	ldr	r3, [pc, #84]	; (15d0 <LCD_HorizontalScroll+0x108>)
    157c:	4798      	blx	r3
				return 0;
    157e:	2000      	movs	r0, #0
    1580:	e00f      	b.n	15a2 <LCD_HorizontalScroll+0xda>
			Keyscan();		//check which key is pressed
			if(NextKey)		//increment key pressed
			{
				CurPoint++;
				if (CurPoint>NoOfOpt)
					CurPoint=1; //if overflows			
    1582:	2501      	movs	r5, #1
    1584:	e000      	b.n	1588 <LCD_HorizontalScroll+0xc0>

			else if(PrevKey)
			{
				CurPoint--;
				if (CurPoint<1)
					CurPoint=NoOfOpt; //if overflows
    1586:	9d05      	ldr	r5, [sp, #20]
			{
				LCD_CursorOff();
				return 0;
			}
			
			LCD_HorizCurPos(CurPoint, row1, col1, row2, col2, row3, col3);
    1588:	b2e8      	uxtb	r0, r5
    158a:	4659      	mov	r1, fp
    158c:	9100      	str	r1, [sp, #0]
    158e:	464a      	mov	r2, r9
    1590:	9201      	str	r2, [sp, #4]
    1592:	4653      	mov	r3, sl
    1594:	9302      	str	r3, [sp, #8]
    1596:	9904      	ldr	r1, [sp, #16]
    1598:	1c3a      	adds	r2, r7, #0
    159a:	4643      	mov	r3, r8
    159c:	4e05      	ldr	r6, [pc, #20]	; (15b4 <LCD_HorizontalScroll+0xec>)
    159e:	47b0      	blx	r6
    15a0:	e7c2      	b.n	1528 <LCD_HorizontalScroll+0x60>

		}
	}

}
    15a2:	b007      	add	sp, #28
    15a4:	bc3c      	pop	{r2, r3, r4, r5}
    15a6:	4690      	mov	r8, r2
    15a8:	4699      	mov	r9, r3
    15aa:	46a2      	mov	sl, r4
    15ac:	46ab      	mov	fp, r5
    15ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    15b0:	000010ed 	.word	0x000010ed
    15b4:	00001479 	.word	0x00001479
    15b8:	00001851 	.word	0x00001851
    15bc:	00001635 	.word	0x00001635
    15c0:	00001671 	.word	0x00001671
    15c4:	20000094 	.word	0x20000094
    15c8:	200000ec 	.word	0x200000ec
    15cc:	20000104 	.word	0x20000104
    15d0:	000010fd 	.word	0x000010fd
    15d4:	200000cc 	.word	0x200000cc

000015d8 <Config_MatrixKeypad>:
2 COL configured as Input with Pull up resistor, and 3 rows as Totem-pole OUTPUT
	1. We will first roughly chk for any key press by making all Rows LOW and Checking Both COL for LOW
	2. If any key detected we will wait for debounce period      
	3. And then clear each ROW and check each col to determine which key is pressed   */
/**********************************************************************************************************/
void Config_MatrixKeypad(){	//call this once in your program
    15d8:	b510      	push	{r4, lr}
	pinMode(COL1, INPUP);		//Make Columns Input with pull up.
    15da:	202d      	movs	r0, #45	; 0x2d
    15dc:	2103      	movs	r1, #3
    15de:	4c07      	ldr	r4, [pc, #28]	; (15fc <Config_MatrixKeypad+0x24>)
    15e0:	47a0      	blx	r4
	pinMode(COL2, INPUP);		//INPUP stands for input with pull up.
    15e2:	202e      	movs	r0, #46	; 0x2e
    15e4:	2103      	movs	r1, #3
    15e6:	47a0      	blx	r4
	//Make ROWs as Output
	pinMode(ROW1, OUTPUT);		
    15e8:	202a      	movs	r0, #42	; 0x2a
    15ea:	2100      	movs	r1, #0
    15ec:	47a0      	blx	r4
	pinMode(ROW2, OUTPUT);		
    15ee:	202b      	movs	r0, #43	; 0x2b
    15f0:	2100      	movs	r1, #0
    15f2:	47a0      	blx	r4
	pinMode(ROW3, OUTPUT);
    15f4:	202c      	movs	r0, #44	; 0x2c
    15f6:	2100      	movs	r1, #0
    15f8:	47a0      	blx	r4
}
    15fa:	bd10      	pop	{r4, pc}
    15fc:	000018a5 	.word	0x000018a5

00001600 <ClearKeys>:

void ClearKeys(){
	ParaKey	=0;
    1600:	2300      	movs	r3, #0
    1602:	4a06      	ldr	r2, [pc, #24]	; (161c <ClearKeys+0x1c>)
    1604:	7013      	strb	r3, [r2, #0]
	RunKey	=0;
    1606:	4a06      	ldr	r2, [pc, #24]	; (1620 <ClearKeys+0x20>)
    1608:	7013      	strb	r3, [r2, #0]
	StartKey=0;
    160a:	4a06      	ldr	r2, [pc, #24]	; (1624 <ClearKeys+0x24>)
    160c:	7013      	strb	r3, [r2, #0]
	StopKey	=0;
    160e:	4a06      	ldr	r2, [pc, #24]	; (1628 <ClearKeys+0x28>)
    1610:	7013      	strb	r3, [r2, #0]
	UpdateKey=0;
    1612:	4a06      	ldr	r2, [pc, #24]	; (162c <ClearKeys+0x2c>)
    1614:	7013      	strb	r3, [r2, #0]
	EnterKey =0;
    1616:	4a06      	ldr	r2, [pc, #24]	; (1630 <ClearKeys+0x30>)
    1618:	7013      	strb	r3, [r2, #0]
}
    161a:	4770      	bx	lr
    161c:	200000cc 	.word	0x200000cc
    1620:	200000ec 	.word	0x200000ec
    1624:	20000105 	.word	0x20000105
    1628:	20000138 	.word	0x20000138
    162c:	20000094 	.word	0x20000094
    1630:	20000104 	.word	0x20000104

00001634 <KeyDetected>:

bool KeyDetected(){
    1634:	b508      	push	{r3, lr}
	PinClr(ROW1);
    1636:	4b0c      	ldr	r3, [pc, #48]	; (1668 <KeyDetected+0x34>)
    1638:	2280      	movs	r2, #128	; 0x80
    163a:	00d2      	lsls	r2, r2, #3
    163c:	601a      	str	r2, [r3, #0]
	PinClr(ROW2);
    163e:	2280      	movs	r2, #128	; 0x80
    1640:	0112      	lsls	r2, r2, #4
    1642:	601a      	str	r2, [r3, #0]
	PinClr(ROW3);
    1644:	2280      	movs	r2, #128	; 0x80
    1646:	0152      	lsls	r2, r2, #5
    1648:	601a      	str	r2, [r3, #0]
	if ((digitalRead(COL1)==0) || (digitalRead(COL2)==0))
    164a:	202d      	movs	r0, #45	; 0x2d
    164c:	4b07      	ldr	r3, [pc, #28]	; (166c <KeyDetected+0x38>)
    164e:	4798      	blx	r3
    1650:	1c03      	adds	r3, r0, #0
	{
		return(true);
    1652:	2001      	movs	r0, #1

bool KeyDetected(){
	PinClr(ROW1);
	PinClr(ROW2);
	PinClr(ROW3);
	if ((digitalRead(COL1)==0) || (digitalRead(COL2)==0))
    1654:	2b00      	cmp	r3, #0
    1656:	d005      	beq.n	1664 <KeyDetected+0x30>
    1658:	202e      	movs	r0, #46	; 0x2e
    165a:	4b04      	ldr	r3, [pc, #16]	; (166c <KeyDetected+0x38>)
    165c:	4798      	blx	r3
    165e:	2301      	movs	r3, #1
    1660:	4058      	eors	r0, r3
    1662:	b2c0      	uxtb	r0, r0
	{
		return(true);
	}
	else
		return(false);
}
    1664:	bd08      	pop	{r3, pc}
    1666:	46c0      	nop			; (mov r8, r8)
    1668:	41004494 	.word	0x41004494
    166c:	000019dd 	.word	0x000019dd

00001670 <Keyscan>:


void Keyscan(){			//call this whenever key status required
    1670:	b5f0      	push	{r4, r5, r6, r7, lr}
    1672:	4657      	mov	r7, sl
    1674:	464e      	mov	r6, r9
    1676:	4645      	mov	r5, r8
    1678:	b4e0      	push	{r5, r6, r7}

	if (KeyDetected())	//if both columns are high, then no key is pressed
    167a:	4b2f      	ldr	r3, [pc, #188]	; (1738 <Keyscan+0xc8>)
    167c:	4798      	blx	r3
    167e:	2800      	cmp	r0, #0
    1680:	d052      	beq.n	1728 <Keyscan+0xb8>
	{	//program will enter when any key is pressed
		delay_ms(debounce_ms);	//debounce delay
    1682:	2014      	movs	r0, #20
    1684:	4b2d      	ldr	r3, [pc, #180]	; (173c <Keyscan+0xcc>)
    1686:	4798      	blx	r3
		if (KeyDetected())	//check again
    1688:	4b2b      	ldr	r3, [pc, #172]	; (1738 <Keyscan+0xc8>)
    168a:	4798      	blx	r3
    168c:	2800      	cmp	r0, #0
    168e:	d048      	beq.n	1722 <Keyscan+0xb2>
		{						 
			//ROW1
			PinClr(ROW1);		//activate ROW 1 and check both columns
    1690:	4f2b      	ldr	r7, [pc, #172]	; (1740 <Keyscan+0xd0>)
    1692:	2380      	movs	r3, #128	; 0x80
    1694:	00db      	lsls	r3, r3, #3
    1696:	469a      	mov	sl, r3
    1698:	603b      	str	r3, [r7, #0]
			PinSet(ROW2);
    169a:	4e2a      	ldr	r6, [pc, #168]	; (1744 <Keyscan+0xd4>)
    169c:	2380      	movs	r3, #128	; 0x80
    169e:	011b      	lsls	r3, r3, #4
    16a0:	4699      	mov	r9, r3
    16a2:	6033      	str	r3, [r6, #0]
			PinSet(ROW3);
    16a4:	2380      	movs	r3, #128	; 0x80
    16a6:	015b      	lsls	r3, r3, #5
    16a8:	4698      	mov	r8, r3
    16aa:	6033      	str	r3, [r6, #0]
			 ParaKey	= !(digitalRead(COL1));
    16ac:	202d      	movs	r0, #45	; 0x2d
    16ae:	4d26      	ldr	r5, [pc, #152]	; (1748 <Keyscan+0xd8>)
    16b0:	47a8      	blx	r5
    16b2:	2401      	movs	r4, #1
    16b4:	4060      	eors	r0, r4
    16b6:	b2c0      	uxtb	r0, r0
    16b8:	4b24      	ldr	r3, [pc, #144]	; (174c <Keyscan+0xdc>)
    16ba:	7018      	strb	r0, [r3, #0]
			 RunKey	= !(digitalRead(COL2));
    16bc:	202e      	movs	r0, #46	; 0x2e
    16be:	47a8      	blx	r5
    16c0:	4060      	eors	r0, r4
    16c2:	b2c0      	uxtb	r0, r0
    16c4:	4b22      	ldr	r3, [pc, #136]	; (1750 <Keyscan+0xe0>)
    16c6:	7018      	strb	r0, [r3, #0]
			
			//ROW2
			PinSet(ROW1);
    16c8:	4653      	mov	r3, sl
    16ca:	6033      	str	r3, [r6, #0]
			PinClr(ROW2);		//activate ROW 2 and check both columns
    16cc:	464b      	mov	r3, r9
    16ce:	603b      	str	r3, [r7, #0]
			PinSet(ROW3);
    16d0:	4643      	mov	r3, r8
    16d2:	6033      	str	r3, [r6, #0]
			 StartKey	= !(digitalRead(COL1));
    16d4:	202d      	movs	r0, #45	; 0x2d
    16d6:	47a8      	blx	r5
    16d8:	4060      	eors	r0, r4
    16da:	b2c0      	uxtb	r0, r0
    16dc:	4b1d      	ldr	r3, [pc, #116]	; (1754 <Keyscan+0xe4>)
    16de:	7018      	strb	r0, [r3, #0]
			 StopKey	= !(digitalRead(COL2));
    16e0:	202e      	movs	r0, #46	; 0x2e
    16e2:	47a8      	blx	r5
    16e4:	4060      	eors	r0, r4
    16e6:	b2c0      	uxtb	r0, r0
    16e8:	4b1b      	ldr	r3, [pc, #108]	; (1758 <Keyscan+0xe8>)
    16ea:	7018      	strb	r0, [r3, #0]
			
			//ROW3
			PinSet(ROW1);		//activate ROW 3 and check both columns
    16ec:	4653      	mov	r3, sl
    16ee:	6033      	str	r3, [r6, #0]
			PinSet(ROW2);
    16f0:	464b      	mov	r3, r9
    16f2:	6033      	str	r3, [r6, #0]
			PinClr(ROW3);
    16f4:	4643      	mov	r3, r8
    16f6:	603b      	str	r3, [r7, #0]
			 UpdateKey= !(digitalRead(COL1));
    16f8:	202d      	movs	r0, #45	; 0x2d
    16fa:	47a8      	blx	r5
    16fc:	4060      	eors	r0, r4
    16fe:	b2c0      	uxtb	r0, r0
    1700:	4b16      	ldr	r3, [pc, #88]	; (175c <Keyscan+0xec>)
    1702:	7018      	strb	r0, [r3, #0]
			 EnterKey = !(digitalRead(COL2));
    1704:	202e      	movs	r0, #46	; 0x2e
    1706:	47a8      	blx	r5
    1708:	4044      	eors	r4, r0
    170a:	b2e0      	uxtb	r0, r4
    170c:	4b14      	ldr	r3, [pc, #80]	; (1760 <Keyscan+0xf0>)
    170e:	7018      	strb	r0, [r3, #0]
			while (KeyDetected())
    1710:	4c09      	ldr	r4, [pc, #36]	; (1738 <Keyscan+0xc8>)
			{
				delay_ms(1);	//w8 until all keys are released
    1712:	4d0a      	ldr	r5, [pc, #40]	; (173c <Keyscan+0xcc>)
			PinSet(ROW1);		//activate ROW 3 and check both columns
			PinSet(ROW2);
			PinClr(ROW3);
			 UpdateKey= !(digitalRead(COL1));
			 EnterKey = !(digitalRead(COL2));
			while (KeyDetected())
    1714:	e001      	b.n	171a <Keyscan+0xaa>
			{
				delay_ms(1);	//w8 until all keys are released
    1716:	2001      	movs	r0, #1
    1718:	47a8      	blx	r5
			PinSet(ROW1);		//activate ROW 3 and check both columns
			PinSet(ROW2);
			PinClr(ROW3);
			 UpdateKey= !(digitalRead(COL1));
			 EnterKey = !(digitalRead(COL2));
			while (KeyDetected())
    171a:	47a0      	blx	r4
    171c:	2800      	cmp	r0, #0
    171e:	d1fa      	bne.n	1716 <Keyscan+0xa6>
    1720:	e004      	b.n	172c <Keyscan+0xbc>
			{
				delay_ms(1);	//w8 until all keys are released
			}
		}
		else
			ClearKeys();	
    1722:	4b10      	ldr	r3, [pc, #64]	; (1764 <Keyscan+0xf4>)
    1724:	4798      	blx	r3
    1726:	e001      	b.n	172c <Keyscan+0xbc>
	}
	else
		ClearKeys();
    1728:	4b0e      	ldr	r3, [pc, #56]	; (1764 <Keyscan+0xf4>)
    172a:	4798      	blx	r3
}
    172c:	bc1c      	pop	{r2, r3, r4}
    172e:	4690      	mov	r8, r2
    1730:	4699      	mov	r9, r3
    1732:	46a2      	mov	sl, r4
    1734:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1736:	46c0      	nop			; (mov r8, r8)
    1738:	00001635 	.word	0x00001635
    173c:	00001279 	.word	0x00001279
    1740:	41004494 	.word	0x41004494
    1744:	41004498 	.word	0x41004498
    1748:	000019dd 	.word	0x000019dd
    174c:	200000cc 	.word	0x200000cc
    1750:	200000ec 	.word	0x200000ec
    1754:	20000105 	.word	0x20000105
    1758:	20000138 	.word	0x20000138
    175c:	20000094 	.word	0x20000094
    1760:	20000104 	.word	0x20000104
    1764:	00001601 	.word	0x00001601

00001768 <KeyscanWORelese>:



void KeyscanWORelese(){			//call this whenever key status required
    1768:	b5f0      	push	{r4, r5, r6, r7, lr}
    176a:	4657      	mov	r7, sl
    176c:	464e      	mov	r6, r9
    176e:	4645      	mov	r5, r8
    1770:	b4e0      	push	{r5, r6, r7}

	if (KeyDetected())	//if both columns are high, then no key is pressed
    1772:	4b2b      	ldr	r3, [pc, #172]	; (1820 <KeyscanWORelese+0xb8>)
    1774:	4798      	blx	r3
    1776:	2800      	cmp	r0, #0
    1778:	d04a      	beq.n	1810 <KeyscanWORelese+0xa8>
	{	//program will enter when any key is pressed
		delay_ms(debounce_ms);	//debounce delay
    177a:	2014      	movs	r0, #20
    177c:	4b29      	ldr	r3, [pc, #164]	; (1824 <KeyscanWORelese+0xbc>)
    177e:	4798      	blx	r3
		if (KeyDetected())	//check again
    1780:	4b27      	ldr	r3, [pc, #156]	; (1820 <KeyscanWORelese+0xb8>)
    1782:	4798      	blx	r3
    1784:	2800      	cmp	r0, #0
    1786:	d040      	beq.n	180a <KeyscanWORelese+0xa2>
		{
			//ROW1
			PinClr(ROW1);		//activate ROW 1 and check both columns
    1788:	4f27      	ldr	r7, [pc, #156]	; (1828 <KeyscanWORelese+0xc0>)
    178a:	2380      	movs	r3, #128	; 0x80
    178c:	00db      	lsls	r3, r3, #3
    178e:	469a      	mov	sl, r3
    1790:	603b      	str	r3, [r7, #0]
			PinSet(ROW2);
    1792:	4e26      	ldr	r6, [pc, #152]	; (182c <KeyscanWORelese+0xc4>)
    1794:	2380      	movs	r3, #128	; 0x80
    1796:	011b      	lsls	r3, r3, #4
    1798:	4699      	mov	r9, r3
    179a:	6033      	str	r3, [r6, #0]
			PinSet(ROW3);
    179c:	2380      	movs	r3, #128	; 0x80
    179e:	015b      	lsls	r3, r3, #5
    17a0:	4698      	mov	r8, r3
    17a2:	6033      	str	r3, [r6, #0]
			ParaKey	= !(digitalRead(COL1));
    17a4:	202d      	movs	r0, #45	; 0x2d
    17a6:	4d22      	ldr	r5, [pc, #136]	; (1830 <KeyscanWORelese+0xc8>)
    17a8:	47a8      	blx	r5
    17aa:	2401      	movs	r4, #1
    17ac:	4060      	eors	r0, r4
    17ae:	b2c0      	uxtb	r0, r0
    17b0:	4b20      	ldr	r3, [pc, #128]	; (1834 <KeyscanWORelese+0xcc>)
    17b2:	7018      	strb	r0, [r3, #0]
			RunKey	= !(digitalRead(COL2));
    17b4:	202e      	movs	r0, #46	; 0x2e
    17b6:	47a8      	blx	r5
    17b8:	4060      	eors	r0, r4
    17ba:	b2c0      	uxtb	r0, r0
    17bc:	4b1e      	ldr	r3, [pc, #120]	; (1838 <KeyscanWORelese+0xd0>)
    17be:	7018      	strb	r0, [r3, #0]
			
			//ROW2
			PinSet(ROW1);
    17c0:	4653      	mov	r3, sl
    17c2:	6033      	str	r3, [r6, #0]
			PinClr(ROW2);		//activate ROW 2 and check both columns
    17c4:	464b      	mov	r3, r9
    17c6:	603b      	str	r3, [r7, #0]
			PinSet(ROW3);
    17c8:	4643      	mov	r3, r8
    17ca:	6033      	str	r3, [r6, #0]
			StartKey	= !(digitalRead(COL1));
    17cc:	202d      	movs	r0, #45	; 0x2d
    17ce:	47a8      	blx	r5
    17d0:	4060      	eors	r0, r4
    17d2:	b2c0      	uxtb	r0, r0
    17d4:	4b19      	ldr	r3, [pc, #100]	; (183c <KeyscanWORelese+0xd4>)
    17d6:	7018      	strb	r0, [r3, #0]
			StopKey	= !(digitalRead(COL2));
    17d8:	202e      	movs	r0, #46	; 0x2e
    17da:	47a8      	blx	r5
    17dc:	4060      	eors	r0, r4
    17de:	b2c0      	uxtb	r0, r0
    17e0:	4b17      	ldr	r3, [pc, #92]	; (1840 <KeyscanWORelese+0xd8>)
    17e2:	7018      	strb	r0, [r3, #0]
			
			//ROW3
			PinSet(ROW1);		//activate ROW 3 and check both columns
    17e4:	4653      	mov	r3, sl
    17e6:	6033      	str	r3, [r6, #0]
			PinSet(ROW2);
    17e8:	464b      	mov	r3, r9
    17ea:	6033      	str	r3, [r6, #0]
			PinClr(ROW3);
    17ec:	4643      	mov	r3, r8
    17ee:	603b      	str	r3, [r7, #0]
			UpdateKey= !(digitalRead(COL1));
    17f0:	202d      	movs	r0, #45	; 0x2d
    17f2:	47a8      	blx	r5
    17f4:	4060      	eors	r0, r4
    17f6:	b2c0      	uxtb	r0, r0
    17f8:	4b12      	ldr	r3, [pc, #72]	; (1844 <KeyscanWORelese+0xdc>)
    17fa:	7018      	strb	r0, [r3, #0]
			EnterKey = !(digitalRead(COL2));
    17fc:	202e      	movs	r0, #46	; 0x2e
    17fe:	47a8      	blx	r5
    1800:	4044      	eors	r4, r0
    1802:	b2e0      	uxtb	r0, r4
    1804:	4b10      	ldr	r3, [pc, #64]	; (1848 <KeyscanWORelese+0xe0>)
    1806:	7018      	strb	r0, [r3, #0]
    1808:	e004      	b.n	1814 <KeyscanWORelese+0xac>
			//{
				//delay_ms(1);	//w8 until all keys are released
			//}
		}
		else
		ClearKeys();
    180a:	4b10      	ldr	r3, [pc, #64]	; (184c <KeyscanWORelese+0xe4>)
    180c:	4798      	blx	r3
    180e:	e001      	b.n	1814 <KeyscanWORelese+0xac>
	}
	else
	ClearKeys();
    1810:	4b0e      	ldr	r3, [pc, #56]	; (184c <KeyscanWORelese+0xe4>)
    1812:	4798      	blx	r3
}
    1814:	bc1c      	pop	{r2, r3, r4}
    1816:	4690      	mov	r8, r2
    1818:	4699      	mov	r9, r3
    181a:	46a2      	mov	sl, r4
    181c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    181e:	46c0      	nop			; (mov r8, r8)
    1820:	00001635 	.word	0x00001635
    1824:	00001279 	.word	0x00001279
    1828:	41004494 	.word	0x41004494
    182c:	41004498 	.word	0x41004498
    1830:	000019dd 	.word	0x000019dd
    1834:	200000cc 	.word	0x200000cc
    1838:	200000ec 	.word	0x200000ec
    183c:	20000105 	.word	0x20000105
    1840:	20000138 	.word	0x20000138
    1844:	20000094 	.word	0x20000094
    1848:	20000104 	.word	0x20000104
    184c:	00001601 	.word	0x00001601

00001850 <ReleaseKey>:



void ReleaseKey(void){
    1850:	b510      	push	{r4, lr}
	delay_ms(debounce_ms);
    1852:	2014      	movs	r0, #20
    1854:	4b04      	ldr	r3, [pc, #16]	; (1868 <ReleaseKey+0x18>)
    1856:	4798      	blx	r3
	while(KeyDetected());
    1858:	4c04      	ldr	r4, [pc, #16]	; (186c <ReleaseKey+0x1c>)
    185a:	47a0      	blx	r4
    185c:	2800      	cmp	r0, #0
    185e:	d1fc      	bne.n	185a <ReleaseKey+0xa>
	delay_ms(debounce_ms);
    1860:	2014      	movs	r0, #20
    1862:	4b01      	ldr	r3, [pc, #4]	; (1868 <ReleaseKey+0x18>)
    1864:	4798      	blx	r3
}
    1866:	bd10      	pop	{r4, pc}
    1868:	00001279 	.word	0x00001279
    186c:	00001635 	.word	0x00001635

00001870 <WaitforAnyKey>:

void WaitforAnyKey(void){
    1870:	b510      	push	{r4, lr}
	delay_ms(debounce_ms);
    1872:	2014      	movs	r0, #20
    1874:	4b04      	ldr	r3, [pc, #16]	; (1888 <WaitforAnyKey+0x18>)
    1876:	4798      	blx	r3
	while(!KeyDetected());
    1878:	4c04      	ldr	r4, [pc, #16]	; (188c <WaitforAnyKey+0x1c>)
    187a:	47a0      	blx	r4
    187c:	2800      	cmp	r0, #0
    187e:	d0fc      	beq.n	187a <WaitforAnyKey+0xa>
	delay_ms(debounce_ms);
    1880:	2014      	movs	r0, #20
    1882:	4b01      	ldr	r3, [pc, #4]	; (1888 <WaitforAnyKey+0x18>)
    1884:	4798      	blx	r3
}
    1886:	bd10      	pop	{r4, pc}
    1888:	00001279 	.word	0x00001279
    188c:	00001635 	.word	0x00001635

00001890 <AnykeyPulse>:
	
/************************************************************************/
/* This function waits for for user to press key and then waits for the key to release*/

/************************************************************************/
void AnykeyPulse(void){
    1890:	b508      	push	{r3, lr}
	WaitforAnyKey();
    1892:	4b02      	ldr	r3, [pc, #8]	; (189c <AnykeyPulse+0xc>)
    1894:	4798      	blx	r3
	ReleaseKey();
    1896:	4b02      	ldr	r3, [pc, #8]	; (18a0 <AnykeyPulse+0x10>)
    1898:	4798      	blx	r3
}
    189a:	bd08      	pop	{r3, pc}
    189c:	00001871 	.word	0x00001871
    18a0:	00001851 	.word	0x00001851

000018a4 <pinMode>:

 OLD approach*/

//usage pinMode(PA15, OUTPUT)
void pinMode(uint8_t Pin, uint8_t mode)
{
    18a4:	b510      	push	{r4, lr}
	if (mode==OUTPUT) {			//strong Totem Pole output
    18a6:	2900      	cmp	r1, #0
    18a8:	d10e      	bne.n	18c8 <pinMode+0x24>
		DIRSET(Pin);			//enable pin as output
    18aa:	0943      	lsrs	r3, r0, #5
    18ac:	01db      	lsls	r3, r3, #7
    18ae:	4939      	ldr	r1, [pc, #228]	; (1994 <pinMode+0xf0>)
    18b0:	185a      	adds	r2, r3, r1
    18b2:	211f      	movs	r1, #31
    18b4:	4008      	ands	r0, r1
    18b6:	2101      	movs	r1, #1
    18b8:	4081      	lsls	r1, r0
    18ba:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)=0;			//disable pull up, input, low drive strength
    18bc:	4a36      	ldr	r2, [pc, #216]	; (1998 <pinMode+0xf4>)
    18be:	1880      	adds	r0, r0, r2
    18c0:	18c3      	adds	r3, r0, r3
    18c2:	2200      	movs	r2, #0
    18c4:	701a      	strb	r2, [r3, #0]
    18c6:	e063      	b.n	1990 <pinMode+0xec>
	}
		
	else if (mode==WEAKOUT){	//pin configured as output with weak pull
    18c8:	2901      	cmp	r1, #1
    18ca:	d110      	bne.n	18ee <pinMode+0x4a>
		DIRCLR(Pin);			//enable pin as output
    18cc:	0943      	lsrs	r3, r0, #5
    18ce:	01db      	lsls	r3, r3, #7
    18d0:	4932      	ldr	r1, [pc, #200]	; (199c <pinMode+0xf8>)
    18d2:	185a      	adds	r2, r3, r1
    18d4:	211f      	movs	r1, #31
    18d6:	4008      	ands	r0, r1
    18d8:	2101      	movs	r1, #1
    18da:	4081      	lsls	r1, r0
    18dc:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b100;		//enable pull RESISTOR
    18de:	4a2e      	ldr	r2, [pc, #184]	; (1998 <pinMode+0xf4>)
    18e0:	1880      	adds	r0, r0, r2
    18e2:	18c0      	adds	r0, r0, r3
    18e4:	7802      	ldrb	r2, [r0, #0]
    18e6:	2304      	movs	r3, #4
    18e8:	4313      	orrs	r3, r2
    18ea:	7003      	strb	r3, [r0, #0]
    18ec:	e050      	b.n	1990 <pinMode+0xec>
	//Pull value will be decided by OUT register value
	//when OUT bit is 1 for a particular pin it will be pulled high and for out bit =0 pin will be pulled low
	}
	
	else if(mode==INPUT) {		//high impedance input
    18ee:	2902      	cmp	r1, #2
    18f0:	d110      	bne.n	1914 <pinMode+0x70>
		DIRCLR(Pin);			//make pin input
    18f2:	0943      	lsrs	r3, r0, #5
    18f4:	01db      	lsls	r3, r3, #7
    18f6:	4929      	ldr	r1, [pc, #164]	; (199c <pinMode+0xf8>)
    18f8:	185a      	adds	r2, r3, r1
    18fa:	211f      	movs	r1, #31
    18fc:	4008      	ands	r0, r1
    18fe:	2101      	movs	r1, #1
    1900:	4081      	lsls	r1, r0
    1902:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b10;		//enable input pin sampling, pull disabled		
    1904:	4a24      	ldr	r2, [pc, #144]	; (1998 <pinMode+0xf4>)
    1906:	1880      	adds	r0, r0, r2
    1908:	18c0      	adds	r0, r0, r3
    190a:	7802      	ldrb	r2, [r0, #0]
    190c:	2302      	movs	r3, #2
    190e:	4313      	orrs	r3, r2
    1910:	7003      	strb	r3, [r0, #0]
    1912:	e03d      	b.n	1990 <pinMode+0xec>
	}
	
	else if (mode==INOUT){		//pin configured as input and output
    1914:	2905      	cmp	r1, #5
    1916:	d110      	bne.n	193a <pinMode+0x96>
		DIRSET(Pin);			//enable pin as output
    1918:	0943      	lsrs	r3, r0, #5
    191a:	01db      	lsls	r3, r3, #7
    191c:	491d      	ldr	r1, [pc, #116]	; (1994 <pinMode+0xf0>)
    191e:	185a      	adds	r2, r3, r1
    1920:	211f      	movs	r1, #31
    1922:	4008      	ands	r0, r1
    1924:	2101      	movs	r1, #1
    1926:	4081      	lsls	r1, r0
    1928:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b10;		//enable input pin sampling
    192a:	4a1b      	ldr	r2, [pc, #108]	; (1998 <pinMode+0xf4>)
    192c:	1880      	adds	r0, r0, r2
    192e:	18c0      	adds	r0, r0, r3
    1930:	7802      	ldrb	r2, [r0, #0]
    1932:	2302      	movs	r3, #2
    1934:	4313      	orrs	r3, r2
    1936:	7003      	strb	r3, [r0, #0]
    1938:	e02a      	b.n	1990 <pinMode+0xec>
	}
	
	else if (mode==INPUP){		//pin configured as input with pull up resistor
    193a:	2903      	cmp	r1, #3
    193c:	d113      	bne.n	1966 <pinMode+0xc2>
		DIRCLR(Pin);			//enable pin as input
    193e:	0943      	lsrs	r3, r0, #5
    1940:	01db      	lsls	r3, r3, #7
    1942:	4a16      	ldr	r2, [pc, #88]	; (199c <pinMode+0xf8>)
    1944:	1899      	adds	r1, r3, r2
    1946:	221f      	movs	r2, #31
    1948:	4010      	ands	r0, r2
    194a:	2201      	movs	r2, #1
    194c:	4082      	lsls	r2, r0
    194e:	600a      	str	r2, [r1, #0]
		PINCFG(Pin)|=0b110;		//enable pull and input pin sampling
    1950:	4911      	ldr	r1, [pc, #68]	; (1998 <pinMode+0xf4>)
    1952:	1840      	adds	r0, r0, r1
    1954:	18c0      	adds	r0, r0, r3
    1956:	7804      	ldrb	r4, [r0, #0]
    1958:	2106      	movs	r1, #6
    195a:	4321      	orrs	r1, r4
    195c:	7001      	strb	r1, [r0, #0]
	//pull value(1 or 0) depends on OUT register value, since we want pull up so we will set 'OUT' register bit
		PinSet(Pin);											
    195e:	4910      	ldr	r1, [pc, #64]	; (19a0 <pinMode+0xfc>)
    1960:	185b      	adds	r3, r3, r1
    1962:	601a      	str	r2, [r3, #0]
    1964:	e014      	b.n	1990 <pinMode+0xec>
	}
	
	else if (mode==INPDN){		//pin configured as input with pull down resistor
    1966:	2904      	cmp	r1, #4
    1968:	d112      	bne.n	1990 <pinMode+0xec>
		DIRCLR(Pin);			//enable pin as input
    196a:	0943      	lsrs	r3, r0, #5
    196c:	01db      	lsls	r3, r3, #7
    196e:	4a0b      	ldr	r2, [pc, #44]	; (199c <pinMode+0xf8>)
    1970:	1899      	adds	r1, r3, r2
    1972:	221f      	movs	r2, #31
    1974:	4010      	ands	r0, r2
    1976:	2201      	movs	r2, #1
    1978:	4082      	lsls	r2, r0
    197a:	600a      	str	r2, [r1, #0]
		PINCFG(Pin)|=0b110;		//enable pull and input pin sampling
    197c:	4906      	ldr	r1, [pc, #24]	; (1998 <pinMode+0xf4>)
    197e:	1840      	adds	r0, r0, r1
    1980:	18c0      	adds	r0, r0, r3
    1982:	7804      	ldrb	r4, [r0, #0]
    1984:	2106      	movs	r1, #6
    1986:	4321      	orrs	r1, r4
    1988:	7001      	strb	r1, [r0, #0]
	//pull value(1 or 0) depends on OUT register value, since we want pull dwn so we will clear 'OUT' register bit
		PinClr(Pin);
    198a:	4906      	ldr	r1, [pc, #24]	; (19a4 <pinMode+0x100>)
    198c:	185b      	adds	r3, r3, r1
    198e:	601a      	str	r2, [r3, #0]
	}
		
}
    1990:	bd10      	pop	{r4, pc}
    1992:	46c0      	nop			; (mov r8, r8)
    1994:	41004408 	.word	0x41004408
    1998:	41004440 	.word	0x41004440
    199c:	41004404 	.word	0x41004404
    19a0:	41004418 	.word	0x41004418
    19a4:	41004414 	.word	0x41004414

000019a8 <digitalWrite>:

//usage digitalWrite(PA20, HIGH); to set pin PA20
//Alternatively you can use PinSet(PA20) and PinClr(pin_no) macros
void digitalWrite(uint8_t pin_no, bool val){
	if (val==1)
    19a8:	2900      	cmp	r1, #0
    19aa:	d009      	beq.n	19c0 <digitalWrite+0x18>
	{
		PinSet(pin_no);
    19ac:	0943      	lsrs	r3, r0, #5
    19ae:	01db      	lsls	r3, r3, #7
    19b0:	4a08      	ldr	r2, [pc, #32]	; (19d4 <digitalWrite+0x2c>)
    19b2:	189b      	adds	r3, r3, r2
    19b4:	221f      	movs	r2, #31
    19b6:	4010      	ands	r0, r2
    19b8:	2201      	movs	r2, #1
    19ba:	4082      	lsls	r2, r0
    19bc:	601a      	str	r2, [r3, #0]
    19be:	e008      	b.n	19d2 <digitalWrite+0x2a>
	}
	else
	{
		
		PinClr(pin_no);
    19c0:	0943      	lsrs	r3, r0, #5
    19c2:	01db      	lsls	r3, r3, #7
    19c4:	4a04      	ldr	r2, [pc, #16]	; (19d8 <digitalWrite+0x30>)
    19c6:	189b      	adds	r3, r3, r2
    19c8:	221f      	movs	r2, #31
    19ca:	4010      	ands	r0, r2
    19cc:	2201      	movs	r2, #1
    19ce:	4082      	lsls	r2, r0
    19d0:	601a      	str	r2, [r3, #0]
	}
}
    19d2:	4770      	bx	lr
    19d4:	41004418 	.word	0x41004418
    19d8:	41004414 	.word	0x41004414

000019dc <digitalRead>:

//usage bool a= digitalRead(PB20); a will contain status of pin PB20
//Alternatively You can use macro function eg:PinRead(PA04), since this function also does the same.
bool digitalRead(uint8_t Pin){
	return(PinRead(Pin));
    19dc:	0943      	lsrs	r3, r0, #5
    19de:	01db      	lsls	r3, r3, #7
    19e0:	4a06      	ldr	r2, [pc, #24]	; (19fc <digitalRead+0x20>)
    19e2:	189b      	adds	r3, r3, r2
    19e4:	681b      	ldr	r3, [r3, #0]
    19e6:	221f      	movs	r2, #31
    19e8:	4010      	ands	r0, r2
    19ea:	2201      	movs	r2, #1
    19ec:	4082      	lsls	r2, r0
    19ee:	1c10      	adds	r0, r2, #0
    19f0:	4018      	ands	r0, r3
    19f2:	1e43      	subs	r3, r0, #1
    19f4:	4198      	sbcs	r0, r3
    19f6:	b2c0      	uxtb	r0, r0
}
    19f8:	4770      	bx	lr
    19fa:	46c0      	nop			; (mov r8, r8)
    19fc:	41004420 	.word	0x41004420

00001a00 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    1a00:	4b0c      	ldr	r3, [pc, #48]	; (1a34 <cpu_irq_enter_critical+0x34>)
    1a02:	681b      	ldr	r3, [r3, #0]
    1a04:	2b00      	cmp	r3, #0
    1a06:	d110      	bne.n	1a2a <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    1a08:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    1a0c:	2b00      	cmp	r3, #0
    1a0e:	d109      	bne.n	1a24 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
    1a10:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    1a12:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    1a16:	2200      	movs	r2, #0
    1a18:	4b07      	ldr	r3, [pc, #28]	; (1a38 <cpu_irq_enter_critical+0x38>)
    1a1a:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    1a1c:	2201      	movs	r2, #1
    1a1e:	4b07      	ldr	r3, [pc, #28]	; (1a3c <cpu_irq_enter_critical+0x3c>)
    1a20:	701a      	strb	r2, [r3, #0]
    1a22:	e002      	b.n	1a2a <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    1a24:	2200      	movs	r2, #0
    1a26:	4b05      	ldr	r3, [pc, #20]	; (1a3c <cpu_irq_enter_critical+0x3c>)
    1a28:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    1a2a:	4b02      	ldr	r3, [pc, #8]	; (1a34 <cpu_irq_enter_critical+0x34>)
    1a2c:	681a      	ldr	r2, [r3, #0]
    1a2e:	3201      	adds	r2, #1
    1a30:	601a      	str	r2, [r3, #0]
}
    1a32:	4770      	bx	lr
    1a34:	20000054 	.word	0x20000054
    1a38:	20000000 	.word	0x20000000
    1a3c:	20000058 	.word	0x20000058

00001a40 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    1a40:	4b08      	ldr	r3, [pc, #32]	; (1a64 <cpu_irq_leave_critical+0x24>)
    1a42:	681a      	ldr	r2, [r3, #0]
    1a44:	3a01      	subs	r2, #1
    1a46:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    1a48:	681b      	ldr	r3, [r3, #0]
    1a4a:	2b00      	cmp	r3, #0
    1a4c:	d109      	bne.n	1a62 <cpu_irq_leave_critical+0x22>
    1a4e:	4b06      	ldr	r3, [pc, #24]	; (1a68 <cpu_irq_leave_critical+0x28>)
    1a50:	781b      	ldrb	r3, [r3, #0]
    1a52:	2b00      	cmp	r3, #0
    1a54:	d005      	beq.n	1a62 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    1a56:	2201      	movs	r2, #1
    1a58:	4b04      	ldr	r3, [pc, #16]	; (1a6c <cpu_irq_leave_critical+0x2c>)
    1a5a:	701a      	strb	r2, [r3, #0]
    1a5c:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
    1a60:	b662      	cpsie	i
	}
}
    1a62:	4770      	bx	lr
    1a64:	20000054 	.word	0x20000054
    1a68:	20000058 	.word	0x20000058
    1a6c:	20000000 	.word	0x20000000

00001a70 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    1a70:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a72:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    1a74:	ac01      	add	r4, sp, #4
    1a76:	2501      	movs	r5, #1
    1a78:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    1a7a:	2700      	movs	r7, #0
    1a7c:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    1a7e:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
    1a80:	203e      	movs	r0, #62	; 0x3e
    1a82:	1c21      	adds	r1, r4, #0
    1a84:	4e06      	ldr	r6, [pc, #24]	; (1aa0 <system_board_init+0x30>)
    1a86:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1a88:	2280      	movs	r2, #128	; 0x80
    1a8a:	05d2      	lsls	r2, r2, #23
    1a8c:	4b05      	ldr	r3, [pc, #20]	; (1aa4 <system_board_init+0x34>)
    1a8e:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    1a90:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    1a92:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    1a94:	200f      	movs	r0, #15
    1a96:	1c21      	adds	r1, r4, #0
    1a98:	47b0      	blx	r6
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
    1a9a:	b003      	add	sp, #12
    1a9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a9e:	46c0      	nop			; (mov r8, r8)
    1aa0:	00001aa9 	.word	0x00001aa9
    1aa4:	41004480 	.word	0x41004480

00001aa8 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    1aa8:	b500      	push	{lr}
    1aaa:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    1aac:	ab01      	add	r3, sp, #4
    1aae:	2280      	movs	r2, #128	; 0x80
    1ab0:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    1ab2:	780a      	ldrb	r2, [r1, #0]
    1ab4:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    1ab6:	784a      	ldrb	r2, [r1, #1]
    1ab8:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    1aba:	788a      	ldrb	r2, [r1, #2]
    1abc:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    1abe:	1c19      	adds	r1, r3, #0
    1ac0:	4b01      	ldr	r3, [pc, #4]	; (1ac8 <port_pin_set_config+0x20>)
    1ac2:	4798      	blx	r3
}
    1ac4:	b003      	add	sp, #12
    1ac6:	bd00      	pop	{pc}
    1ac8:	000021e1 	.word	0x000021e1

00001acc <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    1acc:	b508      	push	{r3, lr}
	switch (clock_source) {
    1ace:	2808      	cmp	r0, #8
    1ad0:	d834      	bhi.n	1b3c <system_clock_source_get_hz+0x70>
    1ad2:	0080      	lsls	r0, r0, #2
    1ad4:	4b1b      	ldr	r3, [pc, #108]	; (1b44 <system_clock_source_get_hz+0x78>)
    1ad6:	581b      	ldr	r3, [r3, r0]
    1ad8:	469f      	mov	pc, r3

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    1ada:	2080      	movs	r0, #128	; 0x80
    1adc:	0200      	lsls	r0, r0, #8
    1ade:	e030      	b.n	1b42 <system_clock_source_get_hz+0x76>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    1ae0:	4b19      	ldr	r3, [pc, #100]	; (1b48 <system_clock_source_get_hz+0x7c>)
    1ae2:	6918      	ldr	r0, [r3, #16]
    1ae4:	e02d      	b.n	1b42 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    1ae6:	4b19      	ldr	r3, [pc, #100]	; (1b4c <system_clock_source_get_hz+0x80>)
    1ae8:	6a18      	ldr	r0, [r3, #32]
    1aea:	0580      	lsls	r0, r0, #22
    1aec:	0f80      	lsrs	r0, r0, #30
    1aee:	4b18      	ldr	r3, [pc, #96]	; (1b50 <system_clock_source_get_hz+0x84>)
    1af0:	40c3      	lsrs	r3, r0
    1af2:	1c18      	adds	r0, r3, #0
    1af4:	e025      	b.n	1b42 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    1af6:	4b14      	ldr	r3, [pc, #80]	; (1b48 <system_clock_source_get_hz+0x7c>)
    1af8:	6958      	ldr	r0, [r3, #20]
    1afa:	e022      	b.n	1b42 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    1afc:	4b12      	ldr	r3, [pc, #72]	; (1b48 <system_clock_source_get_hz+0x7c>)
    1afe:	681b      	ldr	r3, [r3, #0]
    1b00:	2002      	movs	r0, #2
    1b02:	4018      	ands	r0, r3
    1b04:	d01d      	beq.n	1b42 <system_clock_source_get_hz+0x76>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    1b06:	4911      	ldr	r1, [pc, #68]	; (1b4c <system_clock_source_get_hz+0x80>)
    1b08:	2210      	movs	r2, #16
    1b0a:	68cb      	ldr	r3, [r1, #12]
    1b0c:	421a      	tst	r2, r3
    1b0e:	d0fc      	beq.n	1b0a <system_clock_source_get_hz+0x3e>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    1b10:	4b0d      	ldr	r3, [pc, #52]	; (1b48 <system_clock_source_get_hz+0x7c>)
    1b12:	681b      	ldr	r3, [r3, #0]
    1b14:	075a      	lsls	r2, r3, #29
    1b16:	d513      	bpl.n	1b40 <system_clock_source_get_hz+0x74>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    1b18:	2000      	movs	r0, #0
    1b1a:	4b0e      	ldr	r3, [pc, #56]	; (1b54 <system_clock_source_get_hz+0x88>)
    1b1c:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    1b1e:	4b0a      	ldr	r3, [pc, #40]	; (1b48 <system_clock_source_get_hz+0x7c>)
    1b20:	689b      	ldr	r3, [r3, #8]
    1b22:	041b      	lsls	r3, r3, #16
    1b24:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    1b26:	4358      	muls	r0, r3
    1b28:	e00b      	b.n	1b42 <system_clock_source_get_hz+0x76>

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    1b2a:	2350      	movs	r3, #80	; 0x50
    1b2c:	4a07      	ldr	r2, [pc, #28]	; (1b4c <system_clock_source_get_hz+0x80>)
    1b2e:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    1b30:	2000      	movs	r0, #0

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    1b32:	075a      	lsls	r2, r3, #29
    1b34:	d505      	bpl.n	1b42 <system_clock_source_get_hz+0x76>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
    1b36:	4b04      	ldr	r3, [pc, #16]	; (1b48 <system_clock_source_get_hz+0x7c>)
    1b38:	68d8      	ldr	r0, [r3, #12]
    1b3a:	e002      	b.n	1b42 <system_clock_source_get_hz+0x76>
#endif

	default:
		return 0;
    1b3c:	2000      	movs	r0, #0
    1b3e:	e000      	b.n	1b42 <system_clock_source_get_hz+0x76>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    1b40:	4805      	ldr	r0, [pc, #20]	; (1b58 <system_clock_source_get_hz+0x8c>)
#endif

	default:
		return 0;
	}
}
    1b42:	bd08      	pop	{r3, pc}
    1b44:	00002808 	.word	0x00002808
    1b48:	2000005c 	.word	0x2000005c
    1b4c:	40000800 	.word	0x40000800
    1b50:	007a1200 	.word	0x007a1200
    1b54:	00002121 	.word	0x00002121
    1b58:	02dc6c00 	.word	0x02dc6c00

00001b5c <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    1b5c:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    1b5e:	4b0c      	ldr	r3, [pc, #48]	; (1b90 <system_clock_source_osc8m_set_config+0x34>)
    1b60:	6a1c      	ldr	r4, [r3, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    1b62:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    1b64:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    1b66:	7840      	ldrb	r0, [r0, #1]
    1b68:	2201      	movs	r2, #1
    1b6a:	4010      	ands	r0, r2
    1b6c:	0180      	lsls	r0, r0, #6
    1b6e:	2640      	movs	r6, #64	; 0x40
    1b70:	43b4      	bics	r4, r6
    1b72:	4304      	orrs	r4, r0
    1b74:	402a      	ands	r2, r5
    1b76:	01d0      	lsls	r0, r2, #7
    1b78:	2280      	movs	r2, #128	; 0x80
    1b7a:	4394      	bics	r4, r2
    1b7c:	1c22      	adds	r2, r4, #0
    1b7e:	4302      	orrs	r2, r0
    1b80:	2003      	movs	r0, #3
    1b82:	4001      	ands	r1, r0
    1b84:	0209      	lsls	r1, r1, #8
    1b86:	4803      	ldr	r0, [pc, #12]	; (1b94 <system_clock_source_osc8m_set_config+0x38>)
    1b88:	4002      	ands	r2, r0
    1b8a:	430a      	orrs	r2, r1
    1b8c:	621a      	str	r2, [r3, #32]
}
    1b8e:	bd70      	pop	{r4, r5, r6, pc}
    1b90:	40000800 	.word	0x40000800
    1b94:	fffffcff 	.word	0xfffffcff

00001b98 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    1b98:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b9a:	465f      	mov	r7, fp
    1b9c:	4656      	mov	r6, sl
    1b9e:	464d      	mov	r5, r9
    1ba0:	4644      	mov	r4, r8
    1ba2:	b4f0      	push	{r4, r5, r6, r7}
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    1ba4:	4a25      	ldr	r2, [pc, #148]	; (1c3c <system_clock_source_xosc32k_set_config+0xa4>)
    1ba6:	8a94      	ldrh	r4, [r2, #20]

	temp.bit.STARTUP = config->startup_time;
    1ba8:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    1baa:	7803      	ldrb	r3, [r0, #0]
    1bac:	4259      	negs	r1, r3
    1bae:	4159      	adcs	r1, r3
    1bb0:	468a      	mov	sl, r1
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    1bb2:	7883      	ldrb	r3, [r0, #2]
    1bb4:	469c      	mov	ip, r3
	temp.bit.EN1K = config->enable_1khz_output;
    1bb6:	78c1      	ldrb	r1, [r0, #3]
    1bb8:	4688      	mov	r8, r1
	temp.bit.EN32K = config->enable_32khz_output;
    1bba:	7903      	ldrb	r3, [r0, #4]
    1bbc:	4699      	mov	r9, r3

	temp.bit.ONDEMAND = config->on_demand;
    1bbe:	7b46      	ldrb	r6, [r0, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
    1bc0:	7b07      	ldrb	r7, [r0, #12]
	temp.bit.WRTLOCK  = config->write_once;
    1bc2:	7b81      	ldrb	r1, [r0, #14]
    1bc4:	468b      	mov	fp, r1

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    1bc6:	6880      	ldr	r0, [r0, #8]
    1bc8:	4b1d      	ldr	r3, [pc, #116]	; (1c40 <system_clock_source_xosc32k_set_config+0xa8>)
    1bca:	6158      	str	r0, [r3, #20]

	SYSCTRL->XOSC32K = temp;
    1bcc:	2301      	movs	r3, #1
    1bce:	4651      	mov	r1, sl
    1bd0:	0088      	lsls	r0, r1, #2
    1bd2:	2104      	movs	r1, #4
    1bd4:	438c      	bics	r4, r1
    1bd6:	4304      	orrs	r4, r0
    1bd8:	4648      	mov	r0, r9
    1bda:	4018      	ands	r0, r3
    1bdc:	00c0      	lsls	r0, r0, #3
    1bde:	2108      	movs	r1, #8
    1be0:	438c      	bics	r4, r1
    1be2:	4304      	orrs	r4, r0
    1be4:	4640      	mov	r0, r8
    1be6:	4018      	ands	r0, r3
    1be8:	0100      	lsls	r0, r0, #4
    1bea:	2110      	movs	r1, #16
    1bec:	438c      	bics	r4, r1
    1bee:	4304      	orrs	r4, r0
    1bf0:	4660      	mov	r0, ip
    1bf2:	4018      	ands	r0, r3
    1bf4:	0140      	lsls	r0, r0, #5
    1bf6:	2120      	movs	r1, #32
    1bf8:	438c      	bics	r4, r1
    1bfa:	4304      	orrs	r4, r0
    1bfc:	1c18      	adds	r0, r3, #0
    1bfe:	4038      	ands	r0, r7
    1c00:	0180      	lsls	r0, r0, #6
    1c02:	2740      	movs	r7, #64	; 0x40
    1c04:	43bc      	bics	r4, r7
    1c06:	4304      	orrs	r4, r0
    1c08:	1c18      	adds	r0, r3, #0
    1c0a:	4030      	ands	r0, r6
    1c0c:	01c0      	lsls	r0, r0, #7
    1c0e:	2680      	movs	r6, #128	; 0x80
    1c10:	43b4      	bics	r4, r6
    1c12:	4304      	orrs	r4, r0
    1c14:	2007      	movs	r0, #7
    1c16:	4028      	ands	r0, r5
    1c18:	0200      	lsls	r0, r0, #8
    1c1a:	4d0a      	ldr	r5, [pc, #40]	; (1c44 <system_clock_source_xosc32k_set_config+0xac>)
    1c1c:	402c      	ands	r4, r5
    1c1e:	4304      	orrs	r4, r0
    1c20:	4659      	mov	r1, fp
    1c22:	400b      	ands	r3, r1
    1c24:	0319      	lsls	r1, r3, #12
    1c26:	4808      	ldr	r0, [pc, #32]	; (1c48 <system_clock_source_xosc32k_set_config+0xb0>)
    1c28:	1c23      	adds	r3, r4, #0
    1c2a:	4003      	ands	r3, r0
    1c2c:	430b      	orrs	r3, r1
    1c2e:	8293      	strh	r3, [r2, #20]
}
    1c30:	bc3c      	pop	{r2, r3, r4, r5}
    1c32:	4690      	mov	r8, r2
    1c34:	4699      	mov	r9, r3
    1c36:	46a2      	mov	sl, r4
    1c38:	46ab      	mov	fp, r5
    1c3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1c3c:	40000800 	.word	0x40000800
    1c40:	2000005c 	.word	0x2000005c
    1c44:	fffff8ff 	.word	0xfffff8ff
    1c48:	ffffefff 	.word	0xffffefff

00001c4c <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    1c4c:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    1c4e:	7a02      	ldrb	r2, [r0, #8]
    1c50:	0692      	lsls	r2, r2, #26
    1c52:	0c12      	lsrs	r2, r2, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
    1c54:	8943      	ldrh	r3, [r0, #10]
    1c56:	059b      	lsls	r3, r3, #22
    1c58:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    1c5a:	431a      	orrs	r2, r3
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
    1c5c:	4b15      	ldr	r3, [pc, #84]	; (1cb4 <system_clock_source_dfll_set_config+0x68>)
    1c5e:	605a      	str	r2, [r3, #4]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
    1c60:	8881      	ldrh	r1, [r0, #4]
    1c62:	8842      	ldrh	r2, [r0, #2]
    1c64:	4311      	orrs	r1, r2
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    1c66:	79c4      	ldrb	r4, [r0, #7]
    1c68:	7982      	ldrb	r2, [r0, #6]
    1c6a:	4322      	orrs	r2, r4
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    1c6c:	430a      	orrs	r2, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    1c6e:	7841      	ldrb	r1, [r0, #1]
    1c70:	01c9      	lsls	r1, r1, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
    1c72:	430a      	orrs	r2, r1
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
    1c74:	601a      	str	r2, [r3, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    1c76:	7803      	ldrb	r3, [r0, #0]
    1c78:	2b04      	cmp	r3, #4
    1c7a:	d10f      	bne.n	1c9c <system_clock_source_dfll_set_config+0x50>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    1c7c:	7b02      	ldrb	r2, [r0, #12]
    1c7e:	0692      	lsls	r2, r2, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    1c80:	8a03      	ldrh	r3, [r0, #16]
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    1c82:	431a      	orrs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    1c84:	89c3      	ldrh	r3, [r0, #14]
    1c86:	041b      	lsls	r3, r3, #16
    1c88:	490b      	ldr	r1, [pc, #44]	; (1cb8 <system_clock_source_dfll_set_config+0x6c>)
    1c8a:	400b      	ands	r3, r1
    1c8c:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
    1c8e:	4b09      	ldr	r3, [pc, #36]	; (1cb4 <system_clock_source_dfll_set_config+0x68>)
    1c90:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    1c92:	6819      	ldr	r1, [r3, #0]
    1c94:	2204      	movs	r2, #4
    1c96:	430a      	orrs	r2, r1
    1c98:	601a      	str	r2, [r3, #0]
    1c9a:	e009      	b.n	1cb0 <system_clock_source_dfll_set_config+0x64>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    1c9c:	2b20      	cmp	r3, #32
    1c9e:	d107      	bne.n	1cb0 <system_clock_source_dfll_set_config+0x64>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    1ca0:	8a02      	ldrh	r2, [r0, #16]
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
    1ca2:	4b04      	ldr	r3, [pc, #16]	; (1cb4 <system_clock_source_dfll_set_config+0x68>)
    1ca4:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    1ca6:	6819      	ldr	r1, [r3, #0]
    1ca8:	2284      	movs	r2, #132	; 0x84
    1caa:	00d2      	lsls	r2, r2, #3
    1cac:	430a      	orrs	r2, r1
    1cae:	601a      	str	r2, [r3, #0]
				SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
    1cb0:	bd10      	pop	{r4, pc}
    1cb2:	46c0      	nop			; (mov r8, r8)
    1cb4:	2000005c 	.word	0x2000005c
    1cb8:	03ff0000 	.word	0x03ff0000

00001cbc <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    1cbc:	2808      	cmp	r0, #8
    1cbe:	d843      	bhi.n	1d48 <system_clock_source_enable+0x8c>
    1cc0:	0080      	lsls	r0, r0, #2
    1cc2:	4b22      	ldr	r3, [pc, #136]	; (1d4c <system_clock_source_enable+0x90>)
    1cc4:	581b      	ldr	r3, [r3, r0]
    1cc6:	469f      	mov	pc, r3
		break;
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    1cc8:	2000      	movs	r0, #0
    1cca:	e03e      	b.n	1d4a <system_clock_source_enable+0x8e>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    1ccc:	4b20      	ldr	r3, [pc, #128]	; (1d50 <system_clock_source_enable+0x94>)
    1cce:	6a19      	ldr	r1, [r3, #32]
    1cd0:	2202      	movs	r2, #2
    1cd2:	430a      	orrs	r2, r1
    1cd4:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
    1cd6:	2000      	movs	r0, #0
    1cd8:	e037      	b.n	1d4a <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    1cda:	4b1d      	ldr	r3, [pc, #116]	; (1d50 <system_clock_source_enable+0x94>)
    1cdc:	6999      	ldr	r1, [r3, #24]
    1cde:	2202      	movs	r2, #2
    1ce0:	430a      	orrs	r2, r1
    1ce2:	619a      	str	r2, [r3, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1ce4:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
    1ce6:	e030      	b.n	1d4a <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    1ce8:	4b19      	ldr	r3, [pc, #100]	; (1d50 <system_clock_source_enable+0x94>)
    1cea:	8a19      	ldrh	r1, [r3, #16]
    1cec:	2202      	movs	r2, #2
    1cee:	430a      	orrs	r2, r1
    1cf0:	821a      	strh	r2, [r3, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1cf2:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
    1cf4:	e029      	b.n	1d4a <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    1cf6:	4b16      	ldr	r3, [pc, #88]	; (1d50 <system_clock_source_enable+0x94>)
    1cf8:	8a99      	ldrh	r1, [r3, #20]
    1cfa:	2202      	movs	r2, #2
    1cfc:	430a      	orrs	r2, r1
    1cfe:	829a      	strh	r2, [r3, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1d00:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
    1d02:	e022      	b.n	1d4a <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    1d04:	4b13      	ldr	r3, [pc, #76]	; (1d54 <system_clock_source_enable+0x98>)
    1d06:	6819      	ldr	r1, [r3, #0]
    1d08:	2202      	movs	r2, #2
    1d0a:	430a      	orrs	r2, r1
    1d0c:	601a      	str	r2, [r3, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
    1d0e:	681a      	ldr	r2, [r3, #0]
    1d10:	4b11      	ldr	r3, [pc, #68]	; (1d58 <system_clock_source_enable+0x9c>)
    1d12:	401a      	ands	r2, r3
    1d14:	4b0e      	ldr	r3, [pc, #56]	; (1d50 <system_clock_source_enable+0x94>)
    1d16:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    1d18:	1c19      	adds	r1, r3, #0
    1d1a:	2210      	movs	r2, #16
    1d1c:	68cb      	ldr	r3, [r1, #12]
    1d1e:	421a      	tst	r2, r3
    1d20:	d0fc      	beq.n	1d1c <system_clock_source_enable+0x60>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    1d22:	4a0c      	ldr	r2, [pc, #48]	; (1d54 <system_clock_source_enable+0x98>)
    1d24:	6891      	ldr	r1, [r2, #8]
    1d26:	4b0a      	ldr	r3, [pc, #40]	; (1d50 <system_clock_source_enable+0x94>)
    1d28:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    1d2a:	6851      	ldr	r1, [r2, #4]
    1d2c:	6299      	str	r1, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    1d2e:	6812      	ldr	r2, [r2, #0]
    1d30:	b292      	uxth	r2, r2
    1d32:	849a      	strh	r2, [r3, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1d34:	2000      	movs	r0, #0
    1d36:	e008      	b.n	1d4a <system_clock_source_enable+0x8e>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    1d38:	4a05      	ldr	r2, [pc, #20]	; (1d50 <system_clock_source_enable+0x94>)
    1d3a:	2344      	movs	r3, #68	; 0x44
    1d3c:	5cd0      	ldrb	r0, [r2, r3]
    1d3e:	2102      	movs	r1, #2
    1d40:	4301      	orrs	r1, r0
    1d42:	54d1      	strb	r1, [r2, r3]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1d44:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
    1d46:	e000      	b.n	1d4a <system_clock_source_enable+0x8e>
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    1d48:	2017      	movs	r0, #23
	}

	return STATUS_OK;
}
    1d4a:	4770      	bx	lr
    1d4c:	0000282c 	.word	0x0000282c
    1d50:	40000800 	.word	0x40000800
    1d54:	2000005c 	.word	0x2000005c
    1d58:	0000ff7f 	.word	0x0000ff7f

00001d5c <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    1d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d5e:	b08f      	sub	sp, #60	; 0x3c
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    1d60:	22c2      	movs	r2, #194	; 0xc2
    1d62:	00d2      	lsls	r2, r2, #3
    1d64:	4b4b      	ldr	r3, [pc, #300]	; (1e94 <system_clock_init+0x138>)
    1d66:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    1d68:	4b4b      	ldr	r3, [pc, #300]	; (1e98 <system_clock_init+0x13c>)
    1d6a:	685a      	ldr	r2, [r3, #4]
    1d6c:	211e      	movs	r1, #30
    1d6e:	438a      	bics	r2, r1
    1d70:	2104      	movs	r1, #4
    1d72:	430a      	orrs	r2, r1
    1d74:	605a      	str	r2, [r3, #4]
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
    1d76:	2202      	movs	r2, #2
    1d78:	ab01      	add	r3, sp, #4
    1d7a:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    1d7c:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    1d7e:	4d47      	ldr	r5, [pc, #284]	; (1e9c <system_clock_init+0x140>)
    1d80:	b2e0      	uxtb	r0, r4
    1d82:	a901      	add	r1, sp, #4
    1d84:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    1d86:	3401      	adds	r4, #1
    1d88:	2c25      	cmp	r4, #37	; 0x25
    1d8a:	d1f9      	bne.n	1d80 <system_clock_init+0x24>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    1d8c:	a80a      	add	r0, sp, #40	; 0x28
    1d8e:	2300      	movs	r3, #0
    1d90:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
    1d92:	2204      	movs	r2, #4
    1d94:	7042      	strb	r2, [r0, #1]
	config->auto_gain_control   = false;
    1d96:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
    1d98:	2280      	movs	r2, #128	; 0x80
    1d9a:	0212      	lsls	r2, r2, #8
    1d9c:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
    1d9e:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
    1da0:	2201      	movs	r2, #1
    1da2:	7102      	strb	r2, [r0, #4]
	config->run_in_standby      = false;
    1da4:	7303      	strb	r3, [r0, #12]
	config->on_demand           = true;
	config->write_once          = false;
    1da6:	7383      	strb	r3, [r0, #14]
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    1da8:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
    1daa:	466a      	mov	r2, sp
    1dac:	84d3      	strh	r3, [r2, #38]	; 0x26
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    1dae:	4b3c      	ldr	r3, [pc, #240]	; (1ea0 <system_clock_init+0x144>)
    1db0:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    1db2:	2005      	movs	r0, #5
    1db4:	4b3b      	ldr	r3, [pc, #236]	; (1ea4 <system_clock_init+0x148>)
    1db6:	4798      	blx	r3

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    1db8:	4836      	ldr	r0, [pc, #216]	; (1e94 <system_clock_init+0x138>)
    1dba:	2102      	movs	r1, #2
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
		XOSC32RDYCount++;
    1dbc:	466b      	mov	r3, sp
    1dbe:	3326      	adds	r3, #38	; 0x26
		if(XOSC32RDYCount>60000){
    1dc0:	4c39      	ldr	r4, [pc, #228]	; (1ea8 <system_clock_init+0x14c>)
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
    1dc2:	e00b      	b.n	1ddc <system_clock_init+0x80>
		XOSC32RDYCount++;
    1dc4:	881a      	ldrh	r2, [r3, #0]
    1dc6:	3201      	adds	r2, #1
    1dc8:	b292      	uxth	r2, r2
    1dca:	801a      	strh	r2, [r3, #0]
		if(XOSC32RDYCount>60000){
    1dcc:	881a      	ldrh	r2, [r3, #0]
    1dce:	b292      	uxth	r2, r2
    1dd0:	42a2      	cmp	r2, r4
    1dd2:	d903      	bls.n	1ddc <system_clock_init+0x80>
			XOSC32Fail=1;
    1dd4:	2201      	movs	r2, #1
    1dd6:	4b35      	ldr	r3, [pc, #212]	; (1eac <system_clock_init+0x150>)
    1dd8:	701a      	strb	r2, [r3, #0]
			break;
    1dda:	e002      	b.n	1de2 <system_clock_init+0x86>

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    1ddc:	68c2      	ldr	r2, [r0, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
    1dde:	4211      	tst	r1, r2
    1de0:	d0f0      	beq.n	1dc4 <system_clock_init+0x68>
			XOSC32Fail=1;
			break;
		}
		}			//sajid here it waits for XOSC32
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
    1de2:	4b2c      	ldr	r3, [pc, #176]	; (1e94 <system_clock_init+0x138>)
    1de4:	8a99      	ldrh	r1, [r3, #20]
    1de6:	2280      	movs	r2, #128	; 0x80
    1de8:	430a      	orrs	r2, r1
    1dea:	829a      	strh	r2, [r3, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    1dec:	a805      	add	r0, sp, #20
    1dee:	2300      	movs	r3, #0
    1df0:	2500      	movs	r5, #0
    1df2:	8043      	strh	r3, [r0, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    1df4:	8083      	strh	r3, [r0, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    1df6:	7185      	strb	r5, [r0, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    1df8:	71c5      	strb	r5, [r0, #7]
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
    1dfa:	2207      	movs	r2, #7
    1dfc:	7202      	strb	r2, [r0, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
    1dfe:	233f      	movs	r3, #63	; 0x3f
    1e00:	8143      	strh	r3, [r0, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    1e02:	2104      	movs	r1, #4
    1e04:	7001      	strb	r1, [r0, #0]
	dfll_conf.on_demand      = false;
    1e06:	7045      	strb	r5, [r0, #1]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    1e08:	4929      	ldr	r1, [pc, #164]	; (1eb0 <system_clock_init+0x154>)
    1e0a:	8201      	strh	r1, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    1e0c:	7302      	strb	r2, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    1e0e:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    1e10:	4b28      	ldr	r3, [pc, #160]	; (1eb4 <system_clock_init+0x158>)
    1e12:	4798      	blx	r3
		struct system_clock_source_osc8m_config *const config)
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
    1e14:	a804      	add	r0, sp, #16
    1e16:	7045      	strb	r5, [r0, #1]
	config->on_demand       = true;
    1e18:	2601      	movs	r6, #1
    1e1a:	7086      	strb	r6, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    1e1c:	7005      	strb	r5, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
    1e1e:	4b26      	ldr	r3, [pc, #152]	; (1eb8 <system_clock_init+0x15c>)
    1e20:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    1e22:	2006      	movs	r0, #6
    1e24:	4f1f      	ldr	r7, [pc, #124]	; (1ea4 <system_clock_init+0x148>)
    1e26:	47b8      	blx	r7


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    1e28:	4b24      	ldr	r3, [pc, #144]	; (1ebc <system_clock_init+0x160>)
    1e2a:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    1e2c:	ac01      	add	r4, sp, #4
    1e2e:	9602      	str	r6, [sp, #8]
	config->high_when_disabled = false;
    1e30:	7065      	strb	r5, [r4, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    1e32:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
    1e34:	7265      	strb	r5, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(8, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    1e36:	2305      	movs	r3, #5
    1e38:	7023      	strb	r3, [r4, #0]
    1e3a:	2001      	movs	r0, #1
    1e3c:	1c21      	adds	r1, r4, #0
    1e3e:	4b20      	ldr	r3, [pc, #128]	; (1ec0 <system_clock_init+0x164>)
    1e40:	4798      	blx	r3
    1e42:	2001      	movs	r0, #1
    1e44:	4b1f      	ldr	r3, [pc, #124]	; (1ec4 <system_clock_init+0x168>)
    1e46:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    1e48:	7026      	strb	r6, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    1e4a:	2000      	movs	r0, #0
    1e4c:	1c21      	adds	r1, r4, #0
    1e4e:	4b13      	ldr	r3, [pc, #76]	; (1e9c <system_clock_init+0x140>)
    1e50:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    1e52:	2000      	movs	r0, #0
    1e54:	4b1c      	ldr	r3, [pc, #112]	; (1ec8 <system_clock_init+0x16c>)
    1e56:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    1e58:	2007      	movs	r0, #7
    1e5a:	47b8      	blx	r7

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    1e5c:	490d      	ldr	r1, [pc, #52]	; (1e94 <system_clock_init+0x138>)
    1e5e:	22d0      	movs	r2, #208	; 0xd0
    1e60:	68cb      	ldr	r3, [r1, #12]
    1e62:	4013      	ands	r3, r2


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    1e64:	2bd0      	cmp	r3, #208	; 0xd0
    1e66:	d1fb      	bne.n	1e60 <system_clock_init+0x104>
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    1e68:	4a18      	ldr	r2, [pc, #96]	; (1ecc <system_clock_init+0x170>)
    1e6a:	2300      	movs	r3, #0
    1e6c:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    1e6e:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    1e70:	7293      	strb	r3, [r2, #10]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    1e72:	a901      	add	r1, sp, #4
    1e74:	2201      	movs	r2, #1
    1e76:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
    1e78:	704b      	strb	r3, [r1, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    1e7a:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    1e7c:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    1e7e:	2307      	movs	r3, #7
    1e80:	700b      	strb	r3, [r1, #0]
    1e82:	2000      	movs	r0, #0
    1e84:	4b0e      	ldr	r3, [pc, #56]	; (1ec0 <system_clock_init+0x164>)
    1e86:	4798      	blx	r3
    1e88:	2000      	movs	r0, #0
    1e8a:	4b0e      	ldr	r3, [pc, #56]	; (1ec4 <system_clock_init+0x168>)
    1e8c:	4798      	blx	r3
#endif
}
    1e8e:	b00f      	add	sp, #60	; 0x3c
    1e90:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1e92:	46c0      	nop			; (mov r8, r8)
    1e94:	40000800 	.word	0x40000800
    1e98:	41004000 	.word	0x41004000
    1e9c:	00002105 	.word	0x00002105
    1ea0:	00001b99 	.word	0x00001b99
    1ea4:	00001cbd 	.word	0x00001cbd
    1ea8:	0000ea60 	.word	0x0000ea60
    1eac:	20000074 	.word	0x20000074
    1eb0:	000005b9 	.word	0x000005b9
    1eb4:	00001c4d 	.word	0x00001c4d
    1eb8:	00001b5d 	.word	0x00001b5d
    1ebc:	00001ed1 	.word	0x00001ed1
    1ec0:	00001ef5 	.word	0x00001ef5
    1ec4:	00001fa9 	.word	0x00001fa9
    1ec8:	00002079 	.word	0x00002079
    1ecc:	40000400 	.word	0x40000400

00001ed0 <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    1ed0:	4b06      	ldr	r3, [pc, #24]	; (1eec <system_gclk_init+0x1c>)
    1ed2:	6999      	ldr	r1, [r3, #24]
    1ed4:	2208      	movs	r2, #8
    1ed6:	430a      	orrs	r2, r1
    1ed8:	619a      	str	r2, [r3, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    1eda:	2201      	movs	r2, #1
    1edc:	4b04      	ldr	r3, [pc, #16]	; (1ef0 <system_gclk_init+0x20>)
    1ede:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    1ee0:	1c19      	adds	r1, r3, #0
    1ee2:	780b      	ldrb	r3, [r1, #0]
    1ee4:	4213      	tst	r3, r2
    1ee6:	d1fc      	bne.n	1ee2 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    1ee8:	4770      	bx	lr
    1eea:	46c0      	nop			; (mov r8, r8)
    1eec:	40000400 	.word	0x40000400
    1ef0:	40000c00 	.word	0x40000c00

00001ef4 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    1ef4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1ef6:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    1ef8:	1c07      	adds	r7, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    1efa:	780d      	ldrb	r5, [r1, #0]
    1efc:	022d      	lsls	r5, r5, #8
    1efe:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    1f00:	784b      	ldrb	r3, [r1, #1]
    1f02:	2b00      	cmp	r3, #0
    1f04:	d002      	beq.n	1f0c <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    1f06:	2380      	movs	r3, #128	; 0x80
    1f08:	02db      	lsls	r3, r3, #11
    1f0a:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    1f0c:	7a4b      	ldrb	r3, [r1, #9]
    1f0e:	2b00      	cmp	r3, #0
    1f10:	d002      	beq.n	1f18 <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    1f12:	2380      	movs	r3, #128	; 0x80
    1f14:	031b      	lsls	r3, r3, #12
    1f16:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    1f18:	684c      	ldr	r4, [r1, #4]
    1f1a:	2c01      	cmp	r4, #1
    1f1c:	d917      	bls.n	1f4e <system_gclk_gen_set_config+0x5a>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    1f1e:	1e63      	subs	r3, r4, #1
    1f20:	421c      	tst	r4, r3
    1f22:	d10f      	bne.n	1f44 <system_gclk_gen_set_config+0x50>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    1f24:	2c02      	cmp	r4, #2
    1f26:	d906      	bls.n	1f36 <system_gclk_gen_set_config+0x42>
    1f28:	2302      	movs	r3, #2
    1f2a:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    1f2c:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    1f2e:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    1f30:	429c      	cmp	r4, r3
    1f32:	d8fb      	bhi.n	1f2c <system_gclk_gen_set_config+0x38>
    1f34:	e000      	b.n	1f38 <system_gclk_gen_set_config+0x44>
    1f36:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    1f38:	0217      	lsls	r7, r2, #8
    1f3a:	4337      	orrs	r7, r6
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    1f3c:	2380      	movs	r3, #128	; 0x80
    1f3e:	035b      	lsls	r3, r3, #13
    1f40:	431d      	orrs	r5, r3
    1f42:	e004      	b.n	1f4e <system_gclk_gen_set_config+0x5a>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    1f44:	0227      	lsls	r7, r4, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    1f46:	4337      	orrs	r7, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    1f48:	2380      	movs	r3, #128	; 0x80
    1f4a:	029b      	lsls	r3, r3, #10
    1f4c:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    1f4e:	7a0b      	ldrb	r3, [r1, #8]
    1f50:	2b00      	cmp	r3, #0
    1f52:	d002      	beq.n	1f5a <system_gclk_gen_set_config+0x66>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    1f54:	2380      	movs	r3, #128	; 0x80
    1f56:	039b      	lsls	r3, r3, #14
    1f58:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1f5a:	4a0f      	ldr	r2, [pc, #60]	; (1f98 <system_gclk_gen_set_config+0xa4>)
    1f5c:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
    1f5e:	b25b      	sxtb	r3, r3
    1f60:	2b00      	cmp	r3, #0
    1f62:	dbfb      	blt.n	1f5c <system_gclk_gen_set_config+0x68>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1f64:	4b0d      	ldr	r3, [pc, #52]	; (1f9c <system_gclk_gen_set_config+0xa8>)
    1f66:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1f68:	4b0d      	ldr	r3, [pc, #52]	; (1fa0 <system_gclk_gen_set_config+0xac>)
    1f6a:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1f6c:	4a0a      	ldr	r2, [pc, #40]	; (1f98 <system_gclk_gen_set_config+0xa4>)
    1f6e:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    1f70:	b25b      	sxtb	r3, r3
    1f72:	2b00      	cmp	r3, #0
    1f74:	dbfb      	blt.n	1f6e <system_gclk_gen_set_config+0x7a>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    1f76:	4b08      	ldr	r3, [pc, #32]	; (1f98 <system_gclk_gen_set_config+0xa4>)
    1f78:	609f      	str	r7, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1f7a:	1c1a      	adds	r2, r3, #0
    1f7c:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
    1f7e:	b25b      	sxtb	r3, r3
    1f80:	2b00      	cmp	r3, #0
    1f82:	dbfb      	blt.n	1f7c <system_gclk_gen_set_config+0x88>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    1f84:	4b04      	ldr	r3, [pc, #16]	; (1f98 <system_gclk_gen_set_config+0xa4>)
    1f86:	6859      	ldr	r1, [r3, #4]
    1f88:	2280      	movs	r2, #128	; 0x80
    1f8a:	0252      	lsls	r2, r2, #9
    1f8c:	400a      	ands	r2, r1
    1f8e:	4315      	orrs	r5, r2
    1f90:	605d      	str	r5, [r3, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1f92:	4b04      	ldr	r3, [pc, #16]	; (1fa4 <system_gclk_gen_set_config+0xb0>)
    1f94:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1f96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1f98:	40000c00 	.word	0x40000c00
    1f9c:	00001a01 	.word	0x00001a01
    1fa0:	40000c08 	.word	0x40000c08
    1fa4:	00001a41 	.word	0x00001a41

00001fa8 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    1fa8:	b510      	push	{r4, lr}
    1faa:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1fac:	4a0b      	ldr	r2, [pc, #44]	; (1fdc <system_gclk_gen_enable+0x34>)
    1fae:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    1fb0:	b25b      	sxtb	r3, r3
    1fb2:	2b00      	cmp	r3, #0
    1fb4:	dbfb      	blt.n	1fae <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1fb6:	4b0a      	ldr	r3, [pc, #40]	; (1fe0 <system_gclk_gen_enable+0x38>)
    1fb8:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1fba:	4b0a      	ldr	r3, [pc, #40]	; (1fe4 <system_gclk_gen_enable+0x3c>)
    1fbc:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1fbe:	4a07      	ldr	r2, [pc, #28]	; (1fdc <system_gclk_gen_enable+0x34>)
    1fc0:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    1fc2:	b25b      	sxtb	r3, r3
    1fc4:	2b00      	cmp	r3, #0
    1fc6:	dbfb      	blt.n	1fc0 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    1fc8:	4b04      	ldr	r3, [pc, #16]	; (1fdc <system_gclk_gen_enable+0x34>)
    1fca:	6859      	ldr	r1, [r3, #4]
    1fcc:	2280      	movs	r2, #128	; 0x80
    1fce:	0252      	lsls	r2, r2, #9
    1fd0:	430a      	orrs	r2, r1
    1fd2:	605a      	str	r2, [r3, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1fd4:	4b04      	ldr	r3, [pc, #16]	; (1fe8 <system_gclk_gen_enable+0x40>)
    1fd6:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1fd8:	bd10      	pop	{r4, pc}
    1fda:	46c0      	nop			; (mov r8, r8)
    1fdc:	40000c00 	.word	0x40000c00
    1fe0:	00001a01 	.word	0x00001a01
    1fe4:	40000c04 	.word	0x40000c04
    1fe8:	00001a41 	.word	0x00001a41

00001fec <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    1fec:	b570      	push	{r4, r5, r6, lr}
    1fee:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1ff0:	4a1a      	ldr	r2, [pc, #104]	; (205c <STACK_SIZE+0x5c>)
    1ff2:	7853      	ldrb	r3, [r2, #1]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    1ff4:	b25b      	sxtb	r3, r3
    1ff6:	2b00      	cmp	r3, #0
    1ff8:	dbfb      	blt.n	1ff2 <system_gclk_gen_get_hz+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1ffa:	4b19      	ldr	r3, [pc, #100]	; (2060 <STACK_SIZE+0x60>)
    1ffc:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1ffe:	4b19      	ldr	r3, [pc, #100]	; (2064 <STACK_SIZE+0x64>)
    2000:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    2002:	4a16      	ldr	r2, [pc, #88]	; (205c <STACK_SIZE+0x5c>)
    2004:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    2006:	b25b      	sxtb	r3, r3
    2008:	2b00      	cmp	r3, #0
    200a:	dbfb      	blt.n	2004 <STACK_SIZE+0x4>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    200c:	4e13      	ldr	r6, [pc, #76]	; (205c <STACK_SIZE+0x5c>)
    200e:	6870      	ldr	r0, [r6, #4]
    2010:	04c0      	lsls	r0, r0, #19
    2012:	0ec0      	lsrs	r0, r0, #27
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    2014:	4b14      	ldr	r3, [pc, #80]	; (2068 <STACK_SIZE+0x68>)
    2016:	4798      	blx	r3
    2018:	1c05      	adds	r5, r0, #0
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    201a:	4b12      	ldr	r3, [pc, #72]	; (2064 <STACK_SIZE+0x64>)
    201c:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    201e:	6876      	ldr	r6, [r6, #4]
    2020:	02f6      	lsls	r6, r6, #11
    2022:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    2024:	4b11      	ldr	r3, [pc, #68]	; (206c <STACK_SIZE+0x6c>)
    2026:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    2028:	4a0c      	ldr	r2, [pc, #48]	; (205c <STACK_SIZE+0x5c>)
    202a:	7853      	ldrb	r3, [r2, #1]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
	while (system_gclk_is_syncing()) {
    202c:	b25b      	sxtb	r3, r3
    202e:	2b00      	cmp	r3, #0
    2030:	dbfb      	blt.n	202a <STACK_SIZE+0x2a>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    2032:	4b0a      	ldr	r3, [pc, #40]	; (205c <STACK_SIZE+0x5c>)
    2034:	689c      	ldr	r4, [r3, #8]
    2036:	0a24      	lsrs	r4, r4, #8
    2038:	b2a4      	uxth	r4, r4
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    203a:	4b0d      	ldr	r3, [pc, #52]	; (2070 <STACK_SIZE+0x70>)
    203c:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    203e:	2e00      	cmp	r6, #0
    2040:	d107      	bne.n	2052 <STACK_SIZE+0x52>
    2042:	2c01      	cmp	r4, #1
    2044:	d907      	bls.n	2056 <STACK_SIZE+0x56>
		gen_input_hz /= divider;
    2046:	1c28      	adds	r0, r5, #0
    2048:	1c21      	adds	r1, r4, #0
    204a:	4b0a      	ldr	r3, [pc, #40]	; (2074 <STACK_SIZE+0x74>)
    204c:	4798      	blx	r3
    204e:	1c05      	adds	r5, r0, #0
    2050:	e001      	b.n	2056 <STACK_SIZE+0x56>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    2052:	3401      	adds	r4, #1
    2054:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
    2056:	1c28      	adds	r0, r5, #0
    2058:	bd70      	pop	{r4, r5, r6, pc}
    205a:	46c0      	nop			; (mov r8, r8)
    205c:	40000c00 	.word	0x40000c00
    2060:	00001a01 	.word	0x00001a01
    2064:	40000c04 	.word	0x40000c04
    2068:	00001acd 	.word	0x00001acd
    206c:	40000c08 	.word	0x40000c08
    2070:	00001a41 	.word	0x00001a41
    2074:	000024b1 	.word	0x000024b1

00002078 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    2078:	b510      	push	{r4, lr}
    207a:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    207c:	4b06      	ldr	r3, [pc, #24]	; (2098 <system_gclk_chan_enable+0x20>)
    207e:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    2080:	4b06      	ldr	r3, [pc, #24]	; (209c <system_gclk_chan_enable+0x24>)
    2082:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    2084:	4b06      	ldr	r3, [pc, #24]	; (20a0 <system_gclk_chan_enable+0x28>)
    2086:	8859      	ldrh	r1, [r3, #2]
    2088:	2280      	movs	r2, #128	; 0x80
    208a:	01d2      	lsls	r2, r2, #7
    208c:	430a      	orrs	r2, r1
    208e:	805a      	strh	r2, [r3, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    2090:	4b04      	ldr	r3, [pc, #16]	; (20a4 <system_gclk_chan_enable+0x2c>)
    2092:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    2094:	bd10      	pop	{r4, pc}
    2096:	46c0      	nop			; (mov r8, r8)
    2098:	00001a01 	.word	0x00001a01
    209c:	40000c02 	.word	0x40000c02
    20a0:	40000c00 	.word	0x40000c00
    20a4:	00001a41 	.word	0x00001a41

000020a8 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    20a8:	b510      	push	{r4, lr}
    20aa:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    20ac:	4b0f      	ldr	r3, [pc, #60]	; (20ec <system_gclk_chan_disable+0x44>)
    20ae:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    20b0:	4b0f      	ldr	r3, [pc, #60]	; (20f0 <system_gclk_chan_disable+0x48>)
    20b2:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    20b4:	4b0f      	ldr	r3, [pc, #60]	; (20f4 <system_gclk_chan_disable+0x4c>)
    20b6:	8858      	ldrh	r0, [r3, #2]
    20b8:	0500      	lsls	r0, r0, #20
    20ba:	0f00      	lsrs	r0, r0, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    20bc:	8859      	ldrh	r1, [r3, #2]
    20be:	4a0e      	ldr	r2, [pc, #56]	; (20f8 <system_gclk_chan_disable+0x50>)
    20c0:	400a      	ands	r2, r1
    20c2:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    20c4:	8859      	ldrh	r1, [r3, #2]
    20c6:	4a0d      	ldr	r2, [pc, #52]	; (20fc <system_gclk_chan_disable+0x54>)
    20c8:	400a      	ands	r2, r1
    20ca:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    20cc:	1c19      	adds	r1, r3, #0
    20ce:	2280      	movs	r2, #128	; 0x80
    20d0:	01d2      	lsls	r2, r2, #7
    20d2:	884b      	ldrh	r3, [r1, #2]
    20d4:	4213      	tst	r3, r2
    20d6:	d1fc      	bne.n	20d2 <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    20d8:	4b06      	ldr	r3, [pc, #24]	; (20f4 <system_gclk_chan_disable+0x4c>)
    20da:	0201      	lsls	r1, r0, #8
    20dc:	8858      	ldrh	r0, [r3, #2]
    20de:	4a06      	ldr	r2, [pc, #24]	; (20f8 <system_gclk_chan_disable+0x50>)
    20e0:	4002      	ands	r2, r0
    20e2:	430a      	orrs	r2, r1
    20e4:	805a      	strh	r2, [r3, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    20e6:	4b06      	ldr	r3, [pc, #24]	; (2100 <system_gclk_chan_disable+0x58>)
    20e8:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    20ea:	bd10      	pop	{r4, pc}
    20ec:	00001a01 	.word	0x00001a01
    20f0:	40000c02 	.word	0x40000c02
    20f4:	40000c00 	.word	0x40000c00
    20f8:	fffff0ff 	.word	0xfffff0ff
    20fc:	ffffbfff 	.word	0xffffbfff
    2100:	00001a41 	.word	0x00001a41

00002104 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    2104:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    2106:	780c      	ldrb	r4, [r1, #0]
    2108:	0224      	lsls	r4, r4, #8
    210a:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    210c:	4b02      	ldr	r3, [pc, #8]	; (2118 <system_gclk_chan_set_config+0x14>)
    210e:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    2110:	b2a4      	uxth	r4, r4
    2112:	4b02      	ldr	r3, [pc, #8]	; (211c <system_gclk_chan_set_config+0x18>)
    2114:	805c      	strh	r4, [r3, #2]
}
    2116:	bd10      	pop	{r4, pc}
    2118:	000020a9 	.word	0x000020a9
    211c:	40000c00 	.word	0x40000c00

00002120 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    2120:	b510      	push	{r4, lr}
    2122:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    2124:	4b06      	ldr	r3, [pc, #24]	; (2140 <system_gclk_chan_get_hz+0x20>)
    2126:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    2128:	4b06      	ldr	r3, [pc, #24]	; (2144 <system_gclk_chan_get_hz+0x24>)
    212a:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    212c:	4b06      	ldr	r3, [pc, #24]	; (2148 <system_gclk_chan_get_hz+0x28>)
    212e:	885c      	ldrh	r4, [r3, #2]
    2130:	0524      	lsls	r4, r4, #20
    2132:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    2134:	4b05      	ldr	r3, [pc, #20]	; (214c <system_gclk_chan_get_hz+0x2c>)
    2136:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    2138:	1c20      	adds	r0, r4, #0
    213a:	4b05      	ldr	r3, [pc, #20]	; (2150 <system_gclk_chan_get_hz+0x30>)
    213c:	4798      	blx	r3
}
    213e:	bd10      	pop	{r4, pc}
    2140:	00001a01 	.word	0x00001a01
    2144:	40000c02 	.word	0x40000c02
    2148:	40000c00 	.word	0x40000c00
    214c:	00001a41 	.word	0x00001a41
    2150:	00001fed 	.word	0x00001fed

00002154 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    2154:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    2156:	78d3      	ldrb	r3, [r2, #3]
    2158:	2b00      	cmp	r3, #0
    215a:	d11e      	bne.n	219a <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    215c:	7813      	ldrb	r3, [r2, #0]
    215e:	2b80      	cmp	r3, #128	; 0x80
    2160:	d004      	beq.n	216c <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    2162:	061b      	lsls	r3, r3, #24
    2164:	2480      	movs	r4, #128	; 0x80
    2166:	0264      	lsls	r4, r4, #9
    2168:	4323      	orrs	r3, r4
    216a:	e000      	b.n	216e <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    216c:	2300      	movs	r3, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    216e:	7854      	ldrb	r4, [r2, #1]
    2170:	2502      	movs	r5, #2
    2172:	43ac      	bics	r4, r5
    2174:	d10a      	bne.n	218c <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    2176:	7894      	ldrb	r4, [r2, #2]
    2178:	2c00      	cmp	r4, #0
    217a:	d103      	bne.n	2184 <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    217c:	2480      	movs	r4, #128	; 0x80
    217e:	02a4      	lsls	r4, r4, #10
    2180:	4323      	orrs	r3, r4
    2182:	e002      	b.n	218a <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    2184:	24c0      	movs	r4, #192	; 0xc0
    2186:	02e4      	lsls	r4, r4, #11
    2188:	4323      	orrs	r3, r4
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    218a:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    218c:	7854      	ldrb	r4, [r2, #1]
    218e:	3c01      	subs	r4, #1
    2190:	2c01      	cmp	r4, #1
    2192:	d804      	bhi.n	219e <_system_pinmux_config+0x4a>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pullup if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    2194:	4c11      	ldr	r4, [pc, #68]	; (21dc <_system_pinmux_config+0x88>)
    2196:	4023      	ands	r3, r4
    2198:	e001      	b.n	219e <_system_pinmux_config+0x4a>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    219a:	6041      	str	r1, [r0, #4]
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    219c:	2300      	movs	r3, #0
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    219e:	040d      	lsls	r5, r1, #16
    21a0:	0c2d      	lsrs	r5, r5, #16
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    21a2:	24a0      	movs	r4, #160	; 0xa0
    21a4:	05e4      	lsls	r4, r4, #23
    21a6:	432c      	orrs	r4, r5
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    21a8:	431c      	orrs	r4, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    21aa:	6284      	str	r4, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    21ac:	0c0d      	lsrs	r5, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    21ae:	24d0      	movs	r4, #208	; 0xd0
    21b0:	0624      	lsls	r4, r4, #24
    21b2:	432c      	orrs	r4, r5
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    21b4:	431c      	orrs	r4, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    21b6:	6284      	str	r4, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    21b8:	78d4      	ldrb	r4, [r2, #3]
    21ba:	2c00      	cmp	r4, #0
    21bc:	d10c      	bne.n	21d8 <_system_pinmux_config+0x84>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    21be:	035c      	lsls	r4, r3, #13
    21c0:	d505      	bpl.n	21ce <_system_pinmux_config+0x7a>
			/* Set the OUT register bits to enable the pullup if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    21c2:	7893      	ldrb	r3, [r2, #2]
    21c4:	2b01      	cmp	r3, #1
    21c6:	d101      	bne.n	21cc <_system_pinmux_config+0x78>
				port->OUTSET.reg = pin_mask;
    21c8:	6181      	str	r1, [r0, #24]
    21ca:	e000      	b.n	21ce <_system_pinmux_config+0x7a>
			} else {
				port->OUTCLR.reg = pin_mask;
    21cc:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    21ce:	7853      	ldrb	r3, [r2, #1]
    21d0:	3b01      	subs	r3, #1
    21d2:	2b01      	cmp	r3, #1
    21d4:	d800      	bhi.n	21d8 <_system_pinmux_config+0x84>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    21d6:	6081      	str	r1, [r0, #8]
		}
	}
}
    21d8:	bd30      	pop	{r4, r5, pc}
    21da:	46c0      	nop			; (mov r8, r8)
    21dc:	fffbffff 	.word	0xfffbffff

000021e0 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    21e0:	b508      	push	{r3, lr}
    21e2:	1c03      	adds	r3, r0, #0
    21e4:	1c0a      	adds	r2, r1, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    21e6:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    21e8:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    21ea:	2900      	cmp	r1, #0
    21ec:	d103      	bne.n	21f6 <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
    21ee:	0958      	lsrs	r0, r3, #5
    21f0:	01c0      	lsls	r0, r0, #7
    21f2:	4904      	ldr	r1, [pc, #16]	; (2204 <system_pinmux_pin_set_config+0x24>)
    21f4:	1840      	adds	r0, r0, r1
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    21f6:	211f      	movs	r1, #31
    21f8:	400b      	ands	r3, r1
    21fa:	2101      	movs	r1, #1
    21fc:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
    21fe:	4b02      	ldr	r3, [pc, #8]	; (2208 <system_pinmux_pin_set_config+0x28>)
    2200:	4798      	blx	r3
}
    2202:	bd08      	pop	{r3, pc}
    2204:	41004400 	.word	0x41004400
    2208:	00002155 	.word	0x00002155

0000220c <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    220c:	4770      	bx	lr
    220e:	46c0      	nop			; (mov r8, r8)

00002210 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    2210:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    2212:	4b04      	ldr	r3, [pc, #16]	; (2224 <system_init+0x14>)
    2214:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    2216:	4b04      	ldr	r3, [pc, #16]	; (2228 <system_init+0x18>)
    2218:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    221a:	4b04      	ldr	r3, [pc, #16]	; (222c <system_init+0x1c>)
    221c:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    221e:	4b04      	ldr	r3, [pc, #16]	; (2230 <system_init+0x20>)
    2220:	4798      	blx	r3
}
    2222:	bd08      	pop	{r3, pc}
    2224:	00001d5d 	.word	0x00001d5d
    2228:	00001a71 	.word	0x00001a71
    222c:	0000220d 	.word	0x0000220d
    2230:	0000220d 	.word	0x0000220d

00002234 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    2234:	e7fe      	b.n	2234 <Dummy_Handler>
    2236:	46c0      	nop			; (mov r8, r8)

00002238 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    2238:	b570      	push	{r4, r5, r6, lr}
        uint32_t *pSrc, *pDest;

        /* Change default QOS values to have the best performance and correct USB behavior */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    223a:	2102      	movs	r1, #2
    223c:	2390      	movs	r3, #144	; 0x90
    223e:	005b      	lsls	r3, r3, #1
    2240:	4a28      	ldr	r2, [pc, #160]	; (22e4 <Reset_Handler+0xac>)
    2242:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    2244:	4b28      	ldr	r3, [pc, #160]	; (22e8 <Reset_Handler+0xb0>)
    2246:	78d8      	ldrb	r0, [r3, #3]
    2248:	2103      	movs	r1, #3
    224a:	4388      	bics	r0, r1
    224c:	2202      	movs	r2, #2
    224e:	4310      	orrs	r0, r2
    2250:	70d8      	strb	r0, [r3, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    2252:	78dd      	ldrb	r5, [r3, #3]
    2254:	240c      	movs	r4, #12
    2256:	43a5      	bics	r5, r4
    2258:	2008      	movs	r0, #8
    225a:	4305      	orrs	r5, r0
    225c:	70dd      	strb	r5, [r3, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    225e:	4b23      	ldr	r3, [pc, #140]	; (22ec <Reset_Handler+0xb4>)
    2260:	7b9e      	ldrb	r6, [r3, #14]
    2262:	2530      	movs	r5, #48	; 0x30
    2264:	43ae      	bics	r6, r5
    2266:	2520      	movs	r5, #32
    2268:	4335      	orrs	r5, r6
    226a:	739d      	strb	r5, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    226c:	7b9d      	ldrb	r5, [r3, #14]
    226e:	43a5      	bics	r5, r4
    2270:	4328      	orrs	r0, r5
    2272:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    2274:	7b98      	ldrb	r0, [r3, #14]
    2276:	4388      	bics	r0, r1
    2278:	4302      	orrs	r2, r0
    227a:	739a      	strb	r2, [r3, #14]

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    227c:	4b1c      	ldr	r3, [pc, #112]	; (22f0 <Reset_Handler+0xb8>)
    227e:	4a1d      	ldr	r2, [pc, #116]	; (22f4 <Reset_Handler+0xbc>)
    2280:	429a      	cmp	r2, r3
    2282:	d003      	beq.n	228c <Reset_Handler+0x54>
                for (; pDest < &_erelocate;) {
    2284:	4b1c      	ldr	r3, [pc, #112]	; (22f8 <Reset_Handler+0xc0>)
    2286:	4a1a      	ldr	r2, [pc, #104]	; (22f0 <Reset_Handler+0xb8>)
    2288:	429a      	cmp	r2, r3
    228a:	d304      	bcc.n	2296 <Reset_Handler+0x5e>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    228c:	4b1b      	ldr	r3, [pc, #108]	; (22fc <Reset_Handler+0xc4>)
    228e:	4a1c      	ldr	r2, [pc, #112]	; (2300 <Reset_Handler+0xc8>)
    2290:	429a      	cmp	r2, r3
    2292:	d310      	bcc.n	22b6 <Reset_Handler+0x7e>
    2294:	e01b      	b.n	22ce <Reset_Handler+0x96>
    2296:	4b1b      	ldr	r3, [pc, #108]	; (2304 <Reset_Handler+0xcc>)
    2298:	4817      	ldr	r0, [pc, #92]	; (22f8 <Reset_Handler+0xc0>)
    229a:	3003      	adds	r0, #3
    229c:	1ac0      	subs	r0, r0, r3
    229e:	0880      	lsrs	r0, r0, #2
    22a0:	3001      	adds	r0, #1
    22a2:	0080      	lsls	r0, r0, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    22a4:	2300      	movs	r3, #0
                        *pDest++ = *pSrc++;
    22a6:	4912      	ldr	r1, [pc, #72]	; (22f0 <Reset_Handler+0xb8>)
    22a8:	4a12      	ldr	r2, [pc, #72]	; (22f4 <Reset_Handler+0xbc>)
    22aa:	58d4      	ldr	r4, [r2, r3]
    22ac:	50cc      	str	r4, [r1, r3]
    22ae:	3304      	adds	r3, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    22b0:	4283      	cmp	r3, r0
    22b2:	d1fa      	bne.n	22aa <Reset_Handler+0x72>
    22b4:	e7ea      	b.n	228c <Reset_Handler+0x54>
    22b6:	4b12      	ldr	r3, [pc, #72]	; (2300 <Reset_Handler+0xc8>)
    22b8:	1d1a      	adds	r2, r3, #4
    22ba:	4910      	ldr	r1, [pc, #64]	; (22fc <Reset_Handler+0xc4>)
    22bc:	3103      	adds	r1, #3
    22be:	1a89      	subs	r1, r1, r2
    22c0:	0889      	lsrs	r1, r1, #2
    22c2:	0089      	lsls	r1, r1, #2
    22c4:	1852      	adds	r2, r2, r1
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
                *pDest++ = 0;
    22c6:	2100      	movs	r1, #0
    22c8:	c302      	stmia	r3!, {r1}
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    22ca:	4293      	cmp	r3, r2
    22cc:	d1fc      	bne.n	22c8 <Reset_Handler+0x90>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    22ce:	4b0e      	ldr	r3, [pc, #56]	; (2308 <Reset_Handler+0xd0>)
    22d0:	217f      	movs	r1, #127	; 0x7f
    22d2:	4a0e      	ldr	r2, [pc, #56]	; (230c <Reset_Handler+0xd4>)
    22d4:	438a      	bics	r2, r1
    22d6:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
        __libc_init_array();
    22d8:	4b0d      	ldr	r3, [pc, #52]	; (2310 <Reset_Handler+0xd8>)
    22da:	4798      	blx	r3

        /* Branch to main function */
        main();
    22dc:	4b0d      	ldr	r3, [pc, #52]	; (2314 <Reset_Handler+0xdc>)
    22de:	4798      	blx	r3
    22e0:	e7fe      	b.n	22e0 <Reset_Handler+0xa8>
    22e2:	46c0      	nop			; (mov r8, r8)
    22e4:	41007000 	.word	0x41007000
    22e8:	41005000 	.word	0x41005000
    22ec:	41004800 	.word	0x41004800
    22f0:	20000000 	.word	0x20000000
    22f4:	0000295c 	.word	0x0000295c
    22f8:	2000001c 	.word	0x2000001c
    22fc:	2000015c 	.word	0x2000015c
    2300:	2000001c 	.word	0x2000001c
    2304:	20000004 	.word	0x20000004
    2308:	e000ed00 	.word	0xe000ed00
    230c:	00000000 	.word	0x00000000
    2310:	00002551 	.word	0x00002551
    2314:	000023dd 	.word	0x000023dd

00002318 <Config_LCD>:
	REG_TC5_COUNT8_CC1= 26*ContrastValue;
}
/************************************************************************/
/* Initializes LCD, Contrast, and Builds some required symbols          */
/************************************************************************/
void Config_LCD(void){
    2318:	b510      	push	{r4, lr}
	//Config_Contrast_PWM();	//not needed for OLED, since no contrast pin
	//LCD_Init();
	LCD_Init();
    231a:	4b07      	ldr	r3, [pc, #28]	; (2338 <Config_LCD+0x20>)
    231c:	4798      	blx	r3
	LCD_CursorOff();
    231e:	4b07      	ldr	r3, [pc, #28]	; (233c <Config_LCD+0x24>)
    2320:	4798      	blx	r3
	//Build symbol in LCD's CGRAM to be used later on
	LCD_build(0, framelement);	//build '||' symbol at location 0, used to draw frame
    2322:	2000      	movs	r0, #0
    2324:	4906      	ldr	r1, [pc, #24]	; (2340 <Config_LCD+0x28>)
    2326:	4c07      	ldr	r4, [pc, #28]	; (2344 <Config_LCD+0x2c>)
    2328:	47a0      	blx	r4
	LCD_build(1, PILOGO);		//build Polltech LOGO at location 1
    232a:	2001      	movs	r0, #1
    232c:	4906      	ldr	r1, [pc, #24]	; (2348 <Config_LCD+0x30>)
    232e:	47a0      	blx	r4
	LCD_build(2,DegreeSym);
    2330:	2002      	movs	r0, #2
    2332:	4906      	ldr	r1, [pc, #24]	; (234c <Config_LCD+0x34>)
    2334:	47a0      	blx	r4
}
    2336:	bd10      	pop	{r4, pc}
    2338:	00001151 	.word	0x00001151
    233c:	000010fd 	.word	0x000010fd
    2340:	20000004 	.word	0x20000004
    2344:	0000105d 	.word	0x0000105d
    2348:	2000000c 	.word	0x2000000c
    234c:	20000014 	.word	0x20000014

00002350 <Disp_IntroLcdMsgs>:


void Disp_IntroLcdMsgs(void){
    2350:	b570      	push	{r4, r5, r6, lr}
	LCD_PowerOff();
    2352:	4b16      	ldr	r3, [pc, #88]	; (23ac <Disp_IntroLcdMsgs+0x5c>)
    2354:	4798      	blx	r3
	LCD_Frame1();			//make good looking frame around LCD
    2356:	4b16      	ldr	r3, [pc, #88]	; (23b0 <Disp_IntroLcdMsgs+0x60>)
    2358:	4798      	blx	r3
	LCD_Setcursor(1,9);
    235a:	2001      	movs	r0, #1
    235c:	2109      	movs	r1, #9
    235e:	4c15      	ldr	r4, [pc, #84]	; (23b4 <Disp_IntroLcdMsgs+0x64>)
    2360:	47a0      	blx	r4
	LCD_Print("   ");
    2362:	4815      	ldr	r0, [pc, #84]	; (23b8 <Disp_IntroLcdMsgs+0x68>)
    2364:	4d15      	ldr	r5, [pc, #84]	; (23bc <Disp_IntroLcdMsgs+0x6c>)
    2366:	47a8      	blx	r5
	LCD_Setcursor(1,10);
    2368:	2001      	movs	r0, #1
    236a:	210a      	movs	r1, #10
    236c:	47a0      	blx	r4
	LCD_DataWrite(1);		//prints polltech logo that is stored at location 1
    236e:	2001      	movs	r0, #1
    2370:	4b13      	ldr	r3, [pc, #76]	; (23c0 <Disp_IntroLcdMsgs+0x70>)
    2372:	4798      	blx	r3
	LCD_Setcursor(2,2);
    2374:	2002      	movs	r0, #2
    2376:	2102      	movs	r1, #2
    2378:	47a0      	blx	r4
	LCD_Print("     Polltech     ");
    237a:	4812      	ldr	r0, [pc, #72]	; (23c4 <Disp_IntroLcdMsgs+0x74>)
    237c:	47a8      	blx	r5
	LCD_Setcursor(3,2);
    237e:	2003      	movs	r0, #3
    2380:	2102      	movs	r1, #2
    2382:	47a0      	blx	r4
	LCD_Print("    Instruments   ");
    2384:	4810      	ldr	r0, [pc, #64]	; (23c8 <Disp_IntroLcdMsgs+0x78>)
    2386:	47a8      	blx	r5
	LCD_PowerOn();
    2388:	4b10      	ldr	r3, [pc, #64]	; (23cc <Disp_IntroLcdMsgs+0x7c>)
    238a:	4798      	blx	r3
	delay_sec(1);
    238c:	2001      	movs	r0, #1
    238e:	4e10      	ldr	r6, [pc, #64]	; (23d0 <Disp_IntroLcdMsgs+0x80>)
    2390:	47b0      	blx	r6
	LCD_Setcursor(2,2);
    2392:	2002      	movs	r0, #2
    2394:	2102      	movs	r1, #2
    2396:	47a0      	blx	r4
	LCD_Print("StackMonitoringKit");
    2398:	480e      	ldr	r0, [pc, #56]	; (23d4 <Disp_IntroLcdMsgs+0x84>)
    239a:	47a8      	blx	r5
	LCD_Setcursor(3,2);
    239c:	2003      	movs	r0, #3
    239e:	2102      	movs	r1, #2
    23a0:	47a0      	blx	r4
	LCD_Print(" Model PEM-SMK 20 ");
    23a2:	480d      	ldr	r0, [pc, #52]	; (23d8 <Disp_IntroLcdMsgs+0x88>)
    23a4:	47a8      	blx	r5
	
	delay_sec(1);
    23a6:	2001      	movs	r0, #1
    23a8:	47b0      	blx	r6
}
    23aa:	bd70      	pop	{r4, r5, r6, pc}
    23ac:	00001121 	.word	0x00001121
    23b0:	00001089 	.word	0x00001089
    23b4:	00000f81 	.word	0x00000f81
    23b8:	00002850 	.word	0x00002850
    23bc:	00000f25 	.word	0x00000f25
    23c0:	00000ef1 	.word	0x00000ef1
    23c4:	00002854 	.word	0x00002854
    23c8:	00002868 	.word	0x00002868
    23cc:	00001139 	.word	0x00001139
    23d0:	0000129d 	.word	0x0000129d
    23d4:	0000287c 	.word	0x0000287c
    23d8:	00002890 	.word	0x00002890

000023dc <main>:
	WaitFor(EnterKey);
}


int main (void)
{
    23dc:	b570      	push	{r4, r5, r6, lr}
    23de:	b086      	sub	sp, #24
	system_init();
    23e0:	4b25      	ldr	r3, [pc, #148]	; (2478 <main+0x9c>)
    23e2:	4798      	blx	r3
	
	
	
	
	
	Config_MatrixKeypad();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
    23e4:	4b25      	ldr	r3, [pc, #148]	; (247c <main+0xa0>)
    23e6:	4798      	blx	r3
	#ifndef BypassLCD
	Config_LCD();	
    23e8:	4b25      	ldr	r3, [pc, #148]	; (2480 <main+0xa4>)
    23ea:	4798      	blx	r3
	configure_EEPROM();
    23ec:	4b25      	ldr	r3, [pc, #148]	; (2484 <main+0xa8>)
    23ee:	4798      	blx	r3
	CalibrationModeChk();
    23f0:	4b25      	ldr	r3, [pc, #148]	; (2488 <main+0xac>)
    23f2:	4798      	blx	r3
	Disp_IntroLcdMsgs();	//Display company name, model name 
    23f4:	4b25      	ldr	r3, [pc, #148]	; (248c <main+0xb0>)
    23f6:	4798      	blx	r3

	
//	DoAutoZero();
	LCD_Clrscr();
    23f8:	4b25      	ldr	r3, [pc, #148]	; (2490 <main+0xb4>)
    23fa:	4798      	blx	r3
	#endif
	LCD_Setcursor(3,20);
    23fc:	2003      	movs	r0, #3
    23fe:	2114      	movs	r1, #20
    2400:	4c24      	ldr	r4, [pc, #144]	; (2494 <main+0xb8>)
    2402:	47a0      	blx	r4
	LCD_DataWrite(ARROW);
    2404:	207f      	movs	r0, #127	; 0x7f
    2406:	4b24      	ldr	r3, [pc, #144]	; (2498 <main+0xbc>)
    2408:	4798      	blx	r3
	
	LCD_Setcursor(1,1);
    240a:	2001      	movs	r0, #1
    240c:	2101      	movs	r1, #1
    240e:	47a0      	blx	r4
	//"    Yes   /   No    ",
	//LCD_BLANK_LINE_MACRO);
	//LCD_Frame2();
				
//	volatile uint32_t as= CombineDigitstoNumber1(arr, 3);
volatile uint8_t selected=0;
    2410:	466d      	mov	r5, sp
    2412:	2600      	movs	r6, #0
    2414:	75ee      	strb	r6, [r5, #23]
//	selected =LCD_MenuHandle(MenuSize(CalibrationMenu),CalibrationMenu);
//	LCD_FullDisp(MSG[0],MSG[1],MSG[2],MSG[3]);
//	LCD_FullDisp(CalibrationMenu[0],CalibrationMenu[1],CalibrationMenu[2],CalibrationMenu[3]);
//	LCD_MenuDisplay(CalibrationMenu, 4);
	
	LCD_Setcursor(1,2);
    2416:	2001      	movs	r0, #1
    2418:	2102      	movs	r1, #2
    241a:	47a0      	blx	r4
	LCD_CursorOn();
    241c:	4b1f      	ldr	r3, [pc, #124]	; (249c <main+0xc0>)
    241e:	4798      	blx	r3
	LCD_DispAscii(selected);
    2420:	7de8      	ldrb	r0, [r5, #23]
    2422:	b2c0      	uxtb	r0, r0
    2424:	4b1e      	ldr	r3, [pc, #120]	; (24a0 <main+0xc4>)
    2426:	4798      	blx	r3
//	LCD_DispVariable(12345,2,10,0,1);

	Ambient_PT100.STDvalue=1,0021;
    2428:	2201      	movs	r2, #1
    242a:	4b1e      	ldr	r3, [pc, #120]	; (24a4 <main+0xc8>)
    242c:	831a      	strh	r2, [r3, #24]
	volatile uint32_t ans=GetNumDataFromUser(32768,2,3,1,10);
    242e:	240a      	movs	r4, #10
    2430:	9400      	str	r4, [sp, #0]
    2432:	2080      	movs	r0, #128	; 0x80
    2434:	0200      	lsls	r0, r0, #8
    2436:	2102      	movs	r1, #2
    2438:	2203      	movs	r2, #3
    243a:	2301      	movs	r3, #1
    243c:	4d1a      	ldr	r5, [pc, #104]	; (24a8 <main+0xcc>)
    243e:	47a8      	blx	r5
    2440:	9004      	str	r0, [sp, #16]
	LCD_DispVariable(ans, 2, 3, 3, 10);
    2442:	9804      	ldr	r0, [sp, #16]
    2444:	9400      	str	r4, [sp, #0]
    2446:	2102      	movs	r1, #2
    2448:	2203      	movs	r2, #3
    244a:	2303      	movs	r3, #3
    244c:	4c17      	ldr	r4, [pc, #92]	; (24ac <main+0xd0>)
    244e:	47a0      	blx	r4
	volatile uint8_t a,b,c,d;

	a=EE_MISCAddr(c);
    2450:	466b      	mov	r3, sp
    2452:	73de      	strb	r6, [r3, #15]
	b=EE_CALAddr(EE_OrifPart_Z);
    2454:	220b      	movs	r2, #11
    2456:	739a      	strb	r2, [r3, #14]
	c=EE_CALAddr(EE_AuxTemp_STDUP);
    2458:	2249      	movs	r2, #73	; 0x49
    245a:	735a      	strb	r2, [r3, #13]
	d=EE_CALAddr(EE_Abs_ADCLOW);
    245c:	aa03      	add	r2, sp, #12
    245e:	2423      	movs	r4, #35	; 0x23
    2460:	7014      	strb	r4, [r2, #0]
	a=a+b+c+d;
    2462:	7bdc      	ldrb	r4, [r3, #15]
    2464:	7b9d      	ldrb	r5, [r3, #14]
    2466:	7b58      	ldrb	r0, [r3, #13]
    2468:	7811      	ldrb	r1, [r2, #0]
    246a:	192a      	adds	r2, r5, r4
    246c:	1882      	adds	r2, r0, r2
    246e:	188a      	adds	r2, r1, r2
    2470:	b2d2      	uxtb	r2, r2
    2472:	73da      	strb	r2, [r3, #15]
    2474:	e7fe      	b.n	2474 <main+0x98>
    2476:	46c0      	nop			; (mov r8, r8)
    2478:	00002211 	.word	0x00002211
    247c:	000015d9 	.word	0x000015d9
    2480:	00002319 	.word	0x00002319
    2484:	000005c5 	.word	0x000005c5
    2488:	000004c5 	.word	0x000004c5
    248c:	00002351 	.word	0x00002351
    2490:	0000110d 	.word	0x0000110d
    2494:	00000f81 	.word	0x00000f81
    2498:	00000ef1 	.word	0x00000ef1
    249c:	000010ed 	.word	0x000010ed
    24a0:	00000f41 	.word	0x00000f41
    24a4:	20000098 	.word	0x20000098
    24a8:	00000831 	.word	0x00000831
    24ac:	000006d9 	.word	0x000006d9

000024b0 <__aeabi_uidiv>:
    24b0:	2900      	cmp	r1, #0
    24b2:	d034      	beq.n	251e <.udivsi3_skip_div0_test+0x6a>

000024b4 <.udivsi3_skip_div0_test>:
    24b4:	2301      	movs	r3, #1
    24b6:	2200      	movs	r2, #0
    24b8:	b410      	push	{r4}
    24ba:	4288      	cmp	r0, r1
    24bc:	d32c      	bcc.n	2518 <.udivsi3_skip_div0_test+0x64>
    24be:	2401      	movs	r4, #1
    24c0:	0724      	lsls	r4, r4, #28
    24c2:	42a1      	cmp	r1, r4
    24c4:	d204      	bcs.n	24d0 <.udivsi3_skip_div0_test+0x1c>
    24c6:	4281      	cmp	r1, r0
    24c8:	d202      	bcs.n	24d0 <.udivsi3_skip_div0_test+0x1c>
    24ca:	0109      	lsls	r1, r1, #4
    24cc:	011b      	lsls	r3, r3, #4
    24ce:	e7f8      	b.n	24c2 <.udivsi3_skip_div0_test+0xe>
    24d0:	00e4      	lsls	r4, r4, #3
    24d2:	42a1      	cmp	r1, r4
    24d4:	d204      	bcs.n	24e0 <.udivsi3_skip_div0_test+0x2c>
    24d6:	4281      	cmp	r1, r0
    24d8:	d202      	bcs.n	24e0 <.udivsi3_skip_div0_test+0x2c>
    24da:	0049      	lsls	r1, r1, #1
    24dc:	005b      	lsls	r3, r3, #1
    24de:	e7f8      	b.n	24d2 <.udivsi3_skip_div0_test+0x1e>
    24e0:	4288      	cmp	r0, r1
    24e2:	d301      	bcc.n	24e8 <.udivsi3_skip_div0_test+0x34>
    24e4:	1a40      	subs	r0, r0, r1
    24e6:	431a      	orrs	r2, r3
    24e8:	084c      	lsrs	r4, r1, #1
    24ea:	42a0      	cmp	r0, r4
    24ec:	d302      	bcc.n	24f4 <.udivsi3_skip_div0_test+0x40>
    24ee:	1b00      	subs	r0, r0, r4
    24f0:	085c      	lsrs	r4, r3, #1
    24f2:	4322      	orrs	r2, r4
    24f4:	088c      	lsrs	r4, r1, #2
    24f6:	42a0      	cmp	r0, r4
    24f8:	d302      	bcc.n	2500 <.udivsi3_skip_div0_test+0x4c>
    24fa:	1b00      	subs	r0, r0, r4
    24fc:	089c      	lsrs	r4, r3, #2
    24fe:	4322      	orrs	r2, r4
    2500:	08cc      	lsrs	r4, r1, #3
    2502:	42a0      	cmp	r0, r4
    2504:	d302      	bcc.n	250c <.udivsi3_skip_div0_test+0x58>
    2506:	1b00      	subs	r0, r0, r4
    2508:	08dc      	lsrs	r4, r3, #3
    250a:	4322      	orrs	r2, r4
    250c:	2800      	cmp	r0, #0
    250e:	d003      	beq.n	2518 <.udivsi3_skip_div0_test+0x64>
    2510:	091b      	lsrs	r3, r3, #4
    2512:	d001      	beq.n	2518 <.udivsi3_skip_div0_test+0x64>
    2514:	0909      	lsrs	r1, r1, #4
    2516:	e7e3      	b.n	24e0 <.udivsi3_skip_div0_test+0x2c>
    2518:	1c10      	adds	r0, r2, #0
    251a:	bc10      	pop	{r4}
    251c:	4770      	bx	lr
    251e:	2800      	cmp	r0, #0
    2520:	d001      	beq.n	2526 <.udivsi3_skip_div0_test+0x72>
    2522:	2000      	movs	r0, #0
    2524:	43c0      	mvns	r0, r0
    2526:	b407      	push	{r0, r1, r2}
    2528:	4802      	ldr	r0, [pc, #8]	; (2534 <.udivsi3_skip_div0_test+0x80>)
    252a:	a102      	add	r1, pc, #8	; (adr r1, 2534 <.udivsi3_skip_div0_test+0x80>)
    252c:	1840      	adds	r0, r0, r1
    252e:	9002      	str	r0, [sp, #8]
    2530:	bd03      	pop	{r0, r1, pc}
    2532:	46c0      	nop			; (mov r8, r8)
    2534:	00000019 	.word	0x00000019

00002538 <__aeabi_uidivmod>:
    2538:	2900      	cmp	r1, #0
    253a:	d0f0      	beq.n	251e <.udivsi3_skip_div0_test+0x6a>
    253c:	b503      	push	{r0, r1, lr}
    253e:	f7ff ffb9 	bl	24b4 <.udivsi3_skip_div0_test>
    2542:	bc0e      	pop	{r1, r2, r3}
    2544:	4342      	muls	r2, r0
    2546:	1a89      	subs	r1, r1, r2
    2548:	4718      	bx	r3
    254a:	46c0      	nop			; (mov r8, r8)

0000254c <__aeabi_idiv0>:
    254c:	4770      	bx	lr
    254e:	46c0      	nop			; (mov r8, r8)

00002550 <__libc_init_array>:
    2550:	b570      	push	{r4, r5, r6, lr}
    2552:	4b0e      	ldr	r3, [pc, #56]	; (258c <__libc_init_array+0x3c>)
    2554:	4d0e      	ldr	r5, [pc, #56]	; (2590 <__libc_init_array+0x40>)
    2556:	2400      	movs	r4, #0
    2558:	1aed      	subs	r5, r5, r3
    255a:	10ad      	asrs	r5, r5, #2
    255c:	1c1e      	adds	r6, r3, #0
    255e:	42ac      	cmp	r4, r5
    2560:	d004      	beq.n	256c <__libc_init_array+0x1c>
    2562:	00a3      	lsls	r3, r4, #2
    2564:	58f3      	ldr	r3, [r6, r3]
    2566:	4798      	blx	r3
    2568:	3401      	adds	r4, #1
    256a:	e7f8      	b.n	255e <__libc_init_array+0xe>
    256c:	f000 f9e6 	bl	293c <_init>
    2570:	4b08      	ldr	r3, [pc, #32]	; (2594 <__libc_init_array+0x44>)
    2572:	4d09      	ldr	r5, [pc, #36]	; (2598 <__libc_init_array+0x48>)
    2574:	2400      	movs	r4, #0
    2576:	1aed      	subs	r5, r5, r3
    2578:	10ad      	asrs	r5, r5, #2
    257a:	1c1e      	adds	r6, r3, #0
    257c:	42ac      	cmp	r4, r5
    257e:	d004      	beq.n	258a <__libc_init_array+0x3a>
    2580:	00a3      	lsls	r3, r4, #2
    2582:	58f3      	ldr	r3, [r6, r3]
    2584:	4798      	blx	r3
    2586:	3401      	adds	r4, #1
    2588:	e7f8      	b.n	257c <__libc_init_array+0x2c>
    258a:	bd70      	pop	{r4, r5, r6, pc}
    258c:	00002948 	.word	0x00002948
    2590:	00002948 	.word	0x00002948
    2594:	00002948 	.word	0x00002948
    2598:	0000294c 	.word	0x0000294c

0000259c <CalibrationMenu>:
    259c:	62412e31 756c6f73 50206574 73736572     1.Absolute Press
    25ac:	00657275 61502e32 2e697472 69724f20     ure.2.Parti. Ori
    25bc:	50442e66 00202020 61472e33 756f6573     f.DP   .3.Gaseou
    25cc:	724f2073 442e6669 00202050 69502e34     s Orif.DP  .4.Pi
    25dc:	20746f74 20205044 20202020 00202020     tot DP         .
    25ec:	74532e35 206b6361 72656854 75436f6d     5.Stack ThermoCu
    25fc:	00202070 6d412e36 6e656962 65542074     p  .6.Ambient Te
    260c:	202e706d 00202020 654d2e37 20726574     mp.    .7.Meter 
    261c:	706d6554 2020202e 00202020 75412e38     Temp.      .8.Au
    262c:	6c6c6978 20797261 706d6554 0020202e     xillary Temp.  .
    263c:	61502e39 63697472 74616c75 6c462065     9.Particulate Fl
    264c:	0020776f 472e3031 6f657361 46207375     ow .10.Gaseous F
    265c:	20776f6c 00202020 61432020 7262696c     low    .  Calibr
    266c:	6f697461 666f206e 2020203a 00000000     ation of:   ....
    267c:	73624120 74756c6f 72502065 75737365      Absolute Pressu
    268c:	20206572 00000000 6e616353 45202f20     re  ....Scan / E
    269c:	20746964 6578452f 65747563 00000000     dit /Execute....
    26ac:	20202020 20202020 20202020 20202020                     
    26bc:	20202020 00000000 6e616353 646f4d20         ....Scan Mod
    26cc:	41203a65 502e7362 2e736572 00000000     e: Abs.Pres.....
    26dc:	696c6143 74617262 286e6f69 6d206e69     Calibration(in m
    26ec:	2967486d 00000000 65776f4c 20203a72     mHg)....Lower:  
    26fc:	20202020 64745320 2020203a 00000000          Std:   ....
    270c:	65707055 20203a72 20202020 64745320     Upper:       Std
    271c:	2020203a 00000000 494c4e4f 4e20454e     :   ....ONLINE N
    272c:	4920544f 454c504d 544e454d 00000000     OT IMPLEMENT....
    273c:	61766e49 2064696c 206c6143 6974704f     Invalid Cal Opti
    274c:	00006e6f 61432020 7262696c 6f697461     on..  Calibratio
    275c:	6f4d206e 20206564 00000000 45202020     n Mode  ....   E
    276c:	7265746e 73615020 726f7773 20202064     nter Password   
    277c:	00000000 57202020 676e6f72 73615020     ....   Wrong Pas
    278c:	726f7773 20212164 00000000 42000800     sword!! .......B
    279c:	42000c00 42001000 42001400 42001800     ...B...B...B...B
    27ac:	42001c00 3d3d3d3d 3d3d3d3d 3d3d3d3d     ...B============
    27bc:	3d3d3d3d 00003d3d 2d2d2d2d 2d2d2d2d     ======..--------
    27cc:	2d2d2d2d 2d2d2d2d 2d2d2d2d 00000000     ------------....
    27dc:	5f5f5f5f 5f5f5f5f 5f5f5f5f 5f5f5f5f     ________________
    27ec:	5f5f5f5f 00000000 3a677542 44434c20     ____....Bug: LCD
    27fc:	726f485f 75437a69 00000072 00001ae0     _HorizCur.......
    280c:	00001b3c 00001b3c 00001ada 00001ada     <...<...........
    281c:	00001af6 00001ae6 00001afc 00001b2a     ............*...
    282c:	00001ce8 00001d48 00001d48 00001cc8     ....H...H.......
    283c:	00001cda 00001cf6 00001ccc 00001d04     ................
    284c:	00001d38 00202020 20202020 6c6f5020     8...   .     Pol
    285c:	6365746c 20202068 00002020 20202020     ltech     ..    
    286c:	74736e49 656d7572 2073746e 00002020     Instruments   ..
    287c:	63617453 6e6f4d6b 726f7469 4b676e69     StackMonitoringK
    288c:	00007469 646f4d20 50206c65 532d4d45     it.. Model PEM-S
    289c:	32204b4d 00002030 61655220 66207964     MK 20 .. Ready f
    28ac:	4120726f 2d6f7475 6f72655a 00000000     or Auto-Zero....
    28bc:	65654b28 69502070 20626f74 2e737341     (Keep Pitob Ass.
    28cc:	74754f20 00000000 61532026 696c706d      Out....& Sampli
    28dc:	5020676e 20706d75 2966664f 00000000     ng Pump Off)....
    28ec:	72502020 20737365 65746e45 654b2072       Press Enter Ke
    28fc:	20202079 00000000 6f442020 20676e69     y   ....  Doing 
    290c:	6f747541 72655a2d 2020206f 00000000     Auto-Zero   ....
    291c:	2d2d2d2d 00002d2d 41202020 2d6f7475     ------..   Auto-
    292c:	6f72655a 6e6f6420 20202065 00000000     Zero done   ....

0000293c <_init>:
    293c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    293e:	46c0      	nop			; (mov r8, r8)
    2940:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2942:	bc08      	pop	{r3}
    2944:	469e      	mov	lr, r3
    2946:	4770      	bx	lr

00002948 <__init_array_start>:
    2948:	000000d9 	.word	0x000000d9

0000294c <_fini>:
    294c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    294e:	46c0      	nop			; (mov r8, r8)
    2950:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2952:	bc08      	pop	{r3}
    2954:	469e      	mov	lr, r3
    2956:	4770      	bx	lr

00002958 <__fini_array_start>:
    2958:	000000b1 	.word	0x000000b1
