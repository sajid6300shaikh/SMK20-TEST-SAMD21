
SMK20 TEST SAMD21.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000142c  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000001c  20000000  0000142c  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000064  2000001c  00001448  0001001c  2**2
                  ALLOC
  3 .stack        00002000  20000080  000014ac  0001001c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0001001c  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010044  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000ec22  00000000  00000000  0001009f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001e12  00000000  00000000  0001ecc1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00002bb7  00000000  00000000  00020ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000478  00000000  00000000  0002368a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000390  00000000  00000000  00023b02  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00005e6f  00000000  00000000  00023e92  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000988e  00000000  00000000  00029d01  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00088be3  00000000  00000000  0003358f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000aa8  00000000  00000000  000bc174  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20002080 	.word	0x20002080
       4:	000010f5 	.word	0x000010f5
       8:	000010f1 	.word	0x000010f1
       c:	000010f1 	.word	0x000010f1
	...
      2c:	000010f1 	.word	0x000010f1
	...
      38:	000010f1 	.word	0x000010f1
      3c:	000010f1 	.word	0x000010f1
      40:	000010f1 	.word	0x000010f1
      44:	000010f1 	.word	0x000010f1
      48:	000010f1 	.word	0x000010f1
      4c:	000010f1 	.word	0x000010f1
      50:	000010f1 	.word	0x000010f1
      54:	000010f1 	.word	0x000010f1
      58:	000010f1 	.word	0x000010f1
      5c:	000010f1 	.word	0x000010f1
      60:	000010f1 	.word	0x000010f1
      64:	00000111 	.word	0x00000111
      68:	00000121 	.word	0x00000121
      6c:	00000131 	.word	0x00000131
      70:	00000141 	.word	0x00000141
      74:	00000151 	.word	0x00000151
      78:	00000161 	.word	0x00000161
      7c:	000010f1 	.word	0x000010f1
      80:	000010f1 	.word	0x000010f1
      84:	000010f1 	.word	0x000010f1
      88:	000010f1 	.word	0x000010f1
      8c:	000010f1 	.word	0x000010f1
      90:	000010f1 	.word	0x000010f1
      94:	000010f1 	.word	0x000010f1
      98:	000010f1 	.word	0x000010f1
      9c:	000010f1 	.word	0x000010f1
      a0:	000010f1 	.word	0x000010f1
      a4:	000010f1 	.word	0x000010f1
      a8:	000010f1 	.word	0x000010f1
      ac:	000010f1 	.word	0x000010f1

000000b0 <__do_global_dtors_aux>:
      b0:	b510      	push	{r4, lr}
      b2:	4c06      	ldr	r4, [pc, #24]	; (cc <__do_global_dtors_aux+0x1c>)
      b4:	7823      	ldrb	r3, [r4, #0]
      b6:	2b00      	cmp	r3, #0
      b8:	d107      	bne.n	ca <__do_global_dtors_aux+0x1a>
      ba:	4b05      	ldr	r3, [pc, #20]	; (d0 <__do_global_dtors_aux+0x20>)
      bc:	2b00      	cmp	r3, #0
      be:	d002      	beq.n	c6 <__do_global_dtors_aux+0x16>
      c0:	4804      	ldr	r0, [pc, #16]	; (d4 <__do_global_dtors_aux+0x24>)
      c2:	e000      	b.n	c6 <__do_global_dtors_aux+0x16>
      c4:	bf00      	nop
      c6:	2301      	movs	r3, #1
      c8:	7023      	strb	r3, [r4, #0]
      ca:	bd10      	pop	{r4, pc}
      cc:	2000001c 	.word	0x2000001c
      d0:	00000000 	.word	0x00000000
      d4:	0000142c 	.word	0x0000142c

000000d8 <frame_dummy>:
      d8:	b508      	push	{r3, lr}
      da:	4b08      	ldr	r3, [pc, #32]	; (fc <frame_dummy+0x24>)
      dc:	2b00      	cmp	r3, #0
      de:	d003      	beq.n	e8 <frame_dummy+0x10>
      e0:	4807      	ldr	r0, [pc, #28]	; (100 <frame_dummy+0x28>)
      e2:	4908      	ldr	r1, [pc, #32]	; (104 <frame_dummy+0x2c>)
      e4:	e000      	b.n	e8 <frame_dummy+0x10>
      e6:	bf00      	nop
      e8:	4807      	ldr	r0, [pc, #28]	; (108 <frame_dummy+0x30>)
      ea:	6803      	ldr	r3, [r0, #0]
      ec:	2b00      	cmp	r3, #0
      ee:	d003      	beq.n	f8 <frame_dummy+0x20>
      f0:	4b06      	ldr	r3, [pc, #24]	; (10c <frame_dummy+0x34>)
      f2:	2b00      	cmp	r3, #0
      f4:	d000      	beq.n	f8 <frame_dummy+0x20>
      f6:	4798      	blx	r3
      f8:	bd08      	pop	{r3, pc}
      fa:	46c0      	nop			; (mov r8, r8)
      fc:	00000000 	.word	0x00000000
     100:	0000142c 	.word	0x0000142c
     104:	20000020 	.word	0x20000020
     108:	0000142c 	.word	0x0000142c
     10c:	00000000 	.word	0x00000000

00000110 <SERCOM0_Handler>:
	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
}

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
     110:	b508      	push	{r3, lr}
     112:	4b02      	ldr	r3, [pc, #8]	; (11c <SERCOM0_Handler+0xc>)
     114:	681b      	ldr	r3, [r3, #0]
     116:	2000      	movs	r0, #0
     118:	4798      	blx	r3
     11a:	bd08      	pop	{r3, pc}
     11c:	20000038 	.word	0x20000038

00000120 <SERCOM1_Handler>:
     120:	b508      	push	{r3, lr}
     122:	4b02      	ldr	r3, [pc, #8]	; (12c <SERCOM1_Handler+0xc>)
     124:	685b      	ldr	r3, [r3, #4]
     126:	2001      	movs	r0, #1
     128:	4798      	blx	r3
     12a:	bd08      	pop	{r3, pc}
     12c:	20000038 	.word	0x20000038

00000130 <SERCOM2_Handler>:
     130:	b508      	push	{r3, lr}
     132:	4b02      	ldr	r3, [pc, #8]	; (13c <SERCOM2_Handler+0xc>)
     134:	689b      	ldr	r3, [r3, #8]
     136:	2002      	movs	r0, #2
     138:	4798      	blx	r3
     13a:	bd08      	pop	{r3, pc}
     13c:	20000038 	.word	0x20000038

00000140 <SERCOM3_Handler>:
     140:	b508      	push	{r3, lr}
     142:	4b02      	ldr	r3, [pc, #8]	; (14c <SERCOM3_Handler+0xc>)
     144:	68db      	ldr	r3, [r3, #12]
     146:	2003      	movs	r0, #3
     148:	4798      	blx	r3
     14a:	bd08      	pop	{r3, pc}
     14c:	20000038 	.word	0x20000038

00000150 <SERCOM4_Handler>:
     150:	b508      	push	{r3, lr}
     152:	4b02      	ldr	r3, [pc, #8]	; (15c <SERCOM4_Handler+0xc>)
     154:	691b      	ldr	r3, [r3, #16]
     156:	2004      	movs	r0, #4
     158:	4798      	blx	r3
     15a:	bd08      	pop	{r3, pc}
     15c:	20000038 	.word	0x20000038

00000160 <SERCOM5_Handler>:
     160:	b508      	push	{r3, lr}
     162:	4b02      	ldr	r3, [pc, #8]	; (16c <SERCOM5_Handler+0xc>)
     164:	695b      	ldr	r3, [r3, #20]
     166:	2005      	movs	r0, #5
     168:	4798      	blx	r3
     16a:	bd08      	pop	{r3, pc}
     16c:	20000038 	.word	0x20000038

00000170 <PulseLCD_EN>:
	LCD_CmdWrite(0x80);
	checkbusy();  // Move the Cursor to First line First Position
	LCD_PowerOn();
}

void PulseLCD_EN(void){
     170:	b510      	push	{r4, lr}
	PinSet(LCD_EN);
     172:	2480      	movs	r4, #128	; 0x80
     174:	0364      	lsls	r4, r4, #13
     176:	4b04      	ldr	r3, [pc, #16]	; (188 <PulseLCD_EN+0x18>)
     178:	601c      	str	r4, [r3, #0]
	delay_us(ENPulse);
     17a:	2002      	movs	r0, #2
     17c:	4b03      	ldr	r3, [pc, #12]	; (18c <PulseLCD_EN+0x1c>)
     17e:	4798      	blx	r3
	PinClr(LCD_EN);
     180:	4b03      	ldr	r3, [pc, #12]	; (190 <PulseLCD_EN+0x20>)
     182:	601c      	str	r4, [r3, #0]
}
     184:	bd10      	pop	{r4, pc}
     186:	46c0      	nop			; (mov r8, r8)
     188:	41004418 	.word	0x41004418
     18c:	000004a1 	.word	0x000004a1
     190:	41004414 	.word	0x41004414

00000194 <write4bits>:
			break;
	}
}

void write4bits(uint8_t value)
{
     194:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     196:	464f      	mov	r7, r9
     198:	4646      	mov	r6, r8
     19a:	b4c0      	push	{r6, r7}
     19c:	4681      	mov	r9, r0
	for (int i = 0; i < 4; i++)
     19e:	2400      	movs	r4, #0
	{
		pinMode(_data_pins[i], OUTPUT);
     1a0:	4b0d      	ldr	r3, [pc, #52]	; (1d8 <write4bits+0x44>)
     1a2:	4698      	mov	r8, r3
     1a4:	4f0d      	ldr	r7, [pc, #52]	; (1dc <write4bits+0x48>)
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
     1a6:	4e0e      	ldr	r6, [pc, #56]	; (1e0 <write4bits+0x4c>)

void write4bits(uint8_t value)
{
	for (int i = 0; i < 4; i++)
	{
		pinMode(_data_pins[i], OUTPUT);
     1a8:	4643      	mov	r3, r8
     1aa:	18e5      	adds	r5, r4, r3
     1ac:	7828      	ldrb	r0, [r5, #0]
     1ae:	2100      	movs	r1, #0
     1b0:	47b8      	blx	r7
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
     1b2:	7828      	ldrb	r0, [r5, #0]
     1b4:	464b      	mov	r3, r9
     1b6:	4123      	asrs	r3, r4
     1b8:	2101      	movs	r1, #1
     1ba:	4019      	ands	r1, r3
     1bc:	47b0      	blx	r6
	}
}

void write4bits(uint8_t value)
{
	for (int i = 0; i < 4; i++)
     1be:	3401      	adds	r4, #1
     1c0:	2c04      	cmp	r4, #4
     1c2:	d1f1      	bne.n	1a8 <write4bits+0x14>
	{
		pinMode(_data_pins[i], OUTPUT);
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
	}
	delay_us(2);
     1c4:	2002      	movs	r0, #2
     1c6:	4b07      	ldr	r3, [pc, #28]	; (1e4 <write4bits+0x50>)
     1c8:	4798      	blx	r3
	PulseLCD_EN();
     1ca:	4b07      	ldr	r3, [pc, #28]	; (1e8 <write4bits+0x54>)
     1cc:	4798      	blx	r3
}
     1ce:	bc0c      	pop	{r2, r3}
     1d0:	4690      	mov	r8, r2
     1d2:	4699      	mov	r9, r3
     1d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     1d6:	46c0      	nop			; (mov r8, r8)
     1d8:	20000074 	.word	0x20000074
     1dc:	00000841 	.word	0x00000841
     1e0:	00000945 	.word	0x00000945
     1e4:	000004a1 	.word	0x000004a1
     1e8:	00000171 	.word	0x00000171

000001ec <checkbusy>:
	
}


void checkbusy()		//waits until LCD is busy
{
     1ec:	b5f0      	push	{r4, r5, r6, r7, lr}
     1ee:	464f      	mov	r7, r9
     1f0:	4646      	mov	r6, r8
     1f2:	b4c0      	push	{r6, r7}
     1f4:	b083      	sub	sp, #12
#ifndef BypassLCD
//delay_ms(2);
	volatile bool p27=1;			// temporary boolean bit var.
     1f6:	466c      	mov	r4, sp
     1f8:	2301      	movs	r3, #1
     1fa:	71e3      	strb	r3, [r4, #7]

//	WritePin(LCD_D7,1);
	pinMode(LCD_D7, INPUT);		//configure lcd_d7 as input
     1fc:	2013      	movs	r0, #19
     1fe:	2102      	movs	r1, #2
     200:	4b1b      	ldr	r3, [pc, #108]	; (270 <checkbusy+0x84>)
     202:	4798      	blx	r3
	PinClr(LCD_RS);
     204:	2280      	movs	r2, #128	; 0x80
     206:	00d2      	lsls	r2, r2, #3
     208:	4b1a      	ldr	r3, [pc, #104]	; (274 <checkbusy+0x88>)
     20a:	601a      	str	r2, [r3, #0]
	PinSet(LCD_RWb);	//RWb=1 indicates read operation.
     20c:	2280      	movs	r2, #128	; 0x80
     20e:	0392      	lsls	r2, r2, #14
     210:	4b19      	ldr	r3, [pc, #100]	; (278 <checkbusy+0x8c>)
     212:	601a      	str	r2, [r3, #0]
	
	while(p27) 
     214:	79e3      	ldrb	r3, [r4, #7]
     216:	2b00      	cmp	r3, #0
     218:	d01a      	beq.n	250 <checkbusy+0x64>
	{
	PinClr(LCD_EN);
     21a:	4a16      	ldr	r2, [pc, #88]	; (274 <checkbusy+0x88>)
     21c:	4690      	mov	r8, r2
     21e:	2480      	movs	r4, #128	; 0x80
     220:	0364      	lsls	r4, r4, #13
     222:	46a1      	mov	r9, r4
     224:	464b      	mov	r3, r9
     226:	4642      	mov	r2, r8
     228:	6013      	str	r3, [r2, #0]
	delay_us(ENPulse);
     22a:	2002      	movs	r0, #2
     22c:	4f13      	ldr	r7, [pc, #76]	; (27c <checkbusy+0x90>)
     22e:	47b8      	blx	r7
	PinSet(LCD_EN);
     230:	4e11      	ldr	r6, [pc, #68]	; (278 <checkbusy+0x8c>)
     232:	6034      	str	r4, [r6, #0]

		p27=PinRead(LCD_D7);
     234:	4b12      	ldr	r3, [pc, #72]	; (280 <checkbusy+0x94>)
     236:	681b      	ldr	r3, [r3, #0]
     238:	031b      	lsls	r3, r3, #12
     23a:	0fdb      	lsrs	r3, r3, #31
     23c:	466d      	mov	r5, sp
     23e:	71eb      	strb	r3, [r5, #7]
		
	PinClr(LCD_EN);
     240:	4643      	mov	r3, r8
     242:	601c      	str	r4, [r3, #0]
	delay_us(ENPulse);
     244:	2002      	movs	r0, #2
     246:	47b8      	blx	r7
	PinSet(LCD_EN);
     248:	6034      	str	r4, [r6, #0]
//	WritePin(LCD_D7,1);
	pinMode(LCD_D7, INPUT);		//configure lcd_d7 as input
	PinClr(LCD_RS);
	PinSet(LCD_RWb);	//RWb=1 indicates read operation.
	
	while(p27) 
     24a:	79eb      	ldrb	r3, [r5, #7]
     24c:	2b00      	cmp	r3, #0
     24e:	d1e9      	bne.n	224 <checkbusy+0x38>
		
	PinClr(LCD_EN);
	delay_us(ENPulse);
	PinSet(LCD_EN);
	}
	PinClr(LCD_EN);
     250:	4b08      	ldr	r3, [pc, #32]	; (274 <checkbusy+0x88>)
     252:	2280      	movs	r2, #128	; 0x80
     254:	0352      	lsls	r2, r2, #13
     256:	601a      	str	r2, [r3, #0]
	PinClr(LCD_RWb);
     258:	2280      	movs	r2, #128	; 0x80
     25a:	0392      	lsls	r2, r2, #14
     25c:	601a      	str	r2, [r3, #0]
	pinMode(LCD_D7,OUT);	//reconfigure LCD_D7 as output
     25e:	2013      	movs	r0, #19
     260:	2100      	movs	r1, #0
     262:	4b03      	ldr	r3, [pc, #12]	; (270 <checkbusy+0x84>)
     264:	4798      	blx	r3
#endif
}
     266:	b003      	add	sp, #12
     268:	bc0c      	pop	{r2, r3}
     26a:	4690      	mov	r8, r2
     26c:	4699      	mov	r9, r3
     26e:	bdf0      	pop	{r4, r5, r6, r7, pc}
     270:	00000841 	.word	0x00000841
     274:	41004414 	.word	0x41004414
     278:	41004418 	.word	0x41004418
     27c:	000004a1 	.word	0x000004a1
     280:	41004420 	.word	0x41004420

00000284 <LCD_DataWrite>:
	}
	delay_us(2);
	PulseLCD_EN();
}

void LCD_DataWrite(uint8_t Data){
     284:	b538      	push	{r3, r4, r5, lr}
     286:	1c05      	adds	r5, r0, #0
	// Select the Data Register by pulling RS High
	PinSet(LCD_RS);
     288:	2280      	movs	r2, #128	; 0x80
     28a:	00d2      	lsls	r2, r2, #3
     28c:	4b06      	ldr	r3, [pc, #24]	; (2a8 <LCD_DataWrite+0x24>)
     28e:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW LOW
	PinClr(LCD_RWb);
     290:	2280      	movs	r2, #128	; 0x80
     292:	0392      	lsls	r2, r2, #14
     294:	4b05      	ldr	r3, [pc, #20]	; (2ac <LCD_DataWrite+0x28>)
     296:	601a      	str	r2, [r3, #0]
	  
	  write4bits(Data>>4);
     298:	0900      	lsrs	r0, r0, #4
     29a:	4c05      	ldr	r4, [pc, #20]	; (2b0 <LCD_DataWrite+0x2c>)
     29c:	47a0      	blx	r4
	  write4bits(Data);
     29e:	1c28      	adds	r0, r5, #0
     2a0:	47a0      	blx	r4
	  checkbusy();
     2a2:	4b04      	ldr	r3, [pc, #16]	; (2b4 <LCD_DataWrite+0x30>)
     2a4:	4798      	blx	r3
}
     2a6:	bd38      	pop	{r3, r4, r5, pc}
     2a8:	41004418 	.word	0x41004418
     2ac:	41004414 	.word	0x41004414
     2b0:	00000195 	.word	0x00000195
     2b4:	000001ed 	.word	0x000001ed

000002b8 <LCD_Print>:
	checkbusy();
}


void LCD_Print(const char *str)	//usage: LCD_disp("Hello World");
{
     2b8:	b538      	push	{r3, r4, r5, lr}
     2ba:	1c04      	adds	r4, r0, #0
	while(*str) 			//Till string ends
     2bc:	7800      	ldrb	r0, [r0, #0]
     2be:	2800      	cmp	r0, #0
     2c0:	d005      	beq.n	2ce <LCD_Print+0x16>
	LCD_DataWrite(*str++); 	//Send characters one by one
     2c2:	4d03      	ldr	r5, [pc, #12]	; (2d0 <LCD_Print+0x18>)
     2c4:	3401      	adds	r4, #1
     2c6:	47a8      	blx	r5
}


void LCD_Print(const char *str)	//usage: LCD_disp("Hello World");
{
	while(*str) 			//Till string ends
     2c8:	7820      	ldrb	r0, [r4, #0]
     2ca:	2800      	cmp	r0, #0
     2cc:	d1fa      	bne.n	2c4 <LCD_Print+0xc>
	LCD_DataWrite(*str++); 	//Send characters one by one
}
     2ce:	bd38      	pop	{r3, r4, r5, pc}
     2d0:	00000285 	.word	0x00000285

000002d4 <LCD_DispAscii>:
void LCD_DispAscii(char a){	//adds 48 offset to data before sending to LCD, can be used to print single digit no on LCD
     2d4:	b508      	push	{r3, lr}
	LCD_DataWrite(a+48);
     2d6:	3030      	adds	r0, #48	; 0x30
     2d8:	b2c0      	uxtb	r0, r0
     2da:	4b01      	ldr	r3, [pc, #4]	; (2e0 <LCD_DispAscii+0xc>)
     2dc:	4798      	blx	r3
}
     2de:	bd08      	pop	{r3, pc}
     2e0:	00000285 	.word	0x00000285

000002e4 <LCD_CmdWrite>:
	write4bits(Data);
	checkbusy();
}


void LCD_CmdWrite(uint8_t Command){
     2e4:	b538      	push	{r3, r4, r5, lr}
     2e6:	1c05      	adds	r5, r0, #0
	// Select the Command Register by pulling RS pin LOW
	PinClr(LCD_RS);
     2e8:	4b07      	ldr	r3, [pc, #28]	; (308 <LCD_CmdWrite+0x24>)
     2ea:	2280      	movs	r2, #128	; 0x80
     2ec:	00d2      	lsls	r2, r2, #3
     2ee:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW pin LOW
	PinClr(LCD_RWb);
     2f0:	2280      	movs	r2, #128	; 0x80
     2f2:	0392      	lsls	r2, r2, #14
     2f4:	601a      	str	r2, [r3, #0]
	
	write4bits(Command>>4);
     2f6:	0900      	lsrs	r0, r0, #4
     2f8:	4c04      	ldr	r4, [pc, #16]	; (30c <LCD_CmdWrite+0x28>)
     2fa:	47a0      	blx	r4
	write4bits(Command);
     2fc:	1c28      	adds	r0, r5, #0
     2fe:	47a0      	blx	r4
	checkbusy();
     300:	4b03      	ldr	r3, [pc, #12]	; (310 <LCD_CmdWrite+0x2c>)
     302:	4798      	blx	r3
}
     304:	bd38      	pop	{r3, r4, r5, pc}
     306:	46c0      	nop			; (mov r8, r8)
     308:	41004414 	.word	0x41004414
     30c:	00000195 	.word	0x00000195
     310:	000001ed 	.word	0x000001ed

00000314 <LCD_Setcursor>:
	PinClr(LCD_EN);
}
void LCD_Setcursor(char Row, char Column)	
//pass row and column no to this function
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
     314:	b508      	push	{r3, lr}
	switch(Row)		
     316:	2802      	cmp	r0, #2
     318:	d00d      	beq.n	336 <LCD_Setcursor+0x22>
     31a:	d802      	bhi.n	322 <LCD_Setcursor+0xe>
     31c:	2801      	cmp	r0, #1
     31e:	d005      	beq.n	32c <LCD_Setcursor+0x18>
     320:	e017      	b.n	352 <LCD_Setcursor+0x3e>
     322:	2803      	cmp	r0, #3
     324:	d00c      	beq.n	340 <LCD_Setcursor+0x2c>
     326:	2804      	cmp	r0, #4
     328:	d00f      	beq.n	34a <LCD_Setcursor+0x36>
     32a:	e012      	b.n	352 <LCD_Setcursor+0x3e>
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     32c:	317f      	adds	r1, #127	; 0x7f
     32e:	b2c8      	uxtb	r0, r1
     330:	4b08      	ldr	r3, [pc, #32]	; (354 <LCD_Setcursor+0x40>)
     332:	4798      	blx	r3
			break;
     334:	e00d      	b.n	352 <LCD_Setcursor+0x3e>
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     336:	3941      	subs	r1, #65	; 0x41
     338:	b2c8      	uxtb	r0, r1
     33a:	4b06      	ldr	r3, [pc, #24]	; (354 <LCD_Setcursor+0x40>)
     33c:	4798      	blx	r3
			break;
     33e:	e008      	b.n	352 <LCD_Setcursor+0x3e>
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     340:	396d      	subs	r1, #109	; 0x6d
     342:	b2c8      	uxtb	r0, r1
     344:	4b03      	ldr	r3, [pc, #12]	; (354 <LCD_Setcursor+0x40>)
     346:	4798      	blx	r3
			break;
     348:	e003      	b.n	352 <LCD_Setcursor+0x3e>
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     34a:	392d      	subs	r1, #45	; 0x2d
     34c:	b2c8      	uxtb	r0, r1
     34e:	4b01      	ldr	r3, [pc, #4]	; (354 <LCD_Setcursor+0x40>)
     350:	4798      	blx	r3
			break;
	}
}
     352:	bd08      	pop	{r3, pc}
     354:	000002e5 	.word	0x000002e5

00000358 <LCD_build>:
	PinClr(LCD_RWb);
	pinMode(LCD_D7,OUT);	//reconfigure LCD_D7 as output
#endif
}

void LCD_build(uint8_t location, uint8_t *ptr){		//character should be built before writing anything to lcd.
     358:	b570      	push	{r4, r5, r6, lr}
     35a:	1c0e      	adds	r6, r1, #0
	uint8_t i;
	if(location<8){
     35c:	2807      	cmp	r0, #7
     35e:	d80c      	bhi.n	37a <LCD_build+0x22>
		LCD_CmdWrite(0x40+(location*8));	//since each symbol eats up 8 bytes, location is multiplied by 8
     360:	3008      	adds	r0, #8
     362:	00c0      	lsls	r0, r0, #3
     364:	b2c0      	uxtb	r0, r0
     366:	4b05      	ldr	r3, [pc, #20]	; (37c <LCD_build+0x24>)
     368:	4798      	blx	r3
     36a:	1c34      	adds	r4, r6, #0
     36c:	3608      	adds	r6, #8
		for(i=0;i<8;i++)
		LCD_DataWrite(ptr[ i ]);
     36e:	4d04      	ldr	r5, [pc, #16]	; (380 <LCD_build+0x28>)
     370:	7820      	ldrb	r0, [r4, #0]
     372:	47a8      	blx	r5
     374:	3401      	adds	r4, #1

void LCD_build(uint8_t location, uint8_t *ptr){		//character should be built before writing anything to lcd.
	uint8_t i;
	if(location<8){
		LCD_CmdWrite(0x40+(location*8));	//since each symbol eats up 8 bytes, location is multiplied by 8
		for(i=0;i<8;i++)
     376:	42b4      	cmp	r4, r6
     378:	d1fa      	bne.n	370 <LCD_build+0x18>
		LCD_DataWrite(ptr[ i ]);
	}
	
}
     37a:	bd70      	pop	{r4, r5, r6, pc}
     37c:	000002e5 	.word	0x000002e5
     380:	00000285 	.word	0x00000285

00000384 <LCD_CursorOff>:

void LCD_CursorOn(){
	LCD_CmdWrite(0x0E);
}

void LCD_CursorOff(){
     384:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x0C);
     386:	200c      	movs	r0, #12
     388:	4b01      	ldr	r3, [pc, #4]	; (390 <LCD_CursorOff+0xc>)
     38a:	4798      	blx	r3
}
     38c:	bd08      	pop	{r3, pc}
     38e:	46c0      	nop			; (mov r8, r8)
     390:	000002e5 	.word	0x000002e5

00000394 <LCD_Clrscr>:

void LCD_CursorBlink(){
	LCD_CmdWrite(0x0F);
}

void LCD_Clrscr(){
     394:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x01);
     396:	2001      	movs	r0, #1
     398:	4b01      	ldr	r3, [pc, #4]	; (3a0 <LCD_Clrscr+0xc>)
     39a:	4798      	blx	r3
}
     39c:	bd08      	pop	{r3, pc}
     39e:	46c0      	nop			; (mov r8, r8)
     3a0:	000002e5 	.word	0x000002e5

000003a4 <LCD_PowerOn>:
//  [7/25/2015 sajid]
	LCD_CmdWrite(0x13);	//sets internal power off
	checkbusy();  
//---
}
void LCD_PowerOn(){
     3a4:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x17);	//sets internal power ON
     3a6:	2017      	movs	r0, #23
     3a8:	4b02      	ldr	r3, [pc, #8]	; (3b4 <LCD_PowerOn+0x10>)
     3aa:	4798      	blx	r3
	checkbusy();
     3ac:	4b02      	ldr	r3, [pc, #8]	; (3b8 <LCD_PowerOn+0x14>)
     3ae:	4798      	blx	r3
}
     3b0:	bd08      	pop	{r3, pc}
     3b2:	46c0      	nop			; (mov r8, r8)
     3b4:	000002e5 	.word	0x000002e5
     3b8:	000001ed 	.word	0x000001ed

000003bc <LCD_Init>:
#include "Delay.h"


	
void LCD_Init(void)
{
     3bc:	b538      	push	{r3, r4, r5, lr}
//First Setup All port pins properly
//Setup port as output and pin LCD_D7 as output with input read enable.
pinMode(LCD_D4, OUTPUT);		//D4
     3be:	2010      	movs	r0, #16
     3c0:	2100      	movs	r1, #0
     3c2:	4c27      	ldr	r4, [pc, #156]	; (460 <LCD_Init+0xa4>)
     3c4:	47a0      	blx	r4
pinMode(LCD_D5, OUTPUT);		//D5
     3c6:	2011      	movs	r0, #17
     3c8:	2100      	movs	r1, #0
     3ca:	47a0      	blx	r4
pinMode(LCD_D6, OUTPUT);		//D6
     3cc:	2012      	movs	r0, #18
     3ce:	2100      	movs	r1, #0
     3d0:	47a0      	blx	r4
pinMode(LCD_D7, OUTPUT);		//D7, will be changed when we need to read back busy flag
     3d2:	2013      	movs	r0, #19
     3d4:	2100      	movs	r1, #0
     3d6:	47a0      	blx	r4

pinMode(LCD_RS, OUTPUT);
     3d8:	200a      	movs	r0, #10
     3da:	2100      	movs	r1, #0
     3dc:	47a0      	blx	r4
pinMode(LCD_RWb, OUTPUT);
     3de:	2015      	movs	r0, #21
     3e0:	2100      	movs	r1, #0
     3e2:	47a0      	blx	r4
pinMode(LCD_EN, OUTPUT);
     3e4:	2014      	movs	r0, #20
     3e6:	2100      	movs	r1, #0
     3e8:	47a0      	blx	r4
//------------------------------------------------------------------------

 _data_pins[0] = LCD_D4;
     3ea:	4b1e      	ldr	r3, [pc, #120]	; (464 <LCD_Init+0xa8>)
     3ec:	2210      	movs	r2, #16
     3ee:	701a      	strb	r2, [r3, #0]
 _data_pins[1] = LCD_D5;
     3f0:	2211      	movs	r2, #17
     3f2:	705a      	strb	r2, [r3, #1]
 _data_pins[2] = LCD_D6;
     3f4:	2212      	movs	r2, #18
     3f6:	709a      	strb	r2, [r3, #2]
 _data_pins[3] = LCD_D7;
     3f8:	2213      	movs	r2, #19
     3fa:	70da      	strb	r2, [r3, #3]
	// Select the Command Register by pulling RS pin LOW
	PinClr(LCD_RS);
     3fc:	4b1a      	ldr	r3, [pc, #104]	; (468 <LCD_Init+0xac>)
     3fe:	2280      	movs	r2, #128	; 0x80
     400:	00d2      	lsls	r2, r2, #3
     402:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW pin LOW
	PinClr(LCD_RWb);
     404:	2280      	movs	r2, #128	; 0x80
     406:	0392      	lsls	r2, r2, #14
     408:	601a      	str	r2, [r3, #0]

//LCD commands start here

	delay_ms(100);		//w8 for power rail to stabilize
     40a:	2064      	movs	r0, #100	; 0x64
     40c:	4c17      	ldr	r4, [pc, #92]	; (46c <LCD_Init+0xb0>)
     40e:	47a0      	blx	r4
	
	write4bits(0x03);	//put LCD in 8 bit mode
     410:	2003      	movs	r0, #3
     412:	4d17      	ldr	r5, [pc, #92]	; (470 <LCD_Init+0xb4>)
     414:	47a8      	blx	r5
	delay_ms(40);
     416:	2028      	movs	r0, #40	; 0x28
     418:	47a0      	blx	r4
	
	write4bits(0x03);	//again
     41a:	2003      	movs	r0, #3
     41c:	47a8      	blx	r5
	delay_ms(40);
     41e:	2028      	movs	r0, #40	; 0x28
     420:	47a0      	blx	r4
	
	write4bits(0x03);	//again
     422:	2003      	movs	r0, #3
     424:	47a8      	blx	r5
	delay_ms(30);
     426:	201e      	movs	r0, #30
     428:	47a0      	blx	r4
	
	write4bits(0x02);  //Initialize the LCD in 4bit Mode
     42a:	2002      	movs	r0, #2
     42c:	47a8      	blx	r5
	delay_ms(50);
     42e:	2032      	movs	r0, #50	; 0x32
     430:	47a0      	blx	r4
	
	
	LCD_CmdWrite(0x28);	//LCD in 4 bit, 2 lines, 5x8 dots 
     432:	2028      	movs	r0, #40	; 0x28
     434:	4d0f      	ldr	r5, [pc, #60]	; (474 <LCD_Init+0xb8>)
     436:	47a8      	blx	r5
	checkbusy();
     438:	4c0f      	ldr	r4, [pc, #60]	; (478 <LCD_Init+0xbc>)
     43a:	47a0      	blx	r4

	//  [7/25/2015 sajid]
	LCD_CmdWrite(0x08);		//Turn off display, very important for OLED
     43c:	2008      	movs	r0, #8
     43e:	47a8      	blx	r5
	checkbusy();	
     440:	47a0      	blx	r4
	//  [7/25/2015 sajid]
	
	LCD_CmdWrite(0x06);		//Entry mode:Increment, No display shift
     442:	2006      	movs	r0, #6
     444:	47a8      	blx	r5
	checkbusy();
     446:	47a0      	blx	r4
	
	LCD_CmdWrite(0x0E);		// Display ON, cursor ON, Blink Off
     448:	200e      	movs	r0, #14
     44a:	47a8      	blx	r5
	checkbusy();  
     44c:	47a0      	blx	r4
	
	LCD_CmdWrite(0x01);
     44e:	2001      	movs	r0, #1
     450:	47a8      	blx	r5
	checkbusy();  // Clear the LCD
     452:	47a0      	blx	r4
	
	LCD_CmdWrite(0x80);
     454:	2080      	movs	r0, #128	; 0x80
     456:	47a8      	blx	r5
	checkbusy();  // Move the Cursor to First line First Position
     458:	47a0      	blx	r4
	LCD_PowerOn();
     45a:	4b08      	ldr	r3, [pc, #32]	; (47c <LCD_Init+0xc0>)
     45c:	4798      	blx	r3
}
     45e:	bd38      	pop	{r3, r4, r5, pc}
     460:	00000841 	.word	0x00000841
     464:	20000074 	.word	0x20000074
     468:	41004414 	.word	0x41004414
     46c:	000004d9 	.word	0x000004d9
     470:	00000195 	.word	0x00000195
     474:	000002e5 	.word	0x000002e5
     478:	000001ed 	.word	0x000001ed
     47c:	000003a5 	.word	0x000003a5

00000480 <delay_1us>:
#include "compiler.h"

#include "Delay.h"


 void delay_1us() {			//gives 1 us delay
     480:	b082      	sub	sp, #8
	 for (volatile int iter=0; iter<2;iter++)
     482:	2300      	movs	r3, #0
     484:	9301      	str	r3, [sp, #4]
     486:	9b01      	ldr	r3, [sp, #4]
     488:	2b01      	cmp	r3, #1
     48a:	dc07      	bgt.n	49c <delay_1us+0x1c>
	 {
		 asm("NOP");		 
     48c:	46c0      	nop			; (mov r8, r8)
		 asm("NOP");		 
     48e:	46c0      	nop			; (mov r8, r8)

#include "Delay.h"


 void delay_1us() {			//gives 1 us delay
	 for (volatile int iter=0; iter<2;iter++)
     490:	9b01      	ldr	r3, [sp, #4]
     492:	3301      	adds	r3, #1
     494:	9301      	str	r3, [sp, #4]
     496:	9b01      	ldr	r3, [sp, #4]
     498:	2b01      	cmp	r3, #1
     49a:	ddf7      	ble.n	48c <delay_1us+0xc>
	 {
		 asm("NOP");		 
		 asm("NOP");		 
	 }
 }
     49c:	b002      	add	sp, #8
     49e:	4770      	bx	lr

000004a0 <delay_us>:

void delay_us(volatile uint32_t iter_us){	//gives us delay
     4a0:	b510      	push	{r4, lr}
     4a2:	b082      	sub	sp, #8
     4a4:	9001      	str	r0, [sp, #4]
	while(iter_us!=0){
     4a6:	9b01      	ldr	r3, [sp, #4]
     4a8:	2b00      	cmp	r3, #0
     4aa:	d007      	beq.n	4bc <delay_us+0x1c>
		delay_1us();
     4ac:	4c04      	ldr	r4, [pc, #16]	; (4c0 <delay_us+0x20>)
     4ae:	47a0      	blx	r4
		iter_us--;
     4b0:	9b01      	ldr	r3, [sp, #4]
     4b2:	3b01      	subs	r3, #1
     4b4:	9301      	str	r3, [sp, #4]
		 asm("NOP");		 
	 }
 }

void delay_us(volatile uint32_t iter_us){	//gives us delay
	while(iter_us!=0){
     4b6:	9b01      	ldr	r3, [sp, #4]
     4b8:	2b00      	cmp	r3, #0
     4ba:	d1f8      	bne.n	4ae <delay_us+0xe>
		delay_1us();
		iter_us--;
	}
}
     4bc:	b002      	add	sp, #8
     4be:	bd10      	pop	{r4, pc}
     4c0:	00000481 	.word	0x00000481

000004c4 <delay_1ms>:

void delay_1ms() {
     4c4:	b508      	push	{r3, lr}
		delay_us(1050);	//value adjusted to give 1ms delay
     4c6:	4802      	ldr	r0, [pc, #8]	; (4d0 <delay_1ms+0xc>)
     4c8:	4b02      	ldr	r3, [pc, #8]	; (4d4 <delay_1ms+0x10>)
     4ca:	4798      	blx	r3

}
     4cc:	bd08      	pop	{r3, pc}
     4ce:	46c0      	nop			; (mov r8, r8)
     4d0:	0000041a 	.word	0x0000041a
     4d4:	000004a1 	.word	0x000004a1

000004d8 <delay_ms>:

void delay_ms(volatile uint32_t iter_ms){
     4d8:	b510      	push	{r4, lr}
     4da:	b082      	sub	sp, #8
     4dc:	9001      	str	r0, [sp, #4]
	while (iter_ms)
     4de:	9b01      	ldr	r3, [sp, #4]
     4e0:	2b00      	cmp	r3, #0
     4e2:	d007      	beq.n	4f4 <delay_ms+0x1c>
	{
		delay_1ms();
     4e4:	4c04      	ldr	r4, [pc, #16]	; (4f8 <delay_ms+0x20>)
     4e6:	47a0      	blx	r4
		iter_ms--;
     4e8:	9b01      	ldr	r3, [sp, #4]
     4ea:	3b01      	subs	r3, #1
     4ec:	9301      	str	r3, [sp, #4]
		delay_us(1050);	//value adjusted to give 1ms delay

}

void delay_ms(volatile uint32_t iter_ms){
	while (iter_ms)
     4ee:	9b01      	ldr	r3, [sp, #4]
     4f0:	2b00      	cmp	r3, #0
     4f2:	d1f8      	bne.n	4e6 <delay_ms+0xe>
	{
		delay_1ms();
		iter_ms--;
	}
}
     4f4:	b002      	add	sp, #8
     4f6:	bd10      	pop	{r4, pc}
     4f8:	000004c5 	.word	0x000004c5

000004fc <LCD_DispFourOptionsIncrementingFrom>:
/************************************************************************/
/* Has all high level function of LCD to Handle Menu based UI			*/
/************************************************************************/


void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
     4fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     4fe:	0085      	lsls	r5, r0, #2
     500:	1828      	adds	r0, r5, r0
     502:	0080      	lsls	r0, r0, #2
     504:	180d      	adds	r5, r1, r0
	for (char i=0; i<=3; i++)
     506:	2400      	movs	r4, #0
	{
		LCD_Setcursor(i+1,1);
     508:	4f06      	ldr	r7, [pc, #24]	; (524 <LCD_DispFourOptionsIncrementingFrom+0x28>)
		LCD_Print(MenuOptions[StartLine+i]);
     50a:	4e07      	ldr	r6, [pc, #28]	; (528 <LCD_DispFourOptionsIncrementingFrom+0x2c>)


void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
	for (char i=0; i<=3; i++)
	{
		LCD_Setcursor(i+1,1);
     50c:	3401      	adds	r4, #1
     50e:	b2e4      	uxtb	r4, r4
     510:	1c20      	adds	r0, r4, #0
     512:	2101      	movs	r1, #1
     514:	47b8      	blx	r7
		LCD_Print(MenuOptions[StartLine+i]);
     516:	1c28      	adds	r0, r5, #0
     518:	47b0      	blx	r6
     51a:	3514      	adds	r5, #20
/* Has all high level function of LCD to Handle Menu based UI			*/
/************************************************************************/


void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
	for (char i=0; i<=3; i++)
     51c:	2c04      	cmp	r4, #4
     51e:	d1f5      	bne.n	50c <LCD_DispFourOptionsIncrementingFrom+0x10>
	{
		LCD_Setcursor(i+1,1);
		LCD_Print(MenuOptions[StartLine+i]);
	}
	
}
     520:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     522:	46c0      	nop			; (mov r8, r8)
     524:	00000315 	.word	0x00000315
     528:	000002b9 	.word	0x000002b9

0000052c <LCD_DispMenuArrow>:

void LCD_DispMenuArrow(uint8_t Row){
     52c:	b570      	push	{r4, r5, r6, lr}
     52e:	1c06      	adds	r6, r0, #0
	//arrow symbol pointing menu option is shown at extreme right on LCD
	//Clear other Rows
	LCD_Setcursor(1,20);
     530:	2001      	movs	r0, #1
     532:	2114      	movs	r1, #20
     534:	4d0c      	ldr	r5, [pc, #48]	; (568 <LCD_DispMenuArrow+0x3c>)
     536:	47a8      	blx	r5
	LCD_DataWrite(' ');
     538:	2020      	movs	r0, #32
     53a:	4c0c      	ldr	r4, [pc, #48]	; (56c <LCD_DispMenuArrow+0x40>)
     53c:	47a0      	blx	r4
	LCD_Setcursor(2,20);
     53e:	2002      	movs	r0, #2
     540:	2114      	movs	r1, #20
     542:	47a8      	blx	r5
	LCD_DataWrite(' ');
     544:	2020      	movs	r0, #32
     546:	47a0      	blx	r4
	LCD_Setcursor(3,20);
     548:	2003      	movs	r0, #3
     54a:	2114      	movs	r1, #20
     54c:	47a8      	blx	r5
	LCD_DataWrite(' ');
     54e:	2020      	movs	r0, #32
     550:	47a0      	blx	r4
	LCD_Setcursor(4,20);
     552:	2004      	movs	r0, #4
     554:	2114      	movs	r1, #20
     556:	47a8      	blx	r5
	LCD_DataWrite(' ');
     558:	2020      	movs	r0, #32
     55a:	47a0      	blx	r4
	
	LCD_Setcursor(Row,20);
     55c:	1c30      	adds	r0, r6, #0
     55e:	2114      	movs	r1, #20
     560:	47a8      	blx	r5
	LCD_DataWrite(127);
     562:	207f      	movs	r0, #127	; 0x7f
     564:	47a0      	blx	r4
}
     566:	bd70      	pop	{r4, r5, r6, pc}
     568:	00000315 	.word	0x00000315
     56c:	00000285 	.word	0x00000285

00000570 <LCD_MenuHandle>:
	MenuIndex=1;
	return MenuIndex;
}

uint8_t LCD_MenuHandle(uint8_t TotalOptions, const char MenuOptions[][LCDCOLS])
{
     570:	b5f0      	push	{r4, r5, r6, r7, lr}
     572:	465f      	mov	r7, fp
     574:	4656      	mov	r6, sl
     576:	464d      	mov	r5, r9
     578:	4644      	mov	r4, r8
     57a:	b4f0      	push	{r4, r5, r6, r7}
     57c:	b083      	sub	sp, #12
     57e:	4680      	mov	r8, r0
     580:	4689      	mov	r9, r1
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
	//In LCD_DispOptionsIncrementingFrom(optionNo, OptionStringArray) DispOptionno is used to keep track of displayed MSG group
	int8_t DispOptionNo=0;
	LCD_DispFourOptionsIncrementingFrom(0, MenuOptions);	//displays Strings from 0 to 3 of the given string 2D array
     582:	2000      	movs	r0, #0
     584:	4b3c      	ldr	r3, [pc, #240]	; (678 <LCD_MenuHandle+0x108>)
     586:	4798      	blx	r3
	//displays arrow symbol according to location on LCD at 20th Column and Row given by ArrowLoc
	LCD_DispMenuArrow(ArrowLoc);
     588:	2001      	movs	r0, #1
     58a:	4b3c      	ldr	r3, [pc, #240]	; (67c <LCD_MenuHandle+0x10c>)
     58c:	4798      	blx	r3
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
	//In LCD_DispOptionsIncrementingFrom(optionNo, OptionStringArray) DispOptionno is used to keep track of displayed MSG group
	int8_t DispOptionNo=0;
     58e:	2700      	movs	r7, #0
{
	//TotalOptions is nothing but no. of items in menu
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
     590:	2501      	movs	r5, #1

uint8_t LCD_MenuHandle(uint8_t TotalOptions, const char MenuOptions[][LCDCOLS])
{
	//TotalOptions is nothing but no. of items in menu
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
     592:	2601      	movs	r6, #1
				MenuIndex++;
				ArrowLoc++;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
				{
					if (DispOptionNo==(TotalOptions-4))
     594:	2204      	movs	r2, #4
     596:	4252      	negs	r2, r2
     598:	4692      	mov	sl, r2
     59a:	44c2      	add	sl, r8
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
				if (ArrowLoc<1)
				{
					if (DispOptionNo==0)
					{
						DispOptionNo=TotalOptions-4;
     59c:	4653      	mov	r3, sl
     59e:	b2db      	uxtb	r3, r3
     5a0:	469b      	mov	fp, r3
     5a2:	b2da      	uxtb	r2, r3
     5a4:	9201      	str	r2, [sp, #4]
	LCD_DispFourOptionsIncrementingFrom(0, MenuOptions);	//displays Strings from 0 to 3 of the given string 2D array
	//displays arrow symbol according to location on LCD at 20th Column and Row given by ArrowLoc
	LCD_DispMenuArrow(ArrowLoc);
	
	while(1){	//loop forever, this function will be exited by press EnterKey or ParaKey
		if(KeyDetected())
     5a6:	4c36      	ldr	r4, [pc, #216]	; (680 <LCD_MenuHandle+0x110>)
     5a8:	47a0      	blx	r4
     5aa:	2800      	cmp	r0, #0
     5ac:	d0fc      	beq.n	5a8 <LCD_MenuHandle+0x38>
		{//comes here when key is pressed
			Keyscan();		//check which key is pressed
     5ae:	4b35      	ldr	r3, [pc, #212]	; (684 <LCD_MenuHandle+0x114>)
     5b0:	4798      	blx	r3
			if(IncrKey)		//increment key pressed
     5b2:	4b35      	ldr	r3, [pc, #212]	; (688 <LCD_MenuHandle+0x118>)
     5b4:	781b      	ldrb	r3, [r3, #0]
     5b6:	2b00      	cmp	r3, #0
     5b8:	d021      	beq.n	5fe <LCD_MenuHandle+0x8e>
			{
				MenuIndex--;
     5ba:	3e01      	subs	r6, #1
     5bc:	b2f3      	uxtb	r3, r6
				ArrowLoc--;
     5be:	3d01      	subs	r5, #1
     5c0:	b2ed      	uxtb	r5, r5
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
     5c2:	4642      	mov	r2, r8
     5c4:	b2d6      	uxtb	r6, r2
	LCD_Setcursor(Row,20);
	LCD_DataWrite(127);
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
     5c6:	b25a      	sxtb	r2, r3
     5c8:	2a00      	cmp	r2, #0
     5ca:	dd04      	ble.n	5d6 <LCD_MenuHandle+0x66>
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
     5cc:	b271      	sxtb	r1, r6
	MenuIndex=1;
     5ce:	2601      	movs	r6, #1
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
     5d0:	428a      	cmp	r2, r1
     5d2:	dc00      	bgt.n	5d6 <LCD_MenuHandle+0x66>
     5d4:	1c1e      	adds	r6, r3, #0
			if(IncrKey)		//increment key pressed
			{
				MenuIndex--;
				ArrowLoc--;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
				if (ArrowLoc<1)
     5d6:	b26b      	sxtb	r3, r5
     5d8:	2b00      	cmp	r3, #0
     5da:	dc41      	bgt.n	660 <LCD_MenuHandle+0xf0>
				{
					if (DispOptionNo==0)
     5dc:	2f00      	cmp	r7, #0
     5de:	d106      	bne.n	5ee <LCD_MenuHandle+0x7e>
					{
						DispOptionNo=TotalOptions-4;
     5e0:	9f01      	ldr	r7, [sp, #4]
						ArrowLoc=4;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
     5e2:	4658      	mov	r0, fp
     5e4:	4649      	mov	r1, r9
     5e6:	4b24      	ldr	r3, [pc, #144]	; (678 <LCD_MenuHandle+0x108>)
     5e8:	4798      	blx	r3
				if (ArrowLoc<1)
				{
					if (DispOptionNo==0)
					{
						DispOptionNo=TotalOptions-4;
						ArrowLoc=4;
     5ea:	2504      	movs	r5, #4
     5ec:	e038      	b.n	660 <LCD_MenuHandle+0xf0>
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
					}
					else
					{
						DispOptionNo--;
     5ee:	3f01      	subs	r7, #1
     5f0:	b2ff      	uxtb	r7, r7
						ArrowLoc=1;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
     5f2:	b2f8      	uxtb	r0, r7
     5f4:	4649      	mov	r1, r9
     5f6:	4b20      	ldr	r3, [pc, #128]	; (678 <LCD_MenuHandle+0x108>)
     5f8:	4798      	blx	r3
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
					}
					else
					{
						DispOptionNo--;
						ArrowLoc=1;
     5fa:	2501      	movs	r5, #1
     5fc:	e030      	b.n	660 <LCD_MenuHandle+0xf0>
					}
					
				}
			}

			else if(DecrKey)
     5fe:	4b23      	ldr	r3, [pc, #140]	; (68c <LCD_MenuHandle+0x11c>)
     600:	781b      	ldrb	r3, [r3, #0]
     602:	2b00      	cmp	r3, #0
     604:	d022      	beq.n	64c <LCD_MenuHandle+0xdc>
			{
				MenuIndex++;
     606:	1c73      	adds	r3, r6, #1
     608:	b2db      	uxtb	r3, r3
				ArrowLoc++;
     60a:	3501      	adds	r5, #1
     60c:	b2ed      	uxtb	r5, r5
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
     60e:	4642      	mov	r2, r8
     610:	b2d6      	uxtb	r6, r2
	LCD_Setcursor(Row,20);
	LCD_DataWrite(127);
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
     612:	b25a      	sxtb	r2, r3
     614:	2a00      	cmp	r2, #0
     616:	dd04      	ble.n	622 <LCD_MenuHandle+0xb2>
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
     618:	b271      	sxtb	r1, r6
	MenuIndex=1;
     61a:	2601      	movs	r6, #1
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
     61c:	428a      	cmp	r2, r1
     61e:	dc00      	bgt.n	622 <LCD_MenuHandle+0xb2>
     620:	1c1e      	adds	r6, r3, #0
			else if(DecrKey)
			{
				MenuIndex++;
				ArrowLoc++;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
     622:	b26b      	sxtb	r3, r5
     624:	2b04      	cmp	r3, #4
     626:	dd1b      	ble.n	660 <LCD_MenuHandle+0xf0>
				{
					if (DispOptionNo==(TotalOptions-4))
     628:	b27b      	sxtb	r3, r7
     62a:	4553      	cmp	r3, sl
     62c:	d106      	bne.n	63c <LCD_MenuHandle+0xcc>
					{
						DispOptionNo=0;
						ArrowLoc=1;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
     62e:	2000      	movs	r0, #0
     630:	4649      	mov	r1, r9
     632:	4b11      	ldr	r3, [pc, #68]	; (678 <LCD_MenuHandle+0x108>)
     634:	4798      	blx	r3
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
				{
					if (DispOptionNo==(TotalOptions-4))
					{
						DispOptionNo=0;
     636:	2700      	movs	r7, #0
						ArrowLoc=1;
     638:	2501      	movs	r5, #1
     63a:	e011      	b.n	660 <LCD_MenuHandle+0xf0>
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
						
					}
					else
					{
						DispOptionNo++;
     63c:	3701      	adds	r7, #1
     63e:	b2ff      	uxtb	r7, r7
						ArrowLoc=4;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
     640:	b2f8      	uxtb	r0, r7
     642:	4649      	mov	r1, r9
     644:	4b0c      	ldr	r3, [pc, #48]	; (678 <LCD_MenuHandle+0x108>)
     646:	4798      	blx	r3
						
					}
					else
					{
						DispOptionNo++;
						ArrowLoc=4;
     648:	2504      	movs	r5, #4
     64a:	e009      	b.n	660 <LCD_MenuHandle+0xf0>
					}
					
				}
			}
			
			else if(EnterKey)
     64c:	4b10      	ldr	r3, [pc, #64]	; (690 <LCD_MenuHandle+0x120>)
     64e:	781b      	ldrb	r3, [r3, #0]
     650:	2b00      	cmp	r3, #0
     652:	d001      	beq.n	658 <LCD_MenuHandle+0xe8>
			{
				return MenuIndex;
     654:	b2f0      	uxtb	r0, r6
     656:	e008      	b.n	66a <LCD_MenuHandle+0xfa>
			}
			else if (ParaKey)
     658:	4b0e      	ldr	r3, [pc, #56]	; (694 <LCD_MenuHandle+0x124>)
     65a:	781b      	ldrb	r3, [r3, #0]
     65c:	2b00      	cmp	r3, #0
     65e:	d103      	bne.n	668 <LCD_MenuHandle+0xf8>
			{
				return 0;
			}
			LCD_DispMenuArrow(ArrowLoc);
     660:	b2e8      	uxtb	r0, r5
     662:	4b06      	ldr	r3, [pc, #24]	; (67c <LCD_MenuHandle+0x10c>)
     664:	4798      	blx	r3
     666:	e79e      	b.n	5a6 <LCD_MenuHandle+0x36>
			{
				return MenuIndex;
			}
			else if (ParaKey)
			{
				return 0;
     668:	2000      	movs	r0, #0
			}
			LCD_DispMenuArrow(ArrowLoc);
		}
	}
}
     66a:	b003      	add	sp, #12
     66c:	bc3c      	pop	{r2, r3, r4, r5}
     66e:	4690      	mov	r8, r2
     670:	4699      	mov	r9, r3
     672:	46a2      	mov	sl, r4
     674:	46ab      	mov	fp, r5
     676:	bdf0      	pop	{r4, r5, r6, r7, pc}
     678:	000004fd 	.word	0x000004fd
     67c:	0000052d 	.word	0x0000052d
     680:	000006f5 	.word	0x000006f5
     684:	00000731 	.word	0x00000731
     688:	2000007c 	.word	0x2000007c
     68c:	2000007d 	.word	0x2000007d
     690:	2000007b 	.word	0x2000007b
     694:	20000079 	.word	0x20000079

00000698 <Config_MatrixKeypad>:
2 COL configured as Input with Pull up resistor, and 3 rows as Totem-pole OUTPUT
	1. We will first roughly chk for any key press by making all Rows LOW and Checking Both COL for LOW
	2. If any key detected we will wait for debounce period      
	3. And then clear each ROW and check each col to determine which key is pressed   */
/**********************************************************************************************************/
void Config_MatrixKeypad(){	//call this once in your program
     698:	b510      	push	{r4, lr}
	pinMode(COL1, INPUP);		//Make Columns Input with pull up.
     69a:	202d      	movs	r0, #45	; 0x2d
     69c:	2103      	movs	r1, #3
     69e:	4c07      	ldr	r4, [pc, #28]	; (6bc <Config_MatrixKeypad+0x24>)
     6a0:	47a0      	blx	r4
	pinMode(COL2, INPUP);		//INPUP stands for input with pull up.
     6a2:	202e      	movs	r0, #46	; 0x2e
     6a4:	2103      	movs	r1, #3
     6a6:	47a0      	blx	r4
	pinMode(ROW1, OUTPUT);		//Make ROWs as Output
     6a8:	202a      	movs	r0, #42	; 0x2a
     6aa:	2100      	movs	r1, #0
     6ac:	47a0      	blx	r4
	pinMode(ROW2, OUTPUT);
     6ae:	202b      	movs	r0, #43	; 0x2b
     6b0:	2100      	movs	r1, #0
     6b2:	47a0      	blx	r4
	pinMode(ROW3, OUTPUT);
     6b4:	202c      	movs	r0, #44	; 0x2c
     6b6:	2100      	movs	r1, #0
     6b8:	47a0      	blx	r4
}
     6ba:	bd10      	pop	{r4, pc}
     6bc:	00000841 	.word	0x00000841

000006c0 <ClearKeys>:

void ClearKeys(){
	ParaKey =0;
     6c0:	2300      	movs	r3, #0
     6c2:	4a06      	ldr	r2, [pc, #24]	; (6dc <ClearKeys+0x1c>)
     6c4:	7013      	strb	r3, [r2, #0]
	RunKey	=0;
     6c6:	4a06      	ldr	r2, [pc, #24]	; (6e0 <ClearKeys+0x20>)
     6c8:	7013      	strb	r3, [r2, #0]
	StartKey=0;
     6ca:	4a06      	ldr	r2, [pc, #24]	; (6e4 <ClearKeys+0x24>)
     6cc:	7013      	strb	r3, [r2, #0]
	StopKey	=0;
     6ce:	4a06      	ldr	r2, [pc, #24]	; (6e8 <ClearKeys+0x28>)
     6d0:	7013      	strb	r3, [r2, #0]
	UpdateKey=0;
     6d2:	4a06      	ldr	r2, [pc, #24]	; (6ec <ClearKeys+0x2c>)
     6d4:	7013      	strb	r3, [r2, #0]
	EnterKey =0;
     6d6:	4a06      	ldr	r2, [pc, #24]	; (6f0 <ClearKeys+0x30>)
     6d8:	7013      	strb	r3, [r2, #0]
}
     6da:	4770      	bx	lr
     6dc:	20000079 	.word	0x20000079
     6e0:	2000007a 	.word	0x2000007a
     6e4:	2000007c 	.word	0x2000007c
     6e8:	2000007d 	.word	0x2000007d
     6ec:	20000078 	.word	0x20000078
     6f0:	2000007b 	.word	0x2000007b

000006f4 <KeyDetected>:

bool KeyDetected(){
     6f4:	b508      	push	{r3, lr}
	PinClr(ROW1);
     6f6:	4b0c      	ldr	r3, [pc, #48]	; (728 <KeyDetected+0x34>)
     6f8:	2280      	movs	r2, #128	; 0x80
     6fa:	00d2      	lsls	r2, r2, #3
     6fc:	601a      	str	r2, [r3, #0]
	PinClr(ROW2);
     6fe:	2280      	movs	r2, #128	; 0x80
     700:	0112      	lsls	r2, r2, #4
     702:	601a      	str	r2, [r3, #0]
	PinClr(ROW3);
     704:	2280      	movs	r2, #128	; 0x80
     706:	0152      	lsls	r2, r2, #5
     708:	601a      	str	r2, [r3, #0]
	if ((digitalRead(COL1)==0) || (digitalRead(COL2)==0))
     70a:	202d      	movs	r0, #45	; 0x2d
     70c:	4b07      	ldr	r3, [pc, #28]	; (72c <KeyDetected+0x38>)
     70e:	4798      	blx	r3
     710:	1c03      	adds	r3, r0, #0
	{
		return(true);
     712:	2001      	movs	r0, #1

bool KeyDetected(){
	PinClr(ROW1);
	PinClr(ROW2);
	PinClr(ROW3);
	if ((digitalRead(COL1)==0) || (digitalRead(COL2)==0))
     714:	2b00      	cmp	r3, #0
     716:	d005      	beq.n	724 <KeyDetected+0x30>
     718:	202e      	movs	r0, #46	; 0x2e
     71a:	4b04      	ldr	r3, [pc, #16]	; (72c <KeyDetected+0x38>)
     71c:	4798      	blx	r3
     71e:	2301      	movs	r3, #1
     720:	4058      	eors	r0, r3
     722:	b2c0      	uxtb	r0, r0
	{
		return(true);
	}
	else
		return(false);
}
     724:	bd08      	pop	{r3, pc}
     726:	46c0      	nop			; (mov r8, r8)
     728:	41004494 	.word	0x41004494
     72c:	00000979 	.word	0x00000979

00000730 <Keyscan>:


void Keyscan(){			//call this whenever key status required
     730:	b5f0      	push	{r4, r5, r6, r7, lr}
     732:	4657      	mov	r7, sl
     734:	464e      	mov	r6, r9
     736:	4645      	mov	r5, r8
     738:	b4e0      	push	{r5, r6, r7}

	if (KeyDetected())	//if both columns are high, then no key is pressed
     73a:	4b2f      	ldr	r3, [pc, #188]	; (7f8 <Keyscan+0xc8>)
     73c:	4798      	blx	r3
     73e:	2800      	cmp	r0, #0
     740:	d052      	beq.n	7e8 <Keyscan+0xb8>
	{	//program will enter when any key is pressed
		delay_ms(debounce_ms);	//debounce delay
     742:	2014      	movs	r0, #20
     744:	4b2d      	ldr	r3, [pc, #180]	; (7fc <Keyscan+0xcc>)
     746:	4798      	blx	r3
		if (KeyDetected())	//check again
     748:	4b2b      	ldr	r3, [pc, #172]	; (7f8 <Keyscan+0xc8>)
     74a:	4798      	blx	r3
     74c:	2800      	cmp	r0, #0
     74e:	d048      	beq.n	7e2 <Keyscan+0xb2>
		{						 
			//ROW1
			PinClr(ROW1);		//activate ROW 1 and check both columns
     750:	4f2b      	ldr	r7, [pc, #172]	; (800 <Keyscan+0xd0>)
     752:	2380      	movs	r3, #128	; 0x80
     754:	00db      	lsls	r3, r3, #3
     756:	469a      	mov	sl, r3
     758:	603b      	str	r3, [r7, #0]
			PinSet(ROW2);
     75a:	4e2a      	ldr	r6, [pc, #168]	; (804 <Keyscan+0xd4>)
     75c:	2380      	movs	r3, #128	; 0x80
     75e:	011b      	lsls	r3, r3, #4
     760:	4699      	mov	r9, r3
     762:	6033      	str	r3, [r6, #0]
			PinSet(ROW3);
     764:	2380      	movs	r3, #128	; 0x80
     766:	015b      	lsls	r3, r3, #5
     768:	4698      	mov	r8, r3
     76a:	6033      	str	r3, [r6, #0]
			ParaKey	= !(digitalRead(COL1));
     76c:	202d      	movs	r0, #45	; 0x2d
     76e:	4d26      	ldr	r5, [pc, #152]	; (808 <Keyscan+0xd8>)
     770:	47a8      	blx	r5
     772:	2401      	movs	r4, #1
     774:	4060      	eors	r0, r4
     776:	b2c0      	uxtb	r0, r0
     778:	4b24      	ldr	r3, [pc, #144]	; (80c <Keyscan+0xdc>)
     77a:	7018      	strb	r0, [r3, #0]
			RunKey	= !(digitalRead(COL2));
     77c:	202e      	movs	r0, #46	; 0x2e
     77e:	47a8      	blx	r5
     780:	4060      	eors	r0, r4
     782:	b2c0      	uxtb	r0, r0
     784:	4b22      	ldr	r3, [pc, #136]	; (810 <Keyscan+0xe0>)
     786:	7018      	strb	r0, [r3, #0]
			
			//ROW2
			PinSet(ROW1);
     788:	4653      	mov	r3, sl
     78a:	6033      	str	r3, [r6, #0]
			PinClr(ROW2);		//activate ROW 2 and check both columns
     78c:	464b      	mov	r3, r9
     78e:	603b      	str	r3, [r7, #0]
			PinSet(ROW3);
     790:	4643      	mov	r3, r8
     792:	6033      	str	r3, [r6, #0]
			 StartKey= !(digitalRead(COL1));
     794:	202d      	movs	r0, #45	; 0x2d
     796:	47a8      	blx	r5
     798:	4060      	eors	r0, r4
     79a:	b2c0      	uxtb	r0, r0
     79c:	4b1d      	ldr	r3, [pc, #116]	; (814 <Keyscan+0xe4>)
     79e:	7018      	strb	r0, [r3, #0]
			 StopKey	= !(digitalRead(COL2));
     7a0:	202e      	movs	r0, #46	; 0x2e
     7a2:	47a8      	blx	r5
     7a4:	4060      	eors	r0, r4
     7a6:	b2c0      	uxtb	r0, r0
     7a8:	4b1b      	ldr	r3, [pc, #108]	; (818 <Keyscan+0xe8>)
     7aa:	7018      	strb	r0, [r3, #0]
			
			//ROW3
			PinSet(ROW1);		//activate ROW 3 and check both columns
     7ac:	4653      	mov	r3, sl
     7ae:	6033      	str	r3, [r6, #0]
			PinSet(ROW2);
     7b0:	464b      	mov	r3, r9
     7b2:	6033      	str	r3, [r6, #0]
			PinClr(ROW3);
     7b4:	4643      	mov	r3, r8
     7b6:	603b      	str	r3, [r7, #0]
			 UpdateKey= !(digitalRead(COL1));
     7b8:	202d      	movs	r0, #45	; 0x2d
     7ba:	47a8      	blx	r5
     7bc:	4060      	eors	r0, r4
     7be:	b2c0      	uxtb	r0, r0
     7c0:	4b16      	ldr	r3, [pc, #88]	; (81c <Keyscan+0xec>)
     7c2:	7018      	strb	r0, [r3, #0]
			 EnterKey = !(digitalRead(COL2));
     7c4:	202e      	movs	r0, #46	; 0x2e
     7c6:	47a8      	blx	r5
     7c8:	4044      	eors	r4, r0
     7ca:	b2e0      	uxtb	r0, r4
     7cc:	4b14      	ldr	r3, [pc, #80]	; (820 <Keyscan+0xf0>)
     7ce:	7018      	strb	r0, [r3, #0]
			while (KeyDetected())
     7d0:	4c09      	ldr	r4, [pc, #36]	; (7f8 <Keyscan+0xc8>)
			{
				delay_ms(1);	//w8 until all keys are released
     7d2:	4d0a      	ldr	r5, [pc, #40]	; (7fc <Keyscan+0xcc>)
			PinSet(ROW1);		//activate ROW 3 and check both columns
			PinSet(ROW2);
			PinClr(ROW3);
			 UpdateKey= !(digitalRead(COL1));
			 EnterKey = !(digitalRead(COL2));
			while (KeyDetected())
     7d4:	e001      	b.n	7da <Keyscan+0xaa>
			{
				delay_ms(1);	//w8 until all keys are released
     7d6:	2001      	movs	r0, #1
     7d8:	47a8      	blx	r5
			PinSet(ROW1);		//activate ROW 3 and check both columns
			PinSet(ROW2);
			PinClr(ROW3);
			 UpdateKey= !(digitalRead(COL1));
			 EnterKey = !(digitalRead(COL2));
			while (KeyDetected())
     7da:	47a0      	blx	r4
     7dc:	2800      	cmp	r0, #0
     7de:	d1fa      	bne.n	7d6 <Keyscan+0xa6>
     7e0:	e004      	b.n	7ec <Keyscan+0xbc>
			{
				delay_ms(1);	//w8 until all keys are released
			}
		}
		else
			ClearKeys();	
     7e2:	4b10      	ldr	r3, [pc, #64]	; (824 <Keyscan+0xf4>)
     7e4:	4798      	blx	r3
     7e6:	e001      	b.n	7ec <Keyscan+0xbc>
	}
	else
		ClearKeys();
     7e8:	4b0e      	ldr	r3, [pc, #56]	; (824 <Keyscan+0xf4>)
     7ea:	4798      	blx	r3
}
     7ec:	bc1c      	pop	{r2, r3, r4}
     7ee:	4690      	mov	r8, r2
     7f0:	4699      	mov	r9, r3
     7f2:	46a2      	mov	sl, r4
     7f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
     7f6:	46c0      	nop			; (mov r8, r8)
     7f8:	000006f5 	.word	0x000006f5
     7fc:	000004d9 	.word	0x000004d9
     800:	41004494 	.word	0x41004494
     804:	41004498 	.word	0x41004498
     808:	00000979 	.word	0x00000979
     80c:	20000079 	.word	0x20000079
     810:	2000007a 	.word	0x2000007a
     814:	2000007c 	.word	0x2000007c
     818:	2000007d 	.word	0x2000007d
     81c:	20000078 	.word	0x20000078
     820:	2000007b 	.word	0x2000007b
     824:	000006c1 	.word	0x000006c1

00000828 <GCLKGen_Peripheral>:
void GCLKGen_Peripheral(uint8_t GclockGen, uint8_t Peripheral){
//this function writes to 16 bit CLKCTRL register
// [WRTLOCK|CLKEN|GEN()]
	uint16_t Data=0;
  //Data=(CLKEN) |    (GEN[0:3])   | (Peripheral ID[5:0])
	Data=(1<<14) |  (GclockGen<<8) | (Peripheral<<0) ;
     828:	2380      	movs	r3, #128	; 0x80
     82a:	01db      	lsls	r3, r3, #7
     82c:	4319      	orrs	r1, r3
     82e:	0203      	lsls	r3, r0, #8
     830:	1c08      	adds	r0, r1, #0
     832:	4318      	orrs	r0, r3
	CLKCTRL=Data;
     834:	4b01      	ldr	r3, [pc, #4]	; (83c <GCLKGen_Peripheral+0x14>)
     836:	8018      	strh	r0, [r3, #0]
}
     838:	4770      	bx	lr
     83a:	46c0      	nop			; (mov r8, r8)
     83c:	40000c02 	.word	0x40000c02

00000840 <pinMode>:

 OLD approach*/

//usage pinMode(PA15, OUTPUT)
void pinMode(uint8_t Pin, uint8_t mode)
{
     840:	b510      	push	{r4, lr}
	if (mode==OUTPUT) {			//strong Totem Pole output
     842:	2900      	cmp	r1, #0
     844:	d10e      	bne.n	864 <pinMode+0x24>
		DIRSET(Pin);			//enable pin as output
     846:	0943      	lsrs	r3, r0, #5
     848:	01db      	lsls	r3, r3, #7
     84a:	4939      	ldr	r1, [pc, #228]	; (930 <pinMode+0xf0>)
     84c:	185a      	adds	r2, r3, r1
     84e:	211f      	movs	r1, #31
     850:	4008      	ands	r0, r1
     852:	2101      	movs	r1, #1
     854:	4081      	lsls	r1, r0
     856:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)=0;			//disable pull up, input, low drive strength
     858:	4a36      	ldr	r2, [pc, #216]	; (934 <pinMode+0xf4>)
     85a:	1880      	adds	r0, r0, r2
     85c:	18c3      	adds	r3, r0, r3
     85e:	2200      	movs	r2, #0
     860:	701a      	strb	r2, [r3, #0]
     862:	e063      	b.n	92c <pinMode+0xec>
	}
		
	else if (mode==WEAKOUT){	//pin configured as output with weak pull
     864:	2901      	cmp	r1, #1
     866:	d110      	bne.n	88a <pinMode+0x4a>
		DIRCLR(Pin);			//enable pin as output
     868:	0943      	lsrs	r3, r0, #5
     86a:	01db      	lsls	r3, r3, #7
     86c:	4932      	ldr	r1, [pc, #200]	; (938 <pinMode+0xf8>)
     86e:	185a      	adds	r2, r3, r1
     870:	211f      	movs	r1, #31
     872:	4008      	ands	r0, r1
     874:	2101      	movs	r1, #1
     876:	4081      	lsls	r1, r0
     878:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b100;		//enable pull RESISTOR
     87a:	4a2e      	ldr	r2, [pc, #184]	; (934 <pinMode+0xf4>)
     87c:	1880      	adds	r0, r0, r2
     87e:	18c0      	adds	r0, r0, r3
     880:	7802      	ldrb	r2, [r0, #0]
     882:	2304      	movs	r3, #4
     884:	4313      	orrs	r3, r2
     886:	7003      	strb	r3, [r0, #0]
     888:	e050      	b.n	92c <pinMode+0xec>
	//Pull value will be decided by OUT register value
	//when OUT bit is 1 for a particular pin it will be pulled high and for out bit =0 pin will be pulled low
	}
	
	else if(mode==INPUT) {		//high impedance input
     88a:	2902      	cmp	r1, #2
     88c:	d110      	bne.n	8b0 <pinMode+0x70>
		DIRCLR(Pin);			//make pin input
     88e:	0943      	lsrs	r3, r0, #5
     890:	01db      	lsls	r3, r3, #7
     892:	4929      	ldr	r1, [pc, #164]	; (938 <pinMode+0xf8>)
     894:	185a      	adds	r2, r3, r1
     896:	211f      	movs	r1, #31
     898:	4008      	ands	r0, r1
     89a:	2101      	movs	r1, #1
     89c:	4081      	lsls	r1, r0
     89e:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b10;		//enable input pin sampling, pull disabled		
     8a0:	4a24      	ldr	r2, [pc, #144]	; (934 <pinMode+0xf4>)
     8a2:	1880      	adds	r0, r0, r2
     8a4:	18c0      	adds	r0, r0, r3
     8a6:	7802      	ldrb	r2, [r0, #0]
     8a8:	2302      	movs	r3, #2
     8aa:	4313      	orrs	r3, r2
     8ac:	7003      	strb	r3, [r0, #0]
     8ae:	e03d      	b.n	92c <pinMode+0xec>
	}
	
	else if (mode==INOUT){		//pin configured as input and output
     8b0:	2905      	cmp	r1, #5
     8b2:	d110      	bne.n	8d6 <pinMode+0x96>
		DIRSET(Pin);			//enable pin as output
     8b4:	0943      	lsrs	r3, r0, #5
     8b6:	01db      	lsls	r3, r3, #7
     8b8:	491d      	ldr	r1, [pc, #116]	; (930 <pinMode+0xf0>)
     8ba:	185a      	adds	r2, r3, r1
     8bc:	211f      	movs	r1, #31
     8be:	4008      	ands	r0, r1
     8c0:	2101      	movs	r1, #1
     8c2:	4081      	lsls	r1, r0
     8c4:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b10;		//enable input pin sampling
     8c6:	4a1b      	ldr	r2, [pc, #108]	; (934 <pinMode+0xf4>)
     8c8:	1880      	adds	r0, r0, r2
     8ca:	18c0      	adds	r0, r0, r3
     8cc:	7802      	ldrb	r2, [r0, #0]
     8ce:	2302      	movs	r3, #2
     8d0:	4313      	orrs	r3, r2
     8d2:	7003      	strb	r3, [r0, #0]
     8d4:	e02a      	b.n	92c <pinMode+0xec>
	}
	
	else if (mode==INPUP){		//pin configured as input with pull up resistor
     8d6:	2903      	cmp	r1, #3
     8d8:	d113      	bne.n	902 <pinMode+0xc2>
		DIRCLR(Pin);			//enable pin as input
     8da:	0943      	lsrs	r3, r0, #5
     8dc:	01db      	lsls	r3, r3, #7
     8de:	4a16      	ldr	r2, [pc, #88]	; (938 <pinMode+0xf8>)
     8e0:	1899      	adds	r1, r3, r2
     8e2:	221f      	movs	r2, #31
     8e4:	4010      	ands	r0, r2
     8e6:	2201      	movs	r2, #1
     8e8:	4082      	lsls	r2, r0
     8ea:	600a      	str	r2, [r1, #0]
		PINCFG(Pin)|=0b110;		//enable pull and input pin sampling
     8ec:	4911      	ldr	r1, [pc, #68]	; (934 <pinMode+0xf4>)
     8ee:	1840      	adds	r0, r0, r1
     8f0:	18c0      	adds	r0, r0, r3
     8f2:	7804      	ldrb	r4, [r0, #0]
     8f4:	2106      	movs	r1, #6
     8f6:	4321      	orrs	r1, r4
     8f8:	7001      	strb	r1, [r0, #0]
	//pull value(1 or 0) depends on OUT register value, since we want pull up so we will set 'OUT' register bit
		PinSet(Pin);											
     8fa:	4910      	ldr	r1, [pc, #64]	; (93c <pinMode+0xfc>)
     8fc:	185b      	adds	r3, r3, r1
     8fe:	601a      	str	r2, [r3, #0]
     900:	e014      	b.n	92c <pinMode+0xec>
	}
	
	else if (mode==INPDN){		//pin configured as input with pull down resistor
     902:	2904      	cmp	r1, #4
     904:	d112      	bne.n	92c <pinMode+0xec>
		DIRCLR(Pin);			//enable pin as input
     906:	0943      	lsrs	r3, r0, #5
     908:	01db      	lsls	r3, r3, #7
     90a:	4a0b      	ldr	r2, [pc, #44]	; (938 <pinMode+0xf8>)
     90c:	1899      	adds	r1, r3, r2
     90e:	221f      	movs	r2, #31
     910:	4010      	ands	r0, r2
     912:	2201      	movs	r2, #1
     914:	4082      	lsls	r2, r0
     916:	600a      	str	r2, [r1, #0]
		PINCFG(Pin)|=0b110;		//enable pull and input pin sampling
     918:	4906      	ldr	r1, [pc, #24]	; (934 <pinMode+0xf4>)
     91a:	1840      	adds	r0, r0, r1
     91c:	18c0      	adds	r0, r0, r3
     91e:	7804      	ldrb	r4, [r0, #0]
     920:	2106      	movs	r1, #6
     922:	4321      	orrs	r1, r4
     924:	7001      	strb	r1, [r0, #0]
	//pull value(1 or 0) depends on OUT register value, since we want pull dwn so we will clear 'OUT' register bit
		PinClr(Pin);
     926:	4906      	ldr	r1, [pc, #24]	; (940 <pinMode+0x100>)
     928:	185b      	adds	r3, r3, r1
     92a:	601a      	str	r2, [r3, #0]
	}
		
}
     92c:	bd10      	pop	{r4, pc}
     92e:	46c0      	nop			; (mov r8, r8)
     930:	41004408 	.word	0x41004408
     934:	41004440 	.word	0x41004440
     938:	41004404 	.word	0x41004404
     93c:	41004418 	.word	0x41004418
     940:	41004414 	.word	0x41004414

00000944 <digitalWrite>:

//usage digitalWrite(PA20, HIGH); to set pin PA20
//Alternatively you can use PinSet(PA20) and PinClr(pin_no) macros
void digitalWrite(uint8_t pin_no, bool val){
	if (val==1)
     944:	2900      	cmp	r1, #0
     946:	d009      	beq.n	95c <digitalWrite+0x18>
	{
		PinSet(pin_no);
     948:	0943      	lsrs	r3, r0, #5
     94a:	01db      	lsls	r3, r3, #7
     94c:	4a08      	ldr	r2, [pc, #32]	; (970 <digitalWrite+0x2c>)
     94e:	189b      	adds	r3, r3, r2
     950:	221f      	movs	r2, #31
     952:	4010      	ands	r0, r2
     954:	2201      	movs	r2, #1
     956:	4082      	lsls	r2, r0
     958:	601a      	str	r2, [r3, #0]
     95a:	e008      	b.n	96e <digitalWrite+0x2a>
	}
	else
	{
		
		PinClr(pin_no);
     95c:	0943      	lsrs	r3, r0, #5
     95e:	01db      	lsls	r3, r3, #7
     960:	4a04      	ldr	r2, [pc, #16]	; (974 <digitalWrite+0x30>)
     962:	189b      	adds	r3, r3, r2
     964:	221f      	movs	r2, #31
     966:	4010      	ands	r0, r2
     968:	2201      	movs	r2, #1
     96a:	4082      	lsls	r2, r0
     96c:	601a      	str	r2, [r3, #0]
	}
}
     96e:	4770      	bx	lr
     970:	41004418 	.word	0x41004418
     974:	41004414 	.word	0x41004414

00000978 <digitalRead>:

//usage bool a= digitalRead(PB20); a will contain status of pin PB20
//Alternatively You can use macro function eg:PinRead(PA04), since this function also does the same.
bool digitalRead(uint8_t Pin){
	return(PinRead(Pin));
     978:	0943      	lsrs	r3, r0, #5
     97a:	01db      	lsls	r3, r3, #7
     97c:	4a06      	ldr	r2, [pc, #24]	; (998 <digitalRead+0x20>)
     97e:	189b      	adds	r3, r3, r2
     980:	681b      	ldr	r3, [r3, #0]
     982:	221f      	movs	r2, #31
     984:	4010      	ands	r0, r2
     986:	2201      	movs	r2, #1
     988:	4082      	lsls	r2, r0
     98a:	1c10      	adds	r0, r2, #0
     98c:	4018      	ands	r0, r3
     98e:	1e43      	subs	r3, r0, #1
     990:	4198      	sbcs	r0, r3
     992:	b2c0      	uxtb	r0, r0
}
     994:	4770      	bx	lr
     996:	46c0      	nop			; (mov r8, r8)
     998:	41004420 	.word	0x41004420

0000099c <pinMux>:


	/*		Usage: pinMux(PA2, ADC);		*/
//REFER S_PORT.h To get list of PINMUX peripheral names
	 
void pinMux(uint8_t Pin, uint8_t peripheral){ //refer S_PORT.h for available options for peripheral.
     99c:	b530      	push	{r4, r5, lr}
//Enable PINMUX for the pin
if (peripheral==0x0A)
     99e:	290a      	cmp	r1, #10
     9a0:	d10b      	bne.n	9ba <pinMux+0x1e>
{
	PINCFG(Pin)&=0xFE;	//clr bit 0
     9a2:	231f      	movs	r3, #31
     9a4:	4003      	ands	r3, r0
     9a6:	4a17      	ldr	r2, [pc, #92]	; (a04 <pinMux+0x68>)
     9a8:	189b      	adds	r3, r3, r2
     9aa:	0940      	lsrs	r0, r0, #5
     9ac:	01c0      	lsls	r0, r0, #7
     9ae:	1818      	adds	r0, r3, r0
     9b0:	7803      	ldrb	r3, [r0, #0]
     9b2:	2201      	movs	r2, #1
     9b4:	4393      	bics	r3, r2
     9b6:	7003      	strb	r3, [r0, #0]
     9b8:	e023      	b.n	a02 <pinMux+0x66>
}
else
{
	PINCFG(Pin) = 0b1;
     9ba:	0942      	lsrs	r2, r0, #5
     9bc:	01d2      	lsls	r2, r2, #7
     9be:	231f      	movs	r3, #31
     9c0:	4003      	ands	r3, r0
     9c2:	4d10      	ldr	r5, [pc, #64]	; (a04 <pinMux+0x68>)
     9c4:	195c      	adds	r4, r3, r5
     9c6:	18a4      	adds	r4, r4, r2
     9c8:	2501      	movs	r5, #1
     9ca:	7025      	strb	r5, [r4, #0]
	//peripheral &= 0x0F;						//makes sure peripheral is 4 bit value
	if ((Pin%32) %2==0)						//even pin no. corresponds to lower nibble in Pmux reg
     9cc:	07c4      	lsls	r4, r0, #31
     9ce:	d40b      	bmi.n	9e8 <pinMux+0x4c>
	{
		PMUX(Pin)&=0xF0;		//clr all lower bits
     9d0:	085b      	lsrs	r3, r3, #1
     9d2:	4d0d      	ldr	r5, [pc, #52]	; (a08 <pinMux+0x6c>)
     9d4:	195b      	adds	r3, r3, r5
     9d6:	189a      	adds	r2, r3, r2
     9d8:	7813      	ldrb	r3, [r2, #0]
     9da:	200f      	movs	r0, #15
     9dc:	4383      	bics	r3, r0
     9de:	7013      	strb	r3, [r2, #0]
		PMUX(Pin)|= peripheral;	// place data in lower nibble
     9e0:	7813      	ldrb	r3, [r2, #0]
     9e2:	4319      	orrs	r1, r3
     9e4:	7011      	strb	r1, [r2, #0]
     9e6:	e00c      	b.n	a02 <pinMux+0x66>
	} 
	else  {								//odd pin no. corresponds to higher nibble in Pmux register
		PMUX(Pin)&=0x0F;		//set all higher bits
     9e8:	085b      	lsrs	r3, r3, #1
     9ea:	4807      	ldr	r0, [pc, #28]	; (a08 <pinMux+0x6c>)
     9ec:	181b      	adds	r3, r3, r0
     9ee:	189b      	adds	r3, r3, r2
     9f0:	7818      	ldrb	r0, [r3, #0]
     9f2:	220f      	movs	r2, #15
     9f4:	4002      	ands	r2, r0
     9f6:	701a      	strb	r2, [r3, #0]
		PMUX(Pin)|=(peripheral<<4);	// place data in higher nibble
     9f8:	781a      	ldrb	r2, [r3, #0]
     9fa:	0109      	lsls	r1, r1, #4
     9fc:	4311      	orrs	r1, r2
     9fe:	b2c9      	uxtb	r1, r1
     a00:	7019      	strb	r1, [r3, #0]
	}
}
     a02:	bd30      	pop	{r4, r5, pc}
     a04:	41004440 	.word	0x41004440
     a08:	41004430 	.word	0x41004430

00000a0c <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
     a0c:	4b0c      	ldr	r3, [pc, #48]	; (a40 <cpu_irq_enter_critical+0x34>)
     a0e:	681b      	ldr	r3, [r3, #0]
     a10:	2b00      	cmp	r3, #0
     a12:	d110      	bne.n	a36 <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     a14:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
     a18:	2b00      	cmp	r3, #0
     a1a:	d109      	bne.n	a30 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
     a1c:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
     a1e:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
     a22:	2200      	movs	r2, #0
     a24:	4b07      	ldr	r3, [pc, #28]	; (a44 <cpu_irq_enter_critical+0x38>)
     a26:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
     a28:	2201      	movs	r2, #1
     a2a:	4b07      	ldr	r3, [pc, #28]	; (a48 <cpu_irq_enter_critical+0x3c>)
     a2c:	701a      	strb	r2, [r3, #0]
     a2e:	e002      	b.n	a36 <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
     a30:	2200      	movs	r2, #0
     a32:	4b05      	ldr	r3, [pc, #20]	; (a48 <cpu_irq_enter_critical+0x3c>)
     a34:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
     a36:	4b02      	ldr	r3, [pc, #8]	; (a40 <cpu_irq_enter_critical+0x34>)
     a38:	681a      	ldr	r2, [r3, #0]
     a3a:	3201      	adds	r2, #1
     a3c:	601a      	str	r2, [r3, #0]
}
     a3e:	4770      	bx	lr
     a40:	20000050 	.word	0x20000050
     a44:	20000000 	.word	0x20000000
     a48:	20000054 	.word	0x20000054

00000a4c <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
     a4c:	4b08      	ldr	r3, [pc, #32]	; (a70 <cpu_irq_leave_critical+0x24>)
     a4e:	681a      	ldr	r2, [r3, #0]
     a50:	3a01      	subs	r2, #1
     a52:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
     a54:	681b      	ldr	r3, [r3, #0]
     a56:	2b00      	cmp	r3, #0
     a58:	d109      	bne.n	a6e <cpu_irq_leave_critical+0x22>
     a5a:	4b06      	ldr	r3, [pc, #24]	; (a74 <cpu_irq_leave_critical+0x28>)
     a5c:	781b      	ldrb	r3, [r3, #0]
     a5e:	2b00      	cmp	r3, #0
     a60:	d005      	beq.n	a6e <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
     a62:	2201      	movs	r2, #1
     a64:	4b04      	ldr	r3, [pc, #16]	; (a78 <cpu_irq_leave_critical+0x2c>)
     a66:	701a      	strb	r2, [r3, #0]
     a68:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
     a6c:	b662      	cpsie	i
	}
}
     a6e:	4770      	bx	lr
     a70:	20000050 	.word	0x20000050
     a74:	20000054 	.word	0x20000054
     a78:	20000000 	.word	0x20000000

00000a7c <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
     a7c:	b5f0      	push	{r4, r5, r6, r7, lr}
     a7e:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     a80:	ac01      	add	r4, sp, #4
     a82:	2501      	movs	r5, #1
     a84:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
     a86:	2700      	movs	r7, #0
     a88:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
     a8a:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
     a8c:	203e      	movs	r0, #62	; 0x3e
     a8e:	1c21      	adds	r1, r4, #0
     a90:	4e06      	ldr	r6, [pc, #24]	; (aac <system_board_init+0x30>)
     a92:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     a94:	2280      	movs	r2, #128	; 0x80
     a96:	05d2      	lsls	r2, r2, #23
     a98:	4b05      	ldr	r3, [pc, #20]	; (ab0 <system_board_init+0x34>)
     a9a:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
     a9c:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
     a9e:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
     aa0:	200f      	movs	r0, #15
     aa2:	1c21      	adds	r1, r4, #0
     aa4:	47b0      	blx	r6
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
     aa6:	b003      	add	sp, #12
     aa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     aaa:	46c0      	nop			; (mov r8, r8)
     aac:	00000ab5 	.word	0x00000ab5
     ab0:	41004480 	.word	0x41004480

00000ab4 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
     ab4:	b500      	push	{lr}
     ab6:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     ab8:	ab01      	add	r3, sp, #4
     aba:	2280      	movs	r2, #128	; 0x80
     abc:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
     abe:	780a      	ldrb	r2, [r1, #0]
     ac0:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
     ac2:	784a      	ldrb	r2, [r1, #1]
     ac4:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
     ac6:	788a      	ldrb	r2, [r1, #2]
     ac8:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
     aca:	1c19      	adds	r1, r3, #0
     acc:	4b01      	ldr	r3, [pc, #4]	; (ad4 <port_pin_set_config+0x20>)
     ace:	4798      	blx	r3
}
     ad0:	b003      	add	sp, #12
     ad2:	bd00      	pop	{pc}
     ad4:	0000109d 	.word	0x0000109d

00000ad8 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
     ad8:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
     ada:	4b0c      	ldr	r3, [pc, #48]	; (b0c <system_clock_source_osc8m_set_config+0x34>)
     adc:	6a1c      	ldr	r4, [r3, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
     ade:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
     ae0:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
     ae2:	7840      	ldrb	r0, [r0, #1]
     ae4:	2201      	movs	r2, #1
     ae6:	4010      	ands	r0, r2
     ae8:	0180      	lsls	r0, r0, #6
     aea:	2640      	movs	r6, #64	; 0x40
     aec:	43b4      	bics	r4, r6
     aee:	4304      	orrs	r4, r0
     af0:	402a      	ands	r2, r5
     af2:	01d0      	lsls	r0, r2, #7
     af4:	2280      	movs	r2, #128	; 0x80
     af6:	4394      	bics	r4, r2
     af8:	1c22      	adds	r2, r4, #0
     afa:	4302      	orrs	r2, r0
     afc:	2003      	movs	r0, #3
     afe:	4001      	ands	r1, r0
     b00:	0209      	lsls	r1, r1, #8
     b02:	4803      	ldr	r0, [pc, #12]	; (b10 <system_clock_source_osc8m_set_config+0x38>)
     b04:	4002      	ands	r2, r0
     b06:	430a      	orrs	r2, r1
     b08:	621a      	str	r2, [r3, #32]
}
     b0a:	bd70      	pop	{r4, r5, r6, pc}
     b0c:	40000800 	.word	0x40000800
     b10:	fffffcff 	.word	0xfffffcff

00000b14 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
     b14:	b5f0      	push	{r4, r5, r6, r7, lr}
     b16:	465f      	mov	r7, fp
     b18:	4656      	mov	r6, sl
     b1a:	464d      	mov	r5, r9
     b1c:	4644      	mov	r4, r8
     b1e:	b4f0      	push	{r4, r5, r6, r7}
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
     b20:	4a25      	ldr	r2, [pc, #148]	; (bb8 <system_clock_source_xosc32k_set_config+0xa4>)
     b22:	8a94      	ldrh	r4, [r2, #20]

	temp.bit.STARTUP = config->startup_time;
     b24:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
     b26:	7803      	ldrb	r3, [r0, #0]
     b28:	4259      	negs	r1, r3
     b2a:	4159      	adcs	r1, r3
     b2c:	468a      	mov	sl, r1
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
     b2e:	7883      	ldrb	r3, [r0, #2]
     b30:	469c      	mov	ip, r3
	temp.bit.EN1K = config->enable_1khz_output;
     b32:	78c1      	ldrb	r1, [r0, #3]
     b34:	4688      	mov	r8, r1
	temp.bit.EN32K = config->enable_32khz_output;
     b36:	7903      	ldrb	r3, [r0, #4]
     b38:	4699      	mov	r9, r3

	temp.bit.ONDEMAND = config->on_demand;
     b3a:	7b46      	ldrb	r6, [r0, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
     b3c:	7b07      	ldrb	r7, [r0, #12]
	temp.bit.WRTLOCK  = config->write_once;
     b3e:	7b81      	ldrb	r1, [r0, #14]
     b40:	468b      	mov	fp, r1

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
     b42:	6880      	ldr	r0, [r0, #8]
     b44:	4b1d      	ldr	r3, [pc, #116]	; (bbc <system_clock_source_xosc32k_set_config+0xa8>)
     b46:	6158      	str	r0, [r3, #20]

	SYSCTRL->XOSC32K = temp;
     b48:	2301      	movs	r3, #1
     b4a:	4651      	mov	r1, sl
     b4c:	0088      	lsls	r0, r1, #2
     b4e:	2104      	movs	r1, #4
     b50:	438c      	bics	r4, r1
     b52:	4304      	orrs	r4, r0
     b54:	4648      	mov	r0, r9
     b56:	4018      	ands	r0, r3
     b58:	00c0      	lsls	r0, r0, #3
     b5a:	2108      	movs	r1, #8
     b5c:	438c      	bics	r4, r1
     b5e:	4304      	orrs	r4, r0
     b60:	4640      	mov	r0, r8
     b62:	4018      	ands	r0, r3
     b64:	0100      	lsls	r0, r0, #4
     b66:	2110      	movs	r1, #16
     b68:	438c      	bics	r4, r1
     b6a:	4304      	orrs	r4, r0
     b6c:	4660      	mov	r0, ip
     b6e:	4018      	ands	r0, r3
     b70:	0140      	lsls	r0, r0, #5
     b72:	2120      	movs	r1, #32
     b74:	438c      	bics	r4, r1
     b76:	4304      	orrs	r4, r0
     b78:	1c18      	adds	r0, r3, #0
     b7a:	4038      	ands	r0, r7
     b7c:	0180      	lsls	r0, r0, #6
     b7e:	2740      	movs	r7, #64	; 0x40
     b80:	43bc      	bics	r4, r7
     b82:	4304      	orrs	r4, r0
     b84:	1c18      	adds	r0, r3, #0
     b86:	4030      	ands	r0, r6
     b88:	01c0      	lsls	r0, r0, #7
     b8a:	2680      	movs	r6, #128	; 0x80
     b8c:	43b4      	bics	r4, r6
     b8e:	4304      	orrs	r4, r0
     b90:	2007      	movs	r0, #7
     b92:	4028      	ands	r0, r5
     b94:	0200      	lsls	r0, r0, #8
     b96:	4d0a      	ldr	r5, [pc, #40]	; (bc0 <system_clock_source_xosc32k_set_config+0xac>)
     b98:	402c      	ands	r4, r5
     b9a:	4304      	orrs	r4, r0
     b9c:	4659      	mov	r1, fp
     b9e:	400b      	ands	r3, r1
     ba0:	0319      	lsls	r1, r3, #12
     ba2:	4808      	ldr	r0, [pc, #32]	; (bc4 <system_clock_source_xosc32k_set_config+0xb0>)
     ba4:	1c23      	adds	r3, r4, #0
     ba6:	4003      	ands	r3, r0
     ba8:	430b      	orrs	r3, r1
     baa:	8293      	strh	r3, [r2, #20]
}
     bac:	bc3c      	pop	{r2, r3, r4, r5}
     bae:	4690      	mov	r8, r2
     bb0:	4699      	mov	r9, r3
     bb2:	46a2      	mov	sl, r4
     bb4:	46ab      	mov	fp, r5
     bb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     bb8:	40000800 	.word	0x40000800
     bbc:	20000058 	.word	0x20000058
     bc0:	fffff8ff 	.word	0xfffff8ff
     bc4:	ffffefff 	.word	0xffffefff

00000bc8 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
     bc8:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
     bca:	7a02      	ldrb	r2, [r0, #8]
     bcc:	0692      	lsls	r2, r2, #26
     bce:	0c12      	lsrs	r2, r2, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
     bd0:	8943      	ldrh	r3, [r0, #10]
     bd2:	059b      	lsls	r3, r3, #22
     bd4:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
     bd6:	431a      	orrs	r2, r3
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
     bd8:	4b15      	ldr	r3, [pc, #84]	; (c30 <system_clock_source_dfll_set_config+0x68>)
     bda:	605a      	str	r2, [r3, #4]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
     bdc:	8881      	ldrh	r1, [r0, #4]
     bde:	8842      	ldrh	r2, [r0, #2]
     be0:	4311      	orrs	r1, r2
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
     be2:	79c4      	ldrb	r4, [r0, #7]
     be4:	7982      	ldrb	r2, [r0, #6]
     be6:	4322      	orrs	r2, r4
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
     be8:	430a      	orrs	r2, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
     bea:	7841      	ldrb	r1, [r0, #1]
     bec:	01c9      	lsls	r1, r1, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
     bee:	430a      	orrs	r2, r1
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
     bf0:	601a      	str	r2, [r3, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
     bf2:	7803      	ldrb	r3, [r0, #0]
     bf4:	2b04      	cmp	r3, #4
     bf6:	d10f      	bne.n	c18 <system_clock_source_dfll_set_config+0x50>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
     bf8:	7b02      	ldrb	r2, [r0, #12]
     bfa:	0692      	lsls	r2, r2, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
     bfc:	8a03      	ldrh	r3, [r0, #16]
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
     bfe:	431a      	orrs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
     c00:	89c3      	ldrh	r3, [r0, #14]
     c02:	041b      	lsls	r3, r3, #16
     c04:	490b      	ldr	r1, [pc, #44]	; (c34 <system_clock_source_dfll_set_config+0x6c>)
     c06:	400b      	ands	r3, r1
     c08:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
     c0a:	4b09      	ldr	r3, [pc, #36]	; (c30 <system_clock_source_dfll_set_config+0x68>)
     c0c:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
     c0e:	6819      	ldr	r1, [r3, #0]
     c10:	2204      	movs	r2, #4
     c12:	430a      	orrs	r2, r1
     c14:	601a      	str	r2, [r3, #0]
     c16:	e009      	b.n	c2c <system_clock_source_dfll_set_config+0x64>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
     c18:	2b20      	cmp	r3, #32
     c1a:	d107      	bne.n	c2c <system_clock_source_dfll_set_config+0x64>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
     c1c:	8a02      	ldrh	r2, [r0, #16]
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
     c1e:	4b04      	ldr	r3, [pc, #16]	; (c30 <system_clock_source_dfll_set_config+0x68>)
     c20:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
     c22:	6819      	ldr	r1, [r3, #0]
     c24:	2284      	movs	r2, #132	; 0x84
     c26:	00d2      	lsls	r2, r2, #3
     c28:	430a      	orrs	r2, r1
     c2a:	601a      	str	r2, [r3, #0]
				SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
     c2c:	bd10      	pop	{r4, pc}
     c2e:	46c0      	nop			; (mov r8, r8)
     c30:	20000058 	.word	0x20000058
     c34:	03ff0000 	.word	0x03ff0000

00000c38 <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
     c38:	2808      	cmp	r0, #8
     c3a:	d843      	bhi.n	cc4 <system_clock_source_enable+0x8c>
     c3c:	0080      	lsls	r0, r0, #2
     c3e:	4b22      	ldr	r3, [pc, #136]	; (cc8 <system_clock_source_enable+0x90>)
     c40:	581b      	ldr	r3, [r3, r0]
     c42:	469f      	mov	pc, r3
		break;
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
     c44:	2000      	movs	r0, #0
     c46:	e03e      	b.n	cc6 <system_clock_source_enable+0x8e>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
     c48:	4b20      	ldr	r3, [pc, #128]	; (ccc <system_clock_source_enable+0x94>)
     c4a:	6a19      	ldr	r1, [r3, #32]
     c4c:	2202      	movs	r2, #2
     c4e:	430a      	orrs	r2, r1
     c50:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
     c52:	2000      	movs	r0, #0
     c54:	e037      	b.n	cc6 <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
     c56:	4b1d      	ldr	r3, [pc, #116]	; (ccc <system_clock_source_enable+0x94>)
     c58:	6999      	ldr	r1, [r3, #24]
     c5a:	2202      	movs	r2, #2
     c5c:	430a      	orrs	r2, r1
     c5e:	619a      	str	r2, [r3, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     c60:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
     c62:	e030      	b.n	cc6 <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
     c64:	4b19      	ldr	r3, [pc, #100]	; (ccc <system_clock_source_enable+0x94>)
     c66:	8a19      	ldrh	r1, [r3, #16]
     c68:	2202      	movs	r2, #2
     c6a:	430a      	orrs	r2, r1
     c6c:	821a      	strh	r2, [r3, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     c6e:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
     c70:	e029      	b.n	cc6 <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
     c72:	4b16      	ldr	r3, [pc, #88]	; (ccc <system_clock_source_enable+0x94>)
     c74:	8a99      	ldrh	r1, [r3, #20]
     c76:	2202      	movs	r2, #2
     c78:	430a      	orrs	r2, r1
     c7a:	829a      	strh	r2, [r3, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     c7c:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
     c7e:	e022      	b.n	cc6 <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
     c80:	4b13      	ldr	r3, [pc, #76]	; (cd0 <system_clock_source_enable+0x98>)
     c82:	6819      	ldr	r1, [r3, #0]
     c84:	2202      	movs	r2, #2
     c86:	430a      	orrs	r2, r1
     c88:	601a      	str	r2, [r3, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
     c8a:	681a      	ldr	r2, [r3, #0]
     c8c:	4b11      	ldr	r3, [pc, #68]	; (cd4 <system_clock_source_enable+0x9c>)
     c8e:	401a      	ands	r2, r3
     c90:	4b0e      	ldr	r3, [pc, #56]	; (ccc <system_clock_source_enable+0x94>)
     c92:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
     c94:	1c19      	adds	r1, r3, #0
     c96:	2210      	movs	r2, #16
     c98:	68cb      	ldr	r3, [r1, #12]
     c9a:	421a      	tst	r2, r3
     c9c:	d0fc      	beq.n	c98 <system_clock_source_enable+0x60>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
     c9e:	4a0c      	ldr	r2, [pc, #48]	; (cd0 <system_clock_source_enable+0x98>)
     ca0:	6891      	ldr	r1, [r2, #8]
     ca2:	4b0a      	ldr	r3, [pc, #40]	; (ccc <system_clock_source_enable+0x94>)
     ca4:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
     ca6:	6851      	ldr	r1, [r2, #4]
     ca8:	6299      	str	r1, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
     caa:	6812      	ldr	r2, [r2, #0]
     cac:	b292      	uxth	r2, r2
     cae:	849a      	strh	r2, [r3, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     cb0:	2000      	movs	r0, #0
     cb2:	e008      	b.n	cc6 <system_clock_source_enable+0x8e>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
     cb4:	4a05      	ldr	r2, [pc, #20]	; (ccc <system_clock_source_enable+0x94>)
     cb6:	2344      	movs	r3, #68	; 0x44
     cb8:	5cd0      	ldrb	r0, [r2, r3]
     cba:	2102      	movs	r1, #2
     cbc:	4301      	orrs	r1, r0
     cbe:	54d1      	strb	r1, [r2, r3]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     cc0:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
     cc2:	e000      	b.n	cc6 <system_clock_source_enable+0x8e>
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
     cc4:	2017      	movs	r0, #23
	}

	return STATUS_OK;
}
     cc6:	4770      	bx	lr
     cc8:	00001320 	.word	0x00001320
     ccc:	40000800 	.word	0x40000800
     cd0:	20000058 	.word	0x20000058
     cd4:	0000ff7f 	.word	0x0000ff7f

00000cd8 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
     cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
     cda:	b08f      	sub	sp, #60	; 0x3c
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
     cdc:	22c2      	movs	r2, #194	; 0xc2
     cde:	00d2      	lsls	r2, r2, #3
     ce0:	4b4b      	ldr	r3, [pc, #300]	; (e10 <system_clock_init+0x138>)
     ce2:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
     ce4:	4b4b      	ldr	r3, [pc, #300]	; (e14 <system_clock_init+0x13c>)
     ce6:	685a      	ldr	r2, [r3, #4]
     ce8:	211e      	movs	r1, #30
     cea:	438a      	bics	r2, r1
     cec:	2104      	movs	r1, #4
     cee:	430a      	orrs	r2, r1
     cf0:	605a      	str	r2, [r3, #4]
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
     cf2:	2202      	movs	r2, #2
     cf4:	ab01      	add	r3, sp, #4
     cf6:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
     cf8:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
     cfa:	4d47      	ldr	r5, [pc, #284]	; (e18 <system_clock_init+0x140>)
     cfc:	b2e0      	uxtb	r0, r4
     cfe:	a901      	add	r1, sp, #4
     d00:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
     d02:	3401      	adds	r4, #1
     d04:	2c25      	cmp	r4, #37	; 0x25
     d06:	d1f9      	bne.n	cfc <system_clock_init+0x24>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
     d08:	a80a      	add	r0, sp, #40	; 0x28
     d0a:	2300      	movs	r3, #0
     d0c:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
     d0e:	2204      	movs	r2, #4
     d10:	7042      	strb	r2, [r0, #1]
	config->auto_gain_control   = false;
     d12:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
     d14:	2280      	movs	r2, #128	; 0x80
     d16:	0212      	lsls	r2, r2, #8
     d18:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
     d1a:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
     d1c:	2201      	movs	r2, #1
     d1e:	7102      	strb	r2, [r0, #4]
	config->run_in_standby      = false;
     d20:	7303      	strb	r3, [r0, #12]
	config->on_demand           = true;
	config->write_once          = false;
     d22:	7383      	strb	r3, [r0, #14]
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
     d24:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
     d26:	466a      	mov	r2, sp
     d28:	84d3      	strh	r3, [r2, #38]	; 0x26
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
     d2a:	4b3c      	ldr	r3, [pc, #240]	; (e1c <system_clock_init+0x144>)
     d2c:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
     d2e:	2005      	movs	r0, #5
     d30:	4b3b      	ldr	r3, [pc, #236]	; (e20 <system_clock_init+0x148>)
     d32:	4798      	blx	r3

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
     d34:	4836      	ldr	r0, [pc, #216]	; (e10 <system_clock_init+0x138>)
     d36:	2102      	movs	r1, #2
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
		XOSC32RDYCount++;
     d38:	466b      	mov	r3, sp
     d3a:	3326      	adds	r3, #38	; 0x26
		if(XOSC32RDYCount>60000){
     d3c:	4c39      	ldr	r4, [pc, #228]	; (e24 <system_clock_init+0x14c>)
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
     d3e:	e00b      	b.n	d58 <system_clock_init+0x80>
		XOSC32RDYCount++;
     d40:	881a      	ldrh	r2, [r3, #0]
     d42:	3201      	adds	r2, #1
     d44:	b292      	uxth	r2, r2
     d46:	801a      	strh	r2, [r3, #0]
		if(XOSC32RDYCount>60000){
     d48:	881a      	ldrh	r2, [r3, #0]
     d4a:	b292      	uxth	r2, r2
     d4c:	42a2      	cmp	r2, r4
     d4e:	d903      	bls.n	d58 <system_clock_init+0x80>
			XOSC32Fail=1;
     d50:	2201      	movs	r2, #1
     d52:	4b35      	ldr	r3, [pc, #212]	; (e28 <system_clock_init+0x150>)
     d54:	701a      	strb	r2, [r3, #0]
			break;
     d56:	e002      	b.n	d5e <system_clock_init+0x86>

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
     d58:	68c2      	ldr	r2, [r0, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
     d5a:	4211      	tst	r1, r2
     d5c:	d0f0      	beq.n	d40 <system_clock_init+0x68>
			XOSC32Fail=1;
			break;
		}
		}			//sajid here it waits for XOSC32
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
     d5e:	4b2c      	ldr	r3, [pc, #176]	; (e10 <system_clock_init+0x138>)
     d60:	8a99      	ldrh	r1, [r3, #20]
     d62:	2280      	movs	r2, #128	; 0x80
     d64:	430a      	orrs	r2, r1
     d66:	829a      	strh	r2, [r3, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
     d68:	a805      	add	r0, sp, #20
     d6a:	2300      	movs	r3, #0
     d6c:	2500      	movs	r5, #0
     d6e:	8043      	strh	r3, [r0, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
     d70:	8083      	strh	r3, [r0, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
     d72:	7185      	strb	r5, [r0, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
     d74:	71c5      	strb	r5, [r0, #7]
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
     d76:	2207      	movs	r2, #7
     d78:	7202      	strb	r2, [r0, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
     d7a:	233f      	movs	r3, #63	; 0x3f
     d7c:	8143      	strh	r3, [r0, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
     d7e:	2104      	movs	r1, #4
     d80:	7001      	strb	r1, [r0, #0]
	dfll_conf.on_demand      = false;
     d82:	7045      	strb	r5, [r0, #1]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
     d84:	4929      	ldr	r1, [pc, #164]	; (e2c <system_clock_init+0x154>)
     d86:	8201      	strh	r1, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
     d88:	7302      	strb	r2, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
     d8a:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
     d8c:	4b28      	ldr	r3, [pc, #160]	; (e30 <system_clock_init+0x158>)
     d8e:	4798      	blx	r3
		struct system_clock_source_osc8m_config *const config)
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
     d90:	a804      	add	r0, sp, #16
     d92:	7045      	strb	r5, [r0, #1]
	config->on_demand       = true;
     d94:	2601      	movs	r6, #1
     d96:	7086      	strb	r6, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
     d98:	7005      	strb	r5, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
     d9a:	4b26      	ldr	r3, [pc, #152]	; (e34 <system_clock_init+0x15c>)
     d9c:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
     d9e:	2006      	movs	r0, #6
     da0:	4f1f      	ldr	r7, [pc, #124]	; (e20 <system_clock_init+0x148>)
     da2:	47b8      	blx	r7


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
     da4:	4b24      	ldr	r3, [pc, #144]	; (e38 <system_clock_init+0x160>)
     da6:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
     da8:	ac01      	add	r4, sp, #4
     daa:	9602      	str	r6, [sp, #8]
	config->high_when_disabled = false;
     dac:	7065      	strb	r5, [r4, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
     dae:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
     db0:	7265      	strb	r5, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(8, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
     db2:	2305      	movs	r3, #5
     db4:	7023      	strb	r3, [r4, #0]
     db6:	2001      	movs	r0, #1
     db8:	1c21      	adds	r1, r4, #0
     dba:	4b20      	ldr	r3, [pc, #128]	; (e3c <system_clock_init+0x164>)
     dbc:	4798      	blx	r3
     dbe:	2001      	movs	r0, #1
     dc0:	4b1f      	ldr	r3, [pc, #124]	; (e40 <system_clock_init+0x168>)
     dc2:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
     dc4:	7026      	strb	r6, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
     dc6:	2000      	movs	r0, #0
     dc8:	1c21      	adds	r1, r4, #0
     dca:	4b13      	ldr	r3, [pc, #76]	; (e18 <system_clock_init+0x140>)
     dcc:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
     dce:	2000      	movs	r0, #0
     dd0:	4b1c      	ldr	r3, [pc, #112]	; (e44 <system_clock_init+0x16c>)
     dd2:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
     dd4:	2007      	movs	r0, #7
     dd6:	47b8      	blx	r7

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
     dd8:	490d      	ldr	r1, [pc, #52]	; (e10 <system_clock_init+0x138>)
     dda:	22d0      	movs	r2, #208	; 0xd0
     ddc:	68cb      	ldr	r3, [r1, #12]
     dde:	4013      	ands	r3, r2


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
     de0:	2bd0      	cmp	r3, #208	; 0xd0
     de2:	d1fb      	bne.n	ddc <system_clock_init+0x104>
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
     de4:	4a18      	ldr	r2, [pc, #96]	; (e48 <system_clock_init+0x170>)
     de6:	2300      	movs	r3, #0
     de8:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
     dea:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
     dec:	7293      	strb	r3, [r2, #10]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
     dee:	a901      	add	r1, sp, #4
     df0:	2201      	movs	r2, #1
     df2:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
     df4:	704b      	strb	r3, [r1, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
     df6:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
     df8:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
     dfa:	2307      	movs	r3, #7
     dfc:	700b      	strb	r3, [r1, #0]
     dfe:	2000      	movs	r0, #0
     e00:	4b0e      	ldr	r3, [pc, #56]	; (e3c <system_clock_init+0x164>)
     e02:	4798      	blx	r3
     e04:	2000      	movs	r0, #0
     e06:	4b0e      	ldr	r3, [pc, #56]	; (e40 <system_clock_init+0x168>)
     e08:	4798      	blx	r3
#endif
}
     e0a:	b00f      	add	sp, #60	; 0x3c
     e0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e0e:	46c0      	nop			; (mov r8, r8)
     e10:	40000800 	.word	0x40000800
     e14:	41004000 	.word	0x41004000
     e18:	00000ff5 	.word	0x00000ff5
     e1c:	00000b15 	.word	0x00000b15
     e20:	00000c39 	.word	0x00000c39
     e24:	0000ea60 	.word	0x0000ea60
     e28:	20000070 	.word	0x20000070
     e2c:	000005b9 	.word	0x000005b9
     e30:	00000bc9 	.word	0x00000bc9
     e34:	00000ad9 	.word	0x00000ad9
     e38:	00000e4d 	.word	0x00000e4d
     e3c:	00000e71 	.word	0x00000e71
     e40:	00000f25 	.word	0x00000f25
     e44:	00000f69 	.word	0x00000f69
     e48:	40000400 	.word	0x40000400

00000e4c <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
     e4c:	4b06      	ldr	r3, [pc, #24]	; (e68 <system_gclk_init+0x1c>)
     e4e:	6999      	ldr	r1, [r3, #24]
     e50:	2208      	movs	r2, #8
     e52:	430a      	orrs	r2, r1
     e54:	619a      	str	r2, [r3, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
     e56:	2201      	movs	r2, #1
     e58:	4b04      	ldr	r3, [pc, #16]	; (e6c <system_gclk_init+0x20>)
     e5a:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
     e5c:	1c19      	adds	r1, r3, #0
     e5e:	780b      	ldrb	r3, [r1, #0]
     e60:	4213      	tst	r3, r2
     e62:	d1fc      	bne.n	e5e <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
     e64:	4770      	bx	lr
     e66:	46c0      	nop			; (mov r8, r8)
     e68:	40000400 	.word	0x40000400
     e6c:	40000c00 	.word	0x40000c00

00000e70 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
     e70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     e72:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
     e74:	1c07      	adds	r7, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
     e76:	780d      	ldrb	r5, [r1, #0]
     e78:	022d      	lsls	r5, r5, #8
     e7a:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
     e7c:	784b      	ldrb	r3, [r1, #1]
     e7e:	2b00      	cmp	r3, #0
     e80:	d002      	beq.n	e88 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
     e82:	2380      	movs	r3, #128	; 0x80
     e84:	02db      	lsls	r3, r3, #11
     e86:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
     e88:	7a4b      	ldrb	r3, [r1, #9]
     e8a:	2b00      	cmp	r3, #0
     e8c:	d002      	beq.n	e94 <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
     e8e:	2380      	movs	r3, #128	; 0x80
     e90:	031b      	lsls	r3, r3, #12
     e92:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
     e94:	684c      	ldr	r4, [r1, #4]
     e96:	2c01      	cmp	r4, #1
     e98:	d917      	bls.n	eca <system_gclk_gen_set_config+0x5a>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
     e9a:	1e63      	subs	r3, r4, #1
     e9c:	421c      	tst	r4, r3
     e9e:	d10f      	bne.n	ec0 <system_gclk_gen_set_config+0x50>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
     ea0:	2c02      	cmp	r4, #2
     ea2:	d906      	bls.n	eb2 <system_gclk_gen_set_config+0x42>
     ea4:	2302      	movs	r3, #2
     ea6:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
     ea8:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
     eaa:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
     eac:	429c      	cmp	r4, r3
     eae:	d8fb      	bhi.n	ea8 <system_gclk_gen_set_config+0x38>
     eb0:	e000      	b.n	eb4 <system_gclk_gen_set_config+0x44>
     eb2:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
     eb4:	0217      	lsls	r7, r2, #8
     eb6:	4337      	orrs	r7, r6
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
     eb8:	2380      	movs	r3, #128	; 0x80
     eba:	035b      	lsls	r3, r3, #13
     ebc:	431d      	orrs	r5, r3
     ebe:	e004      	b.n	eca <system_gclk_gen_set_config+0x5a>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
     ec0:	0227      	lsls	r7, r4, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
     ec2:	4337      	orrs	r7, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
     ec4:	2380      	movs	r3, #128	; 0x80
     ec6:	029b      	lsls	r3, r3, #10
     ec8:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
     eca:	7a0b      	ldrb	r3, [r1, #8]
     ecc:	2b00      	cmp	r3, #0
     ece:	d002      	beq.n	ed6 <system_gclk_gen_set_config+0x66>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
     ed0:	2380      	movs	r3, #128	; 0x80
     ed2:	039b      	lsls	r3, r3, #14
     ed4:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
     ed6:	4a0f      	ldr	r2, [pc, #60]	; (f14 <system_gclk_gen_set_config+0xa4>)
     ed8:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
     eda:	b25b      	sxtb	r3, r3
     edc:	2b00      	cmp	r3, #0
     ede:	dbfb      	blt.n	ed8 <system_gclk_gen_set_config+0x68>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
     ee0:	4b0d      	ldr	r3, [pc, #52]	; (f18 <system_gclk_gen_set_config+0xa8>)
     ee2:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
     ee4:	4b0d      	ldr	r3, [pc, #52]	; (f1c <system_gclk_gen_set_config+0xac>)
     ee6:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
     ee8:	4a0a      	ldr	r2, [pc, #40]	; (f14 <system_gclk_gen_set_config+0xa4>)
     eea:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
     eec:	b25b      	sxtb	r3, r3
     eee:	2b00      	cmp	r3, #0
     ef0:	dbfb      	blt.n	eea <system_gclk_gen_set_config+0x7a>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
     ef2:	4b08      	ldr	r3, [pc, #32]	; (f14 <system_gclk_gen_set_config+0xa4>)
     ef4:	609f      	str	r7, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
     ef6:	1c1a      	adds	r2, r3, #0
     ef8:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
     efa:	b25b      	sxtb	r3, r3
     efc:	2b00      	cmp	r3, #0
     efe:	dbfb      	blt.n	ef8 <system_gclk_gen_set_config+0x88>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
     f00:	4b04      	ldr	r3, [pc, #16]	; (f14 <system_gclk_gen_set_config+0xa4>)
     f02:	6859      	ldr	r1, [r3, #4]
     f04:	2280      	movs	r2, #128	; 0x80
     f06:	0252      	lsls	r2, r2, #9
     f08:	400a      	ands	r2, r1
     f0a:	4315      	orrs	r5, r2
     f0c:	605d      	str	r5, [r3, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
     f0e:	4b04      	ldr	r3, [pc, #16]	; (f20 <system_gclk_gen_set_config+0xb0>)
     f10:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
     f12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     f14:	40000c00 	.word	0x40000c00
     f18:	00000a0d 	.word	0x00000a0d
     f1c:	40000c08 	.word	0x40000c08
     f20:	00000a4d 	.word	0x00000a4d

00000f24 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
     f24:	b510      	push	{r4, lr}
     f26:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
     f28:	4a0b      	ldr	r2, [pc, #44]	; (f58 <system_gclk_gen_enable+0x34>)
     f2a:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
     f2c:	b25b      	sxtb	r3, r3
     f2e:	2b00      	cmp	r3, #0
     f30:	dbfb      	blt.n	f2a <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
     f32:	4b0a      	ldr	r3, [pc, #40]	; (f5c <system_gclk_gen_enable+0x38>)
     f34:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
     f36:	4b0a      	ldr	r3, [pc, #40]	; (f60 <system_gclk_gen_enable+0x3c>)
     f38:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
     f3a:	4a07      	ldr	r2, [pc, #28]	; (f58 <system_gclk_gen_enable+0x34>)
     f3c:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
     f3e:	b25b      	sxtb	r3, r3
     f40:	2b00      	cmp	r3, #0
     f42:	dbfb      	blt.n	f3c <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
     f44:	4b04      	ldr	r3, [pc, #16]	; (f58 <system_gclk_gen_enable+0x34>)
     f46:	6859      	ldr	r1, [r3, #4]
     f48:	2280      	movs	r2, #128	; 0x80
     f4a:	0252      	lsls	r2, r2, #9
     f4c:	430a      	orrs	r2, r1
     f4e:	605a      	str	r2, [r3, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
     f50:	4b04      	ldr	r3, [pc, #16]	; (f64 <system_gclk_gen_enable+0x40>)
     f52:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
     f54:	bd10      	pop	{r4, pc}
     f56:	46c0      	nop			; (mov r8, r8)
     f58:	40000c00 	.word	0x40000c00
     f5c:	00000a0d 	.word	0x00000a0d
     f60:	40000c04 	.word	0x40000c04
     f64:	00000a4d 	.word	0x00000a4d

00000f68 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
     f68:	b510      	push	{r4, lr}
     f6a:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
     f6c:	4b06      	ldr	r3, [pc, #24]	; (f88 <system_gclk_chan_enable+0x20>)
     f6e:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
     f70:	4b06      	ldr	r3, [pc, #24]	; (f8c <system_gclk_chan_enable+0x24>)
     f72:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
     f74:	4b06      	ldr	r3, [pc, #24]	; (f90 <system_gclk_chan_enable+0x28>)
     f76:	8859      	ldrh	r1, [r3, #2]
     f78:	2280      	movs	r2, #128	; 0x80
     f7a:	01d2      	lsls	r2, r2, #7
     f7c:	430a      	orrs	r2, r1
     f7e:	805a      	strh	r2, [r3, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
     f80:	4b04      	ldr	r3, [pc, #16]	; (f94 <system_gclk_chan_enable+0x2c>)
     f82:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
     f84:	bd10      	pop	{r4, pc}
     f86:	46c0      	nop			; (mov r8, r8)
     f88:	00000a0d 	.word	0x00000a0d
     f8c:	40000c02 	.word	0x40000c02
     f90:	40000c00 	.word	0x40000c00
     f94:	00000a4d 	.word	0x00000a4d

00000f98 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
     f98:	b510      	push	{r4, lr}
     f9a:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
     f9c:	4b0f      	ldr	r3, [pc, #60]	; (fdc <system_gclk_chan_disable+0x44>)
     f9e:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
     fa0:	4b0f      	ldr	r3, [pc, #60]	; (fe0 <system_gclk_chan_disable+0x48>)
     fa2:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
     fa4:	4b0f      	ldr	r3, [pc, #60]	; (fe4 <system_gclk_chan_disable+0x4c>)
     fa6:	8858      	ldrh	r0, [r3, #2]
     fa8:	0500      	lsls	r0, r0, #20
     faa:	0f00      	lsrs	r0, r0, #28
	GCLK->CLKCTRL.bit.GEN = 0;
     fac:	8859      	ldrh	r1, [r3, #2]
     fae:	4a0e      	ldr	r2, [pc, #56]	; (fe8 <system_gclk_chan_disable+0x50>)
     fb0:	400a      	ands	r2, r1
     fb2:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
     fb4:	8859      	ldrh	r1, [r3, #2]
     fb6:	4a0d      	ldr	r2, [pc, #52]	; (fec <system_gclk_chan_disable+0x54>)
     fb8:	400a      	ands	r2, r1
     fba:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
     fbc:	1c19      	adds	r1, r3, #0
     fbe:	2280      	movs	r2, #128	; 0x80
     fc0:	01d2      	lsls	r2, r2, #7
     fc2:	884b      	ldrh	r3, [r1, #2]
     fc4:	4213      	tst	r3, r2
     fc6:	d1fc      	bne.n	fc2 <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
     fc8:	4b06      	ldr	r3, [pc, #24]	; (fe4 <system_gclk_chan_disable+0x4c>)
     fca:	0201      	lsls	r1, r0, #8
     fcc:	8858      	ldrh	r0, [r3, #2]
     fce:	4a06      	ldr	r2, [pc, #24]	; (fe8 <system_gclk_chan_disable+0x50>)
     fd0:	4002      	ands	r2, r0
     fd2:	430a      	orrs	r2, r1
     fd4:	805a      	strh	r2, [r3, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
     fd6:	4b06      	ldr	r3, [pc, #24]	; (ff0 <system_gclk_chan_disable+0x58>)
     fd8:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
     fda:	bd10      	pop	{r4, pc}
     fdc:	00000a0d 	.word	0x00000a0d
     fe0:	40000c02 	.word	0x40000c02
     fe4:	40000c00 	.word	0x40000c00
     fe8:	fffff0ff 	.word	0xfffff0ff
     fec:	ffffbfff 	.word	0xffffbfff
     ff0:	00000a4d 	.word	0x00000a4d

00000ff4 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
     ff4:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
     ff6:	780c      	ldrb	r4, [r1, #0]
     ff8:	0224      	lsls	r4, r4, #8
     ffa:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
     ffc:	4b02      	ldr	r3, [pc, #8]	; (1008 <system_gclk_chan_set_config+0x14>)
     ffe:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    1000:	b2a4      	uxth	r4, r4
    1002:	4b02      	ldr	r3, [pc, #8]	; (100c <system_gclk_chan_set_config+0x18>)
    1004:	805c      	strh	r4, [r3, #2]
}
    1006:	bd10      	pop	{r4, pc}
    1008:	00000f99 	.word	0x00000f99
    100c:	40000c00 	.word	0x40000c00

00001010 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    1010:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    1012:	78d3      	ldrb	r3, [r2, #3]
    1014:	2b00      	cmp	r3, #0
    1016:	d11e      	bne.n	1056 <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    1018:	7813      	ldrb	r3, [r2, #0]
    101a:	2b80      	cmp	r3, #128	; 0x80
    101c:	d004      	beq.n	1028 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    101e:	061b      	lsls	r3, r3, #24
    1020:	2480      	movs	r4, #128	; 0x80
    1022:	0264      	lsls	r4, r4, #9
    1024:	4323      	orrs	r3, r4
    1026:	e000      	b.n	102a <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    1028:	2300      	movs	r3, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    102a:	7854      	ldrb	r4, [r2, #1]
    102c:	2502      	movs	r5, #2
    102e:	43ac      	bics	r4, r5
    1030:	d10a      	bne.n	1048 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    1032:	7894      	ldrb	r4, [r2, #2]
    1034:	2c00      	cmp	r4, #0
    1036:	d103      	bne.n	1040 <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    1038:	2480      	movs	r4, #128	; 0x80
    103a:	02a4      	lsls	r4, r4, #10
    103c:	4323      	orrs	r3, r4
    103e:	e002      	b.n	1046 <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    1040:	24c0      	movs	r4, #192	; 0xc0
    1042:	02e4      	lsls	r4, r4, #11
    1044:	4323      	orrs	r3, r4
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    1046:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    1048:	7854      	ldrb	r4, [r2, #1]
    104a:	3c01      	subs	r4, #1
    104c:	2c01      	cmp	r4, #1
    104e:	d804      	bhi.n	105a <_system_pinmux_config+0x4a>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pullup if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    1050:	4c11      	ldr	r4, [pc, #68]	; (1098 <_system_pinmux_config+0x88>)
    1052:	4023      	ands	r3, r4
    1054:	e001      	b.n	105a <_system_pinmux_config+0x4a>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    1056:	6041      	str	r1, [r0, #4]
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    1058:	2300      	movs	r3, #0
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    105a:	040d      	lsls	r5, r1, #16
    105c:	0c2d      	lsrs	r5, r5, #16
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    105e:	24a0      	movs	r4, #160	; 0xa0
    1060:	05e4      	lsls	r4, r4, #23
    1062:	432c      	orrs	r4, r5
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    1064:	431c      	orrs	r4, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1066:	6284      	str	r4, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    1068:	0c0d      	lsrs	r5, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    106a:	24d0      	movs	r4, #208	; 0xd0
    106c:	0624      	lsls	r4, r4, #24
    106e:	432c      	orrs	r4, r5
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    1070:	431c      	orrs	r4, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1072:	6284      	str	r4, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    1074:	78d4      	ldrb	r4, [r2, #3]
    1076:	2c00      	cmp	r4, #0
    1078:	d10c      	bne.n	1094 <_system_pinmux_config+0x84>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    107a:	035c      	lsls	r4, r3, #13
    107c:	d505      	bpl.n	108a <_system_pinmux_config+0x7a>
			/* Set the OUT register bits to enable the pullup if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    107e:	7893      	ldrb	r3, [r2, #2]
    1080:	2b01      	cmp	r3, #1
    1082:	d101      	bne.n	1088 <_system_pinmux_config+0x78>
				port->OUTSET.reg = pin_mask;
    1084:	6181      	str	r1, [r0, #24]
    1086:	e000      	b.n	108a <_system_pinmux_config+0x7a>
			} else {
				port->OUTCLR.reg = pin_mask;
    1088:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    108a:	7853      	ldrb	r3, [r2, #1]
    108c:	3b01      	subs	r3, #1
    108e:	2b01      	cmp	r3, #1
    1090:	d800      	bhi.n	1094 <_system_pinmux_config+0x84>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    1092:	6081      	str	r1, [r0, #8]
		}
	}
}
    1094:	bd30      	pop	{r4, r5, pc}
    1096:	46c0      	nop			; (mov r8, r8)
    1098:	fffbffff 	.word	0xfffbffff

0000109c <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    109c:	b508      	push	{r3, lr}
    109e:	1c03      	adds	r3, r0, #0
    10a0:	1c0a      	adds	r2, r1, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    10a2:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    10a4:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    10a6:	2900      	cmp	r1, #0
    10a8:	d103      	bne.n	10b2 <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
    10aa:	0958      	lsrs	r0, r3, #5
    10ac:	01c0      	lsls	r0, r0, #7
    10ae:	4904      	ldr	r1, [pc, #16]	; (10c0 <system_pinmux_pin_set_config+0x24>)
    10b0:	1840      	adds	r0, r0, r1
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    10b2:	211f      	movs	r1, #31
    10b4:	400b      	ands	r3, r1
    10b6:	2101      	movs	r1, #1
    10b8:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
    10ba:	4b02      	ldr	r3, [pc, #8]	; (10c4 <system_pinmux_pin_set_config+0x28>)
    10bc:	4798      	blx	r3
}
    10be:	bd08      	pop	{r3, pc}
    10c0:	41004400 	.word	0x41004400
    10c4:	00001011 	.word	0x00001011

000010c8 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    10c8:	4770      	bx	lr
    10ca:	46c0      	nop			; (mov r8, r8)

000010cc <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    10cc:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    10ce:	4b04      	ldr	r3, [pc, #16]	; (10e0 <system_init+0x14>)
    10d0:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    10d2:	4b04      	ldr	r3, [pc, #16]	; (10e4 <system_init+0x18>)
    10d4:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    10d6:	4b04      	ldr	r3, [pc, #16]	; (10e8 <system_init+0x1c>)
    10d8:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    10da:	4b04      	ldr	r3, [pc, #16]	; (10ec <system_init+0x20>)
    10dc:	4798      	blx	r3
}
    10de:	bd08      	pop	{r3, pc}
    10e0:	00000cd9 	.word	0x00000cd9
    10e4:	00000a7d 	.word	0x00000a7d
    10e8:	000010c9 	.word	0x000010c9
    10ec:	000010c9 	.word	0x000010c9

000010f0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    10f0:	e7fe      	b.n	10f0 <Dummy_Handler>
    10f2:	46c0      	nop			; (mov r8, r8)

000010f4 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    10f4:	b570      	push	{r4, r5, r6, lr}
        uint32_t *pSrc, *pDest;

        /* Change default QOS values to have the best performance and correct USB behavior */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    10f6:	2102      	movs	r1, #2
    10f8:	2390      	movs	r3, #144	; 0x90
    10fa:	005b      	lsls	r3, r3, #1
    10fc:	4a28      	ldr	r2, [pc, #160]	; (11a0 <Reset_Handler+0xac>)
    10fe:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    1100:	4b28      	ldr	r3, [pc, #160]	; (11a4 <Reset_Handler+0xb0>)
    1102:	78d8      	ldrb	r0, [r3, #3]
    1104:	2103      	movs	r1, #3
    1106:	4388      	bics	r0, r1
    1108:	2202      	movs	r2, #2
    110a:	4310      	orrs	r0, r2
    110c:	70d8      	strb	r0, [r3, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    110e:	78dd      	ldrb	r5, [r3, #3]
    1110:	240c      	movs	r4, #12
    1112:	43a5      	bics	r5, r4
    1114:	2008      	movs	r0, #8
    1116:	4305      	orrs	r5, r0
    1118:	70dd      	strb	r5, [r3, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    111a:	4b23      	ldr	r3, [pc, #140]	; (11a8 <Reset_Handler+0xb4>)
    111c:	7b9e      	ldrb	r6, [r3, #14]
    111e:	2530      	movs	r5, #48	; 0x30
    1120:	43ae      	bics	r6, r5
    1122:	2520      	movs	r5, #32
    1124:	4335      	orrs	r5, r6
    1126:	739d      	strb	r5, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    1128:	7b9d      	ldrb	r5, [r3, #14]
    112a:	43a5      	bics	r5, r4
    112c:	4328      	orrs	r0, r5
    112e:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    1130:	7b98      	ldrb	r0, [r3, #14]
    1132:	4388      	bics	r0, r1
    1134:	4302      	orrs	r2, r0
    1136:	739a      	strb	r2, [r3, #14]

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    1138:	4b1c      	ldr	r3, [pc, #112]	; (11ac <Reset_Handler+0xb8>)
    113a:	4a1d      	ldr	r2, [pc, #116]	; (11b0 <Reset_Handler+0xbc>)
    113c:	429a      	cmp	r2, r3
    113e:	d003      	beq.n	1148 <Reset_Handler+0x54>
                for (; pDest < &_erelocate;) {
    1140:	4b1c      	ldr	r3, [pc, #112]	; (11b4 <Reset_Handler+0xc0>)
    1142:	4a1a      	ldr	r2, [pc, #104]	; (11ac <Reset_Handler+0xb8>)
    1144:	429a      	cmp	r2, r3
    1146:	d304      	bcc.n	1152 <Reset_Handler+0x5e>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    1148:	4b1b      	ldr	r3, [pc, #108]	; (11b8 <Reset_Handler+0xc4>)
    114a:	4a1c      	ldr	r2, [pc, #112]	; (11bc <Reset_Handler+0xc8>)
    114c:	429a      	cmp	r2, r3
    114e:	d310      	bcc.n	1172 <Reset_Handler+0x7e>
    1150:	e01b      	b.n	118a <Reset_Handler+0x96>
    1152:	4b1b      	ldr	r3, [pc, #108]	; (11c0 <Reset_Handler+0xcc>)
    1154:	4817      	ldr	r0, [pc, #92]	; (11b4 <Reset_Handler+0xc0>)
    1156:	3003      	adds	r0, #3
    1158:	1ac0      	subs	r0, r0, r3
    115a:	0880      	lsrs	r0, r0, #2
    115c:	3001      	adds	r0, #1
    115e:	0080      	lsls	r0, r0, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    1160:	2300      	movs	r3, #0
                        *pDest++ = *pSrc++;
    1162:	4912      	ldr	r1, [pc, #72]	; (11ac <Reset_Handler+0xb8>)
    1164:	4a12      	ldr	r2, [pc, #72]	; (11b0 <Reset_Handler+0xbc>)
    1166:	58d4      	ldr	r4, [r2, r3]
    1168:	50cc      	str	r4, [r1, r3]
    116a:	3304      	adds	r3, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    116c:	4283      	cmp	r3, r0
    116e:	d1fa      	bne.n	1166 <Reset_Handler+0x72>
    1170:	e7ea      	b.n	1148 <Reset_Handler+0x54>
    1172:	4b12      	ldr	r3, [pc, #72]	; (11bc <Reset_Handler+0xc8>)
    1174:	1d1a      	adds	r2, r3, #4
    1176:	4910      	ldr	r1, [pc, #64]	; (11b8 <Reset_Handler+0xc4>)
    1178:	3103      	adds	r1, #3
    117a:	1a89      	subs	r1, r1, r2
    117c:	0889      	lsrs	r1, r1, #2
    117e:	0089      	lsls	r1, r1, #2
    1180:	1852      	adds	r2, r2, r1
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
                *pDest++ = 0;
    1182:	2100      	movs	r1, #0
    1184:	c302      	stmia	r3!, {r1}
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    1186:	4293      	cmp	r3, r2
    1188:	d1fc      	bne.n	1184 <Reset_Handler+0x90>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    118a:	4b0e      	ldr	r3, [pc, #56]	; (11c4 <Reset_Handler+0xd0>)
    118c:	217f      	movs	r1, #127	; 0x7f
    118e:	4a0e      	ldr	r2, [pc, #56]	; (11c8 <Reset_Handler+0xd4>)
    1190:	438a      	bics	r2, r1
    1192:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
        __libc_init_array();
    1194:	4b0d      	ldr	r3, [pc, #52]	; (11cc <Reset_Handler+0xd8>)
    1196:	4798      	blx	r3

        /* Branch to main function */
        main();
    1198:	4b0d      	ldr	r3, [pc, #52]	; (11d0 <Reset_Handler+0xdc>)
    119a:	4798      	blx	r3
    119c:	e7fe      	b.n	119c <Reset_Handler+0xa8>
    119e:	46c0      	nop			; (mov r8, r8)
    11a0:	41007000 	.word	0x41007000
    11a4:	41005000 	.word	0x41005000
    11a8:	41004800 	.word	0x41004800
    11ac:	20000000 	.word	0x20000000
    11b0:	0000142c 	.word	0x0000142c
    11b4:	2000001c 	.word	0x2000001c
    11b8:	20000080 	.word	0x20000080
    11bc:	2000001c 	.word	0x2000001c
    11c0:	20000004 	.word	0x20000004
    11c4:	e000ed00 	.word	0xe000ed00
    11c8:	00000000 	.word	0x00000000
    11cc:	000012d5 	.word	0x000012d5
    11d0:	00001269 	.word	0x00001269

000011d4 <Config_Contrast_PWM>:


/************************************************************************/
/* Sets up Timer to output PWM wave to drive LCD contrast charge pump*/
/************************************************************************/
void Config_Contrast_PWM(void){
    11d4:	b510      	push	{r4, lr}
	
	//Enable TC5 in power manager
	REG_PM_APBCMASK |= (1<<13);		
    11d6:	4b0d      	ldr	r3, [pc, #52]	; (120c <Config_Contrast_PWM+0x38>)
    11d8:	6819      	ldr	r1, [r3, #0]
    11da:	2280      	movs	r2, #128	; 0x80
    11dc:	0192      	lsls	r2, r2, #6
    11de:	430a      	orrs	r2, r1
    11e0:	601a      	str	r2, [r3, #0]
	
	//Assign GCLK0 to Timer //GCLK0 runs at 48 MHz
	GCLKGen_Peripheral(GCLKGEN0 , GCLK_TC4_GCLK_TC5);
    11e2:	2000      	movs	r0, #0
    11e4:	211c      	movs	r1, #28
    11e6:	4b0a      	ldr	r3, [pc, #40]	; (1210 <Config_Contrast_PWM+0x3c>)
    11e8:	4798      	blx	r3
	
	//Reset Timer
	REG_TC5_CTRLA=(1<<0);	
    11ea:	4c0a      	ldr	r4, [pc, #40]	; (1214 <Config_Contrast_PWM+0x40>)
    11ec:	2301      	movs	r3, #1
    11ee:	8023      	strh	r3, [r4, #0]
	//	Start Timer
	REG_TC5_CTRLBSET=(1<<6);
    11f0:	2240      	movs	r2, #64	; 0x40
    11f2:	4b09      	ldr	r3, [pc, #36]	; (1218 <Config_Contrast_PWM+0x44>)
    11f4:	701a      	strb	r2, [r3, #0]
	
	//PWM output pin
	pinMux(PB15,ETCmux);			
    11f6:	202f      	movs	r0, #47	; 0x2f
    11f8:	2104      	movs	r1, #4
    11fa:	4b08      	ldr	r3, [pc, #32]	; (121c <Config_Contrast_PWM+0x48>)
    11fc:	4798      	blx	r3
	
					//presync |prescale|wave mode|TC Mode| Enable
	REG_TC5_CTRLA = (0<<12) | (5<<8) | (2<<5) | (1<<2) | (1<<1);
    11fe:	4b08      	ldr	r3, [pc, #32]	; (1220 <Config_Contrast_PWM+0x4c>)
    1200:	8023      	strh	r3, [r4, #0]
	
	//127 =50%, will need value from EEPROM
	REG_TC5_COUNT8_CC1= 127;	 //This register's not enable protected
    1202:	227f      	movs	r2, #127	; 0x7f
    1204:	4b07      	ldr	r3, [pc, #28]	; (1224 <Config_Contrast_PWM+0x50>)
    1206:	701a      	strb	r2, [r3, #0]
}
    1208:	bd10      	pop	{r4, pc}
    120a:	46c0      	nop			; (mov r8, r8)
    120c:	40000420 	.word	0x40000420
    1210:	00000829 	.word	0x00000829
    1214:	42003400 	.word	0x42003400
    1218:	42003405 	.word	0x42003405
    121c:	0000099d 	.word	0x0000099d
    1220:	00000546 	.word	0x00000546
    1224:	42003419 	.word	0x42003419

00001228 <Config_LCD>:
	REG_TC5_COUNT8_CC1= 26*ContrastValue;
}
/************************************************************************/
/* Initializes LCD, Contrast, and Builds some required symbols          */
/************************************************************************/
void Config_LCD(void){
    1228:	b510      	push	{r4, lr}
	Config_Contrast_PWM();
    122a:	4b08      	ldr	r3, [pc, #32]	; (124c <Config_LCD+0x24>)
    122c:	4798      	blx	r3
	//LCD_Init();
	LCD_Init();
    122e:	4b08      	ldr	r3, [pc, #32]	; (1250 <Config_LCD+0x28>)
    1230:	4798      	blx	r3
	LCD_CursorOff();
    1232:	4b08      	ldr	r3, [pc, #32]	; (1254 <Config_LCD+0x2c>)
    1234:	4798      	blx	r3
	//Build symbol in LCD's CGRAM to be used later on
	LCD_build(0, framelement);	//build '||' symbol at location 0, used to draw frame
    1236:	2000      	movs	r0, #0
    1238:	4907      	ldr	r1, [pc, #28]	; (1258 <Config_LCD+0x30>)
    123a:	4c08      	ldr	r4, [pc, #32]	; (125c <Config_LCD+0x34>)
    123c:	47a0      	blx	r4
	LCD_build(1, polltech);		//build Polltech LOGO at location 1
    123e:	2001      	movs	r0, #1
    1240:	4907      	ldr	r1, [pc, #28]	; (1260 <Config_LCD+0x38>)
    1242:	47a0      	blx	r4
	LCD_build(2,degree);
    1244:	2002      	movs	r0, #2
    1246:	4907      	ldr	r1, [pc, #28]	; (1264 <Config_LCD+0x3c>)
    1248:	47a0      	blx	r4
}
    124a:	bd10      	pop	{r4, pc}
    124c:	000011d5 	.word	0x000011d5
    1250:	000003bd 	.word	0x000003bd
    1254:	00000385 	.word	0x00000385
    1258:	2000000c 	.word	0x2000000c
    125c:	00000359 	.word	0x00000359
    1260:	20000004 	.word	0x20000004
    1264:	20000014 	.word	0x20000014

00001268 <main>:
	WaitFor(EnterKey);
}


int main (void)
{
    1268:	b570      	push	{r4, r5, r6, lr}
    126a:	b082      	sub	sp, #8
	system_init();
    126c:	4b10      	ldr	r3, [pc, #64]	; (12b0 <main+0x48>)
    126e:	4798      	blx	r3
	
	Config_MatrixKeypad();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
    1270:	4b10      	ldr	r3, [pc, #64]	; (12b4 <main+0x4c>)
    1272:	4798      	blx	r3
	#ifndef BypassLCD

	Config_LCD();	
    1274:	4b10      	ldr	r3, [pc, #64]	; (12b8 <main+0x50>)
    1276:	4798      	blx	r3
	
	//Disp_IntroLcdMsgs();	//Display company name, model name 
	//DoAutoZero();
	LCD_Clrscr();
    1278:	4e10      	ldr	r6, [pc, #64]	; (12bc <main+0x54>)
    127a:	47b0      	blx	r6
	#endif
	LCD_Setcursor(3,20);
    127c:	2003      	movs	r0, #3
    127e:	2114      	movs	r1, #20
    1280:	4c0f      	ldr	r4, [pc, #60]	; (12c0 <main+0x58>)
    1282:	47a0      	blx	r4
	LCD_DataWrite(ARROW);
    1284:	207f      	movs	r0, #127	; 0x7f
    1286:	4b0f      	ldr	r3, [pc, #60]	; (12c4 <main+0x5c>)
    1288:	4798      	blx	r3
	
	LCD_Setcursor(1,1);
    128a:	2001      	movs	r0, #1
    128c:	2101      	movs	r1, #1
    128e:	47a0      	blx	r4

	
	//LCD_CursorOn();
	
volatile uint8_t selected=LCD_MenuHandle(MenuSize(CalibrationMenu),CalibrationMenu);
    1290:	200a      	movs	r0, #10
    1292:	490d      	ldr	r1, [pc, #52]	; (12c8 <main+0x60>)
    1294:	4b0d      	ldr	r3, [pc, #52]	; (12cc <main+0x64>)
    1296:	4798      	blx	r3
    1298:	466d      	mov	r5, sp
    129a:	71e8      	strb	r0, [r5, #7]
//	LCD_FullDisp(MSG[0],MSG[1],MSG[2],MSG[3]);
//	LCD_FullDisp(CalibrationMenu[0],CalibrationMenu[1],CalibrationMenu[2],CalibrationMenu[3]);
//	LCD_MenuDisplay(CalibrationMenu, 4);

	LCD_Clrscr();
    129c:	47b0      	blx	r6
	LCD_Setcursor(1,2);
    129e:	2001      	movs	r0, #1
    12a0:	2102      	movs	r1, #2
    12a2:	47a0      	blx	r4
	LCD_DispAscii(selected);
    12a4:	79e8      	ldrb	r0, [r5, #7]
    12a6:	b2c0      	uxtb	r0, r0
    12a8:	4b09      	ldr	r3, [pc, #36]	; (12d0 <main+0x68>)
    12aa:	4798      	blx	r3
    12ac:	e7fe      	b.n	12ac <main+0x44>
    12ae:	46c0      	nop			; (mov r8, r8)
    12b0:	000010cd 	.word	0x000010cd
    12b4:	00000699 	.word	0x00000699
    12b8:	00001229 	.word	0x00001229
    12bc:	00000395 	.word	0x00000395
    12c0:	00000315 	.word	0x00000315
    12c4:	00000285 	.word	0x00000285
    12c8:	00001344 	.word	0x00001344
    12cc:	00000571 	.word	0x00000571
    12d0:	000002d5 	.word	0x000002d5

000012d4 <__libc_init_array>:
    12d4:	b570      	push	{r4, r5, r6, lr}
    12d6:	4b0e      	ldr	r3, [pc, #56]	; (1310 <__libc_init_array+0x3c>)
    12d8:	4d0e      	ldr	r5, [pc, #56]	; (1314 <__libc_init_array+0x40>)
    12da:	2400      	movs	r4, #0
    12dc:	1aed      	subs	r5, r5, r3
    12de:	10ad      	asrs	r5, r5, #2
    12e0:	1c1e      	adds	r6, r3, #0
    12e2:	42ac      	cmp	r4, r5
    12e4:	d004      	beq.n	12f0 <__libc_init_array+0x1c>
    12e6:	00a3      	lsls	r3, r4, #2
    12e8:	58f3      	ldr	r3, [r6, r3]
    12ea:	4798      	blx	r3
    12ec:	3401      	adds	r4, #1
    12ee:	e7f8      	b.n	12e2 <__libc_init_array+0xe>
    12f0:	f000 f88c 	bl	140c <_init>
    12f4:	4b08      	ldr	r3, [pc, #32]	; (1318 <__libc_init_array+0x44>)
    12f6:	4d09      	ldr	r5, [pc, #36]	; (131c <__libc_init_array+0x48>)
    12f8:	2400      	movs	r4, #0
    12fa:	1aed      	subs	r5, r5, r3
    12fc:	10ad      	asrs	r5, r5, #2
    12fe:	1c1e      	adds	r6, r3, #0
    1300:	42ac      	cmp	r4, r5
    1302:	d004      	beq.n	130e <__libc_init_array+0x3a>
    1304:	00a3      	lsls	r3, r4, #2
    1306:	58f3      	ldr	r3, [r6, r3]
    1308:	4798      	blx	r3
    130a:	3401      	adds	r4, #1
    130c:	e7f8      	b.n	1300 <__libc_init_array+0x2c>
    130e:	bd70      	pop	{r4, r5, r6, pc}
    1310:	00001418 	.word	0x00001418
    1314:	00001418 	.word	0x00001418
    1318:	00001418 	.word	0x00001418
    131c:	0000141c 	.word	0x0000141c
    1320:	00000c64 	.word	0x00000c64
    1324:	00000cc4 	.word	0x00000cc4
    1328:	00000cc4 	.word	0x00000cc4
    132c:	00000c44 	.word	0x00000c44
    1330:	00000c56 	.word	0x00000c56
    1334:	00000c72 	.word	0x00000c72
    1338:	00000c48 	.word	0x00000c48
    133c:	00000c80 	.word	0x00000c80
    1340:	00000cb4 	.word	0x00000cb4

00001344 <CalibrationMenu>:
    1344:	62412e31 756c6f73 50206574 73736572     1.Absolute Press
    1354:	00657275 61502e32 2e697472 69724f20     ure.2.Parti. Ori
    1364:	50442e66 00202020 61472e33 756f6573     f.DP   .3.Gaseou
    1374:	724f2073 442e6669 00202050 69502e34     s Orif.DP  .4.Pi
    1384:	20746f74 20205044 20202020 00202020     tot DP         .
    1394:	74532e35 2d6b6361 20432f54 20202020     5.Stack-T/C     
    13a4:	00202020 6d412e36 6e656962 65542074        .6.Ambient Te
    13b4:	202e706d 00202020 654d2e37 20726574     mp.    .7.Meter 
    13c4:	706d6554 2020202e 00202020 75412e38     Temp.      .8.Au
    13d4:	6c6c6978 20797261 706d6554 0020202e     xillary Temp.  .
    13e4:	61502e39 63697472 74616c75 6c462065     9.Particulate Fl
    13f4:	0020776f 472e3031 6f657361 46207375     ow .10.Gaseous F
    1404:	20776f6c 00202020                       low    .

0000140c <_init>:
    140c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    140e:	46c0      	nop			; (mov r8, r8)
    1410:	bcf8      	pop	{r3, r4, r5, r6, r7}
    1412:	bc08      	pop	{r3}
    1414:	469e      	mov	lr, r3
    1416:	4770      	bx	lr

00001418 <__init_array_start>:
    1418:	000000d9 	.word	0x000000d9

0000141c <_fini>:
    141c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    141e:	46c0      	nop			; (mov r8, r8)
    1420:	bcf8      	pop	{r3, r4, r5, r6, r7}
    1422:	bc08      	pop	{r3}
    1424:	469e      	mov	lr, r3
    1426:	4770      	bx	lr

00001428 <__fini_array_start>:
    1428:	000000b1 	.word	0x000000b1
