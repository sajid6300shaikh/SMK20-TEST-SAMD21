
SMK20 TEST SAMD21.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001674  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000001c  20000000  00001674  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000130  2000001c  00001690  0001001c  2**2
                  ALLOC
  3 .stack        00002004  2000014c  000017c0  0001001c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0001001c  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010044  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000f316  00000000  00000000  0001009f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001f82  00000000  00000000  0001f3b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00002e4b  00000000  00000000  00021337  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000004c0  00000000  00000000  00024182  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000003c8  00000000  00000000  00024642  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000198f6  00000000  00000000  00024a0a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000a184  00000000  00000000  0003e300  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000896da  00000000  00000000  00048484  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000b9c  00000000  00000000  000d1b60  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
}

/************************************************************************/
/* After Zero and Span Values are read from EEPROM Slope value of all sensors will be calculated once*/
/************************************************************************/
void ComputeEquation_ofall_Sensors(void){
       0:	20002150 	.word	0x20002150
       4:	00001349 	.word	0x00001349
	//AZ sensors requiring Slope from 1 point equation
	Orifice_DP.Slope	=ComputeSlopefrom1point(&Orifice_DP);
       8:	00001345 	.word	0x00001345
       c:	00001345 	.word	0x00001345
	...
	Orifice_Gas_DP.Slope=ComputeSlopefrom1point(&Orifice_Gas_DP);
	Pitot_DP.Slope		=ComputeSlopefrom1point(&Pitot_DP);
	
	//nAZ sensors requiring slope form 2 point equation
	Absolute_Pres.Slope	=ComputeSlopefrom2Point(&Absolute_Pres);
      2c:	00001345 	.word	0x00001345
	...
	Stack_TC.Slope		=ComputeSlopefrom2Point(&Stack_TC);
      38:	00001345 	.word	0x00001345
	Orifice_PT100.Slope	=ComputeSlopefrom2Point(&Orifice_PT100);
      3c:	00001345 	.word	0x00001345
      40:	00001345 	.word	0x00001345
	Ambient_PT100.Slope	=ComputeSlopefrom2Point(&Ambient_PT100);
      44:	00001345 	.word	0x00001345
      48:	00001345 	.word	0x00001345
	Aux_PT100.Slope		=ComputeSlopefrom2Point(&Aux_PT100);
      4c:	00001345 	.word	0x00001345
      50:	00001345 	.word	0x00001345
	
	//nAZ Sensors requiring Intercept form Slope-point equation
	Absolute_Pres.Intercept	=ComputeIntercept(&Absolute_Pres);
      54:	00001345 	.word	0x00001345
      58:	00001345 	.word	0x00001345
      5c:	00001345 	.word	0x00001345
	Stack_TC.Intercept		=ComputeIntercept(&Stack_TC);
      60:	00001345 	.word	0x00001345
      64:	0000050d 	.word	0x0000050d
	Orifice_PT100.Intercept	=ComputeIntercept(&Orifice_PT100);
      68:	0000051d 	.word	0x0000051d
	Ambient_PT100.Intercept	=ComputeIntercept(&Ambient_PT100);
      6c:	0000052d 	.word	0x0000052d
      70:	0000053d 	.word	0x0000053d
	Aux_PT100.Intercept		=ComputeIntercept(&Aux_PT100);
      74:	0000054d 	.word	0x0000054d
}
      78:	0000055d 	.word	0x0000055d
      7c:	00001345 	.word	0x00001345
      80:	00001345 	.word	0x00001345
      84:	00001345 	.word	0x00001345
      88:	00001345 	.word	0x00001345
      8c:	00001345 	.word	0x00001345
      90:	00001345 	.word	0x00001345
      94:	00001345 	.word	0x00001345
      98:	00001345 	.word	0x00001345
      9c:	00001345 	.word	0x00001345
      a0:	00001345 	.word	0x00001345
      a4:	00001345 	.word	0x00001345
      a8:	00001345 	.word	0x00001345
      ac:	00001345 	.word	0x00001345

000000b0 <__do_global_dtors_aux>:
      b0:	b510      	push	{r4, lr}
      b2:	4c06      	ldr	r4, [pc, #24]	; (cc <__do_global_dtors_aux+0x1c>)
      b4:	7823      	ldrb	r3, [r4, #0]
      b6:	2b00      	cmp	r3, #0
      b8:	d107      	bne.n	ca <__do_global_dtors_aux+0x1a>
      ba:	4b05      	ldr	r3, [pc, #20]	; (d0 <__do_global_dtors_aux+0x20>)
      bc:	2b00      	cmp	r3, #0
      be:	d002      	beq.n	c6 <__do_global_dtors_aux+0x16>
      c0:	4804      	ldr	r0, [pc, #16]	; (d4 <__do_global_dtors_aux+0x24>)
      c2:	e000      	b.n	c6 <__do_global_dtors_aux+0x16>
      c4:	bf00      	nop
      c6:	2301      	movs	r3, #1
      c8:	7023      	strb	r3, [r4, #0]
      ca:	bd10      	pop	{r4, pc}
      cc:	2000001c 	.word	0x2000001c
      d0:	00000000 	.word	0x00000000
      d4:	00001674 	.word	0x00001674

000000d8 <frame_dummy>:
      d8:	b508      	push	{r3, lr}
      da:	4b08      	ldr	r3, [pc, #32]	; (fc <frame_dummy+0x24>)
      dc:	2b00      	cmp	r3, #0
      de:	d003      	beq.n	e8 <frame_dummy+0x10>
      e0:	4807      	ldr	r0, [pc, #28]	; (100 <frame_dummy+0x28>)
      e2:	4908      	ldr	r1, [pc, #32]	; (104 <frame_dummy+0x2c>)
      e4:	e000      	b.n	e8 <frame_dummy+0x10>
      e6:	bf00      	nop
      e8:	4807      	ldr	r0, [pc, #28]	; (108 <frame_dummy+0x30>)
      ea:	6803      	ldr	r3, [r0, #0]
      ec:	2b00      	cmp	r3, #0
      ee:	d003      	beq.n	f8 <frame_dummy+0x20>
      f0:	4b06      	ldr	r3, [pc, #24]	; (10c <frame_dummy+0x34>)
      f2:	2b00      	cmp	r3, #0
      f4:	d000      	beq.n	f8 <frame_dummy+0x20>
      f6:	4798      	blx	r3
      f8:	bd08      	pop	{r3, pc}
      fa:	46c0      	nop			; (mov r8, r8)
      fc:	00000000 	.word	0x00000000
     100:	00001674 	.word	0x00001674
     104:	20000020 	.word	0x20000020
     108:	00001674 	.word	0x00001674
     10c:	00000000 	.word	0x00000000

00000110 <CheckDigitBound>:
/************************************************************************/
/* When a Digit is incremented or decremented by User, it should not go above 9 or below 0
This function takes care of proper Rolling off.*/
/************************************************************************/
int8_t CheckDigitBound(int8_t Num){
	if (Num<0)
     110:	2800      	cmp	r0, #0
     112:	db07      	blt.n	124 <CheckDigitBound+0x14>
	Num=9;			//roll to 10
	if (Num>9)
	Num=0;			//roll to 0
     114:	2309      	movs	r3, #9
     116:	0fc1      	lsrs	r1, r0, #31
     118:	17da      	asrs	r2, r3, #31
     11a:	4283      	cmp	r3, r0
     11c:	4151      	adcs	r1, r2
     11e:	424b      	negs	r3, r1
     120:	4018      	ands	r0, r3
     122:	e000      	b.n	126 <CheckDigitBound+0x16>
/* When a Digit is incremented or decremented by User, it should not go above 9 or below 0
This function takes care of proper Rolling off.*/
/************************************************************************/
int8_t CheckDigitBound(int8_t Num){
	if (Num<0)
	Num=9;			//roll to 10
     124:	2009      	movs	r0, #9
	if (Num>9)
	Num=0;			//roll to 0
	
	return Num;
}
     126:	4770      	bx	lr

00000128 <SplitNumbertoDigits>:
Usage:
int8_t BCDarray;	//Initialize and array to Store the BCD digits
SplitNumbertoDigits(Variable, BCDarray, 5);*/
/************************************************************************/
void SplitNumbertoDigits(uint32_t Num, int8_t DigitArray[], int8_t NoofDigits)
{
     128:	b5f0      	push	{r4, r5, r6, r7, lr}
     12a:	4647      	mov	r7, r8
     12c:	b480      	push	{r7}
     12e:	1c04      	adds	r4, r0, #0
     130:	1c0e      	adds	r6, r1, #0
     132:	1e15      	subs	r5, r2, #0
	/*separates no as
	Eg: for 32768. BCD5=3, BCD4=2...*/
	//Converts 16-bit binary no. to BCD to be displayed on screen.	
	if (NoofDigits>0)
     134:	dd03      	ble.n	13e <SplitNumbertoDigits+0x16>
	DigitArray[0] = Num      - (Num/10)*10;
     136:	210a      	movs	r1, #10
     138:	4b33      	ldr	r3, [pc, #204]	; (208 <SplitNumbertoDigits+0xe0>)
     13a:	4798      	blx	r3
     13c:	7031      	strb	r1, [r6, #0]
	
	if (NoofDigits>1)
     13e:	2d01      	cmp	r5, #1
     140:	dd0d      	ble.n	15e <SplitNumbertoDigits+0x36>
	DigitArray[1] = Num/10   - (Num/100)*10;
     142:	4f32      	ldr	r7, [pc, #200]	; (20c <SplitNumbertoDigits+0xe4>)
     144:	1c20      	adds	r0, r4, #0
     146:	210a      	movs	r1, #10
     148:	47b8      	blx	r7
     14a:	4680      	mov	r8, r0
     14c:	1c20      	adds	r0, r4, #0
     14e:	2164      	movs	r1, #100	; 0x64
     150:	47b8      	blx	r7
     152:	0082      	lsls	r2, r0, #2
     154:	1883      	adds	r3, r0, r2
     156:	005b      	lsls	r3, r3, #1
     158:	4642      	mov	r2, r8
     15a:	1ad3      	subs	r3, r2, r3
     15c:	7073      	strb	r3, [r6, #1]
	
	if (NoofDigits>2)
     15e:	2d02      	cmp	r5, #2
     160:	dd0e      	ble.n	180 <SplitNumbertoDigits+0x58>
	DigitArray[2] = Num/100  - (Num/1000)*10;
     162:	4f2a      	ldr	r7, [pc, #168]	; (20c <SplitNumbertoDigits+0xe4>)
     164:	1c20      	adds	r0, r4, #0
     166:	2164      	movs	r1, #100	; 0x64
     168:	47b8      	blx	r7
     16a:	4680      	mov	r8, r0
     16c:	1c20      	adds	r0, r4, #0
     16e:	21fa      	movs	r1, #250	; 0xfa
     170:	0089      	lsls	r1, r1, #2
     172:	47b8      	blx	r7
     174:	0082      	lsls	r2, r0, #2
     176:	1883      	adds	r3, r0, r2
     178:	005b      	lsls	r3, r3, #1
     17a:	4642      	mov	r2, r8
     17c:	1ad3      	subs	r3, r2, r3
     17e:	70b3      	strb	r3, [r6, #2]
	
	if (NoofDigits>3)
     180:	2d03      	cmp	r5, #3
     182:	dd0e      	ble.n	1a2 <SplitNumbertoDigits+0x7a>
	DigitArray[3] = Num/1000 - (Num/10000)*10;
     184:	4f21      	ldr	r7, [pc, #132]	; (20c <SplitNumbertoDigits+0xe4>)
     186:	1c20      	adds	r0, r4, #0
     188:	21fa      	movs	r1, #250	; 0xfa
     18a:	0089      	lsls	r1, r1, #2
     18c:	47b8      	blx	r7
     18e:	4680      	mov	r8, r0
     190:	1c20      	adds	r0, r4, #0
     192:	491f      	ldr	r1, [pc, #124]	; (210 <SplitNumbertoDigits+0xe8>)
     194:	47b8      	blx	r7
     196:	0082      	lsls	r2, r0, #2
     198:	1883      	adds	r3, r0, r2
     19a:	005b      	lsls	r3, r3, #1
     19c:	4642      	mov	r2, r8
     19e:	1ad3      	subs	r3, r2, r3
     1a0:	70f3      	strb	r3, [r6, #3]

	if (NoofDigits>4)
     1a2:	2d04      	cmp	r5, #4
     1a4:	dd0d      	ble.n	1c2 <SplitNumbertoDigits+0x9a>
	DigitArray[4] = Num/10000- (Num/100000)*10;					//most significant digit
     1a6:	4f19      	ldr	r7, [pc, #100]	; (20c <SplitNumbertoDigits+0xe4>)
     1a8:	1c20      	adds	r0, r4, #0
     1aa:	4919      	ldr	r1, [pc, #100]	; (210 <SplitNumbertoDigits+0xe8>)
     1ac:	47b8      	blx	r7
     1ae:	4680      	mov	r8, r0
     1b0:	1c20      	adds	r0, r4, #0
     1b2:	4918      	ldr	r1, [pc, #96]	; (214 <SplitNumbertoDigits+0xec>)
     1b4:	47b8      	blx	r7
     1b6:	0082      	lsls	r2, r0, #2
     1b8:	1883      	adds	r3, r0, r2
     1ba:	005b      	lsls	r3, r3, #1
     1bc:	4642      	mov	r2, r8
     1be:	1ad3      	subs	r3, r2, r3
     1c0:	7133      	strb	r3, [r6, #4]
	
	if (NoofDigits>5)
     1c2:	2d05      	cmp	r5, #5
     1c4:	dd0d      	ble.n	1e2 <SplitNumbertoDigits+0xba>
	DigitArray[5] = Num/100000 -(Num/1000000)*10;
     1c6:	4f11      	ldr	r7, [pc, #68]	; (20c <SplitNumbertoDigits+0xe4>)
     1c8:	1c20      	adds	r0, r4, #0
     1ca:	4912      	ldr	r1, [pc, #72]	; (214 <SplitNumbertoDigits+0xec>)
     1cc:	47b8      	blx	r7
     1ce:	4680      	mov	r8, r0
     1d0:	1c20      	adds	r0, r4, #0
     1d2:	4911      	ldr	r1, [pc, #68]	; (218 <SplitNumbertoDigits+0xf0>)
     1d4:	47b8      	blx	r7
     1d6:	0082      	lsls	r2, r0, #2
     1d8:	1883      	adds	r3, r0, r2
     1da:	005b      	lsls	r3, r3, #1
     1dc:	4642      	mov	r2, r8
     1de:	1ad3      	subs	r3, r2, r3
     1e0:	7173      	strb	r3, [r6, #5]
	
	if (NoofDigits>6)
     1e2:	2d06      	cmp	r5, #6
     1e4:	dd0c      	ble.n	200 <SplitNumbertoDigits+0xd8>
	DigitArray[6]=	Num/1000000-(Num/10000000)*10;
     1e6:	4d09      	ldr	r5, [pc, #36]	; (20c <SplitNumbertoDigits+0xe4>)
     1e8:	1c20      	adds	r0, r4, #0
     1ea:	490b      	ldr	r1, [pc, #44]	; (218 <SplitNumbertoDigits+0xf0>)
     1ec:	47a8      	blx	r5
     1ee:	1c07      	adds	r7, r0, #0
     1f0:	1c20      	adds	r0, r4, #0
     1f2:	490a      	ldr	r1, [pc, #40]	; (21c <SplitNumbertoDigits+0xf4>)
     1f4:	47a8      	blx	r5
     1f6:	0082      	lsls	r2, r0, #2
     1f8:	1883      	adds	r3, r0, r2
     1fa:	005b      	lsls	r3, r3, #1
     1fc:	1aff      	subs	r7, r7, r3
     1fe:	71b7      	strb	r7, [r6, #6]
	
}
     200:	bc04      	pop	{r2}
     202:	4690      	mov	r8, r2
     204:	bdf0      	pop	{r4, r5, r6, r7, pc}
     206:	46c0      	nop			; (mov r8, r8)
     208:	000015cd 	.word	0x000015cd
     20c:	00001545 	.word	0x00001545
     210:	00002710 	.word	0x00002710
     214:	000186a0 	.word	0x000186a0
     218:	000f4240 	.word	0x000f4240
     21c:	00989680 	.word	0x00989680

00000220 <LCD_DispVariable>:

Usage: LCD_DispVariable(12345, 2, 4, 1, 10);
23.45 will be displayed on LCD at 1st Row and 10th Column.
MSd will be neglected since only 4 digit are asked to be displayed */
/*********************************************************************************************************************/
void LCD_DispVariable(uint32_t Number, char DecimalPos, uint8_t NoofDigitsToDisplay, char Row, char Col){
     220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     222:	464f      	mov	r7, r9
     224:	4646      	mov	r6, r8
     226:	b4c0      	push	{r6, r7}
     228:	af00      	add	r7, sp, #0
     22a:	1c0d      	adds	r5, r1, #0
     22c:	1c14      	adds	r4, r2, #0
     22e:	4699      	mov	r9, r3
     230:	2220      	movs	r2, #32
     232:	5dd2      	ldrb	r2, [r2, r7]
     234:	4690      	mov	r8, r2
	int8_t Digit[NoofDigitsToDisplay];	//temporary array to store BCD
     236:	1de3      	adds	r3, r4, #7
     238:	08db      	lsrs	r3, r3, #3
     23a:	00db      	lsls	r3, r3, #3
     23c:	466a      	mov	r2, sp
     23e:	1ad2      	subs	r2, r2, r3
     240:	4695      	mov	sp, r2
     242:	466e      	mov	r6, sp
	SplitNumbertoDigits(Number,  Digit, NoofDigitsToDisplay);
     244:	b262      	sxtb	r2, r4
     246:	4669      	mov	r1, sp
     248:	4b25      	ldr	r3, [pc, #148]	; (2e0 <LCD_DispVariable+0xc0>)
     24a:	4798      	blx	r3
	
	LCD_Setcursor(Row, Col);	
     24c:	4648      	mov	r0, r9
     24e:	4641      	mov	r1, r8
     250:	4b24      	ldr	r3, [pc, #144]	; (2e4 <LCD_DispVariable+0xc4>)
     252:	4798      	blx	r3
	if (NoofDigitsToDisplay>=7)
     254:	2c06      	cmp	r4, #6
     256:	d902      	bls.n	25e <LCD_DispVariable+0x3e>
	LCD_DispAscii(Digit[6]);
     258:	79b0      	ldrb	r0, [r6, #6]
     25a:	4b23      	ldr	r3, [pc, #140]	; (2e8 <LCD_DispVariable+0xc8>)
     25c:	4798      	blx	r3
	if (DecimalPos==6)
     25e:	2d06      	cmp	r5, #6
     260:	d102      	bne.n	268 <LCD_DispVariable+0x48>
	LCD_DataWrite('.');
     262:	202e      	movs	r0, #46	; 0x2e
     264:	4b21      	ldr	r3, [pc, #132]	; (2ec <LCD_DispVariable+0xcc>)
     266:	4798      	blx	r3
	
	
	if (NoofDigitsToDisplay>=6)
     268:	2c05      	cmp	r4, #5
     26a:	d902      	bls.n	272 <LCD_DispVariable+0x52>
	LCD_DispAscii(Digit[5]);
     26c:	7970      	ldrb	r0, [r6, #5]
     26e:	4b1e      	ldr	r3, [pc, #120]	; (2e8 <LCD_DispVariable+0xc8>)
     270:	4798      	blx	r3
	if (DecimalPos==5)
     272:	2d05      	cmp	r5, #5
     274:	d102      	bne.n	27c <LCD_DispVariable+0x5c>
	LCD_DataWrite('.');
     276:	202e      	movs	r0, #46	; 0x2e
     278:	4b1c      	ldr	r3, [pc, #112]	; (2ec <LCD_DispVariable+0xcc>)
     27a:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=5)
     27c:	2c04      	cmp	r4, #4
     27e:	d902      	bls.n	286 <LCD_DispVariable+0x66>
	LCD_DispAscii(Digit[4]);
     280:	7930      	ldrb	r0, [r6, #4]
     282:	4b19      	ldr	r3, [pc, #100]	; (2e8 <LCD_DispVariable+0xc8>)
     284:	4798      	blx	r3
	if (DecimalPos==4)
     286:	2d04      	cmp	r5, #4
     288:	d102      	bne.n	290 <LCD_DispVariable+0x70>
	LCD_DataWrite('.');
     28a:	202e      	movs	r0, #46	; 0x2e
     28c:	4b17      	ldr	r3, [pc, #92]	; (2ec <LCD_DispVariable+0xcc>)
     28e:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=4)
     290:	2c03      	cmp	r4, #3
     292:	d902      	bls.n	29a <LCD_DispVariable+0x7a>
	LCD_DispAscii(Digit[3]);
     294:	78f0      	ldrb	r0, [r6, #3]
     296:	4b14      	ldr	r3, [pc, #80]	; (2e8 <LCD_DispVariable+0xc8>)
     298:	4798      	blx	r3
	if (DecimalPos==3)
     29a:	2d03      	cmp	r5, #3
     29c:	d102      	bne.n	2a4 <LCD_DispVariable+0x84>
	LCD_DataWrite('.');
     29e:	202e      	movs	r0, #46	; 0x2e
     2a0:	4b12      	ldr	r3, [pc, #72]	; (2ec <LCD_DispVariable+0xcc>)
     2a2:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=3)
     2a4:	2c02      	cmp	r4, #2
     2a6:	d902      	bls.n	2ae <LCD_DispVariable+0x8e>
	LCD_DispAscii(Digit[2]);
     2a8:	78b0      	ldrb	r0, [r6, #2]
     2aa:	4b0f      	ldr	r3, [pc, #60]	; (2e8 <LCD_DispVariable+0xc8>)
     2ac:	4798      	blx	r3
	if (DecimalPos==2)
     2ae:	2d02      	cmp	r5, #2
     2b0:	d102      	bne.n	2b8 <LCD_DispVariable+0x98>
	LCD_DataWrite('.');
     2b2:	202e      	movs	r0, #46	; 0x2e
     2b4:	4b0d      	ldr	r3, [pc, #52]	; (2ec <LCD_DispVariable+0xcc>)
     2b6:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=2)
     2b8:	2c01      	cmp	r4, #1
     2ba:	d902      	bls.n	2c2 <LCD_DispVariable+0xa2>
	LCD_DispAscii(Digit[1]);
     2bc:	7870      	ldrb	r0, [r6, #1]
     2be:	4b0a      	ldr	r3, [pc, #40]	; (2e8 <LCD_DispVariable+0xc8>)
     2c0:	4798      	blx	r3
	if (DecimalPos==1)
     2c2:	2d01      	cmp	r5, #1
     2c4:	d102      	bne.n	2cc <LCD_DispVariable+0xac>
	LCD_DataWrite('.');
     2c6:	202e      	movs	r0, #46	; 0x2e
     2c8:	4b08      	ldr	r3, [pc, #32]	; (2ec <LCD_DispVariable+0xcc>)
     2ca:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=1)
     2cc:	2c00      	cmp	r4, #0
     2ce:	d002      	beq.n	2d6 <LCD_DispVariable+0xb6>
	LCD_DispAscii(Digit[0]);
     2d0:	7830      	ldrb	r0, [r6, #0]
     2d2:	4b05      	ldr	r3, [pc, #20]	; (2e8 <LCD_DispVariable+0xc8>)
     2d4:	4798      	blx	r3

}
     2d6:	46bd      	mov	sp, r7
     2d8:	bc0c      	pop	{r2, r3}
     2da:	4690      	mov	r8, r2
     2dc:	4699      	mov	r9, r3
     2de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     2e0:	00000129 	.word	0x00000129
     2e4:	000006f5 	.word	0x000006f5
     2e8:	000006b5 	.word	0x000006b5
     2ec:	00000681 	.word	0x00000681

000002f0 <CombineDigitstoNumber>:
Array Index=  0 1 2 3 4 
Say Digit[5]={2,4,5,6,8}; is the array of 5 element containing 5 BCD digit
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
     2f0:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
	
		
	if (NoofDigits>0)
     2f2:	2900      	cmp	r1, #0
     2f4:	dd02      	ble.n	2fc <CombineDigitstoNumber+0xc>
		BCD1 = Digit[0];
     2f6:	2700      	movs	r7, #0
     2f8:	57c7      	ldrsb	r7, [r0, r7]
     2fa:	e000      	b.n	2fe <CombineDigitstoNumber+0xe>
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     2fc:	2700      	movs	r7, #0
	
		
	if (NoofDigits>0)
		BCD1 = Digit[0];
	
	if (NoofDigits>1)
     2fe:	2901      	cmp	r1, #1
     300:	dd06      	ble.n	310 <CombineDigitstoNumber+0x20>
		BCD2 = Digit[1]*10;
     302:	2301      	movs	r3, #1
     304:	56c3      	ldrsb	r3, [r0, r3]
     306:	009e      	lsls	r6, r3, #2
     308:	18f3      	adds	r3, r6, r3
     30a:	005b      	lsls	r3, r3, #1
     30c:	469c      	mov	ip, r3
     30e:	e001      	b.n	314 <CombineDigitstoNumber+0x24>
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     310:	2300      	movs	r3, #0
     312:	469c      	mov	ip, r3
     314:	2600      	movs	r6, #0
		BCD1 = Digit[0];
	
	if (NoofDigits>1)
		BCD2 = Digit[1]*10;
		
	if (NoofDigits>2)
     316:	2902      	cmp	r1, #2
     318:	dd03      	ble.n	322 <CombineDigitstoNumber+0x32>
		BCD3 = Digit[2]*100;
     31a:	2302      	movs	r3, #2
     31c:	56c3      	ldrsb	r3, [r0, r3]
     31e:	2664      	movs	r6, #100	; 0x64
     320:	435e      	muls	r6, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     322:	2500      	movs	r5, #0
		BCD2 = Digit[1]*10;
		
	if (NoofDigits>2)
		BCD3 = Digit[2]*100;
		
	if (NoofDigits>3)
     324:	2903      	cmp	r1, #3
     326:	dd04      	ble.n	332 <CombineDigitstoNumber+0x42>
		BCD4 = Digit[3]*1000;
     328:	2303      	movs	r3, #3
     32a:	56c3      	ldrsb	r3, [r0, r3]
     32c:	25fa      	movs	r5, #250	; 0xfa
     32e:	00ad      	lsls	r5, r5, #2
     330:	435d      	muls	r5, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     332:	2400      	movs	r4, #0
		BCD3 = Digit[2]*100;
		
	if (NoofDigits>3)
		BCD4 = Digit[3]*1000;

	if (NoofDigits>4)
     334:	2904      	cmp	r1, #4
     336:	dd03      	ble.n	340 <CombineDigitstoNumber+0x50>
		BCD5 = Digit[4]*10000;
     338:	2304      	movs	r3, #4
     33a:	56c3      	ldrsb	r3, [r0, r3]
     33c:	4c0b      	ldr	r4, [pc, #44]	; (36c <CombineDigitstoNumber+0x7c>)
     33e:	435c      	muls	r4, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     340:	2200      	movs	r2, #0
		BCD4 = Digit[3]*1000;

	if (NoofDigits>4)
		BCD5 = Digit[4]*10000;
	
	if (NoofDigits>5)
     342:	2905      	cmp	r1, #5
     344:	dd03      	ble.n	34e <CombineDigitstoNumber+0x5e>
		BCD6 = Digit[5]*100000;
     346:	2305      	movs	r3, #5
     348:	56c3      	ldrsb	r3, [r0, r3]
     34a:	4a09      	ldr	r2, [pc, #36]	; (370 <CombineDigitstoNumber+0x80>)
     34c:	435a      	muls	r2, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     34e:	2300      	movs	r3, #0
		BCD5 = Digit[4]*10000;
	
	if (NoofDigits>5)
		BCD6 = Digit[5]*100000;
		
	if (NoofDigits>6)
     350:	2906      	cmp	r1, #6
     352:	dd03      	ble.n	35c <CombineDigitstoNumber+0x6c>
		BCD7 = Digit[6]*1000000;
     354:	2306      	movs	r3, #6
     356:	56c3      	ldrsb	r3, [r0, r3]
     358:	4906      	ldr	r1, [pc, #24]	; (374 <CombineDigitstoNumber+0x84>)
     35a:	434b      	muls	r3, r1
		

	return (BCD7+BCD6+BCD5+BCD4+BCD3+BCD2+BCD1);
     35c:	4661      	mov	r1, ip
     35e:	19c8      	adds	r0, r1, r7
     360:	1986      	adds	r6, r0, r6
     362:	1975      	adds	r5, r6, r5
     364:	192c      	adds	r4, r5, r4
     366:	18a2      	adds	r2, r4, r2
     368:	18d0      	adds	r0, r2, r3
}
     36a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     36c:	00002710 	.word	0x00002710
     370:	000186a0 	.word	0x000186a0
     374:	000f4240 	.word	0x000f4240

00000378 <GetNumDataFromUser>:
Usage:
uint32_t ans=GetNumDataFromUser(32768,4,5,2,10);      
Current value of variable will be displayed on LCD with given decimal point 
and user can edit the value and press enter to store new value of variable*/
/************************************************************************/
uint32_t GetNumDataFromUser(uint32_t CurrentNum, uint8_t DecimalPos, uint8_t NoofDigit,  char Row, char Col){
     378:	b5f0      	push	{r4, r5, r6, r7, lr}
     37a:	465f      	mov	r7, fp
     37c:	4656      	mov	r6, sl
     37e:	464d      	mov	r5, r9
     380:	4644      	mov	r4, r8
     382:	b4f0      	push	{r4, r5, r6, r7}
     384:	b089      	sub	sp, #36	; 0x24
     386:	af02      	add	r7, sp, #8
     388:	6078      	str	r0, [r7, #4]
     38a:	6139      	str	r1, [r7, #16]
     38c:	4692      	mov	sl, r2
     38e:	469b      	mov	fp, r3
     390:	2140      	movs	r1, #64	; 0x40
     392:	5dc9      	ldrb	r1, [r1, r7]
     394:	6179      	str	r1, [r7, #20]
	int8_t Digit[NoofDigit];
     396:	1c13      	adds	r3, r2, #0
     398:	3307      	adds	r3, #7
     39a:	08db      	lsrs	r3, r3, #3
     39c:	00db      	lsls	r3, r3, #3
     39e:	466a      	mov	r2, sp
     3a0:	1ad2      	subs	r2, r2, r3
     3a2:	4695      	mov	sp, r2
     3a4:	ab02      	add	r3, sp, #8
     3a6:	60bb      	str	r3, [r7, #8]
     3a8:	4698      	mov	r8, r3
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
     3aa:	9100      	str	r1, [sp, #0]
     3ac:	6878      	ldr	r0, [r7, #4]
     3ae:	6939      	ldr	r1, [r7, #16]
     3b0:	4652      	mov	r2, sl
     3b2:	465b      	mov	r3, fp
     3b4:	4c46      	ldr	r4, [pc, #280]	; (4d0 <GetNumDataFromUser+0x158>)
     3b6:	47a0      	blx	r4
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
     3b8:	4652      	mov	r2, sl
     3ba:	b2d2      	uxtb	r2, r2
     3bc:	603a      	str	r2, [r7, #0]
     3be:	b252      	sxtb	r2, r2
     3c0:	6878      	ldr	r0, [r7, #4]
     3c2:	68b9      	ldr	r1, [r7, #8]
     3c4:	4b43      	ldr	r3, [pc, #268]	; (4d4 <GetNumDataFromUser+0x15c>)
     3c6:	4798      	blx	r3
	LCD_CursorOn();
     3c8:	4b43      	ldr	r3, [pc, #268]	; (4d8 <GetNumDataFromUser+0x160>)
     3ca:	4798      	blx	r3
	int8_t i=NoofDigit-1;
     3cc:	4653      	mov	r3, sl
     3ce:	3b01      	subs	r3, #1
     3d0:	b2db      	uxtb	r3, r3
     3d2:	60fb      	str	r3, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
     3d4:	4658      	mov	r0, fp
     3d6:	6979      	ldr	r1, [r7, #20]
     3d8:	4b40      	ldr	r3, [pc, #256]	; (4dc <GetNumDataFromUser+0x164>)
     3da:	4798      	blx	r3
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
	uint8_t NewCol=Col;
     3dc:	697e      	ldr	r6, [r7, #20]
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
     3de:	68fd      	ldr	r5, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
	while(1){
		if (KeyDetected())
     3e0:	4c3f      	ldr	r4, [pc, #252]	; (4e0 <GetNumDataFromUser+0x168>)
     3e2:	47a0      	blx	r4
     3e4:	2800      	cmp	r0, #0
     3e6:	d0fc      	beq.n	3e2 <GetNumDataFromUser+0x6a>
		{
			Keyscan();
     3e8:	4b3e      	ldr	r3, [pc, #248]	; (4e4 <GetNumDataFromUser+0x16c>)
     3ea:	4798      	blx	r3
			if (IncrKey)
     3ec:	493e      	ldr	r1, [pc, #248]	; (4e8 <GetNumDataFromUser+0x170>)
     3ee:	780b      	ldrb	r3, [r1, #0]
     3f0:	2b00      	cmp	r3, #0
     3f2:	d00b      	beq.n	40c <GetNumDataFromUser+0x94>
			{
				Digit[i]++;
     3f4:	b26a      	sxtb	r2, r5
     3f6:	4691      	mov	r9, r2
     3f8:	4643      	mov	r3, r8
     3fa:	444b      	add	r3, r9
     3fc:	7818      	ldrb	r0, [r3, #0]
     3fe:	3001      	adds	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     400:	b240      	sxtb	r0, r0
     402:	4b3a      	ldr	r3, [pc, #232]	; (4ec <GetNumDataFromUser+0x174>)
     404:	4798      	blx	r3
     406:	4641      	mov	r1, r8
     408:	4449      	add	r1, r9
     40a:	7008      	strb	r0, [r1, #0]
			}
			
			if (DecrKey)
     40c:	4b38      	ldr	r3, [pc, #224]	; (4f0 <GetNumDataFromUser+0x178>)
     40e:	781b      	ldrb	r3, [r3, #0]
     410:	2b00      	cmp	r3, #0
     412:	d00b      	beq.n	42c <GetNumDataFromUser+0xb4>
			{
				Digit[i]--;
     414:	b26a      	sxtb	r2, r5
     416:	4691      	mov	r9, r2
     418:	4643      	mov	r3, r8
     41a:	444b      	add	r3, r9
     41c:	7818      	ldrb	r0, [r3, #0]
     41e:	3801      	subs	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     420:	b240      	sxtb	r0, r0
     422:	4b32      	ldr	r3, [pc, #200]	; (4ec <GetNumDataFromUser+0x174>)
     424:	4798      	blx	r3
     426:	4641      	mov	r1, r8
     428:	4449      	add	r1, r9
     42a:	7008      	strb	r0, [r1, #0]
			}
			
			if (NextKey || PrevKey)		//shift cursor to right or left with press of Next or Prev key respectively
     42c:	4b31      	ldr	r3, [pc, #196]	; (4f4 <GetNumDataFromUser+0x17c>)
     42e:	781b      	ldrb	r3, [r3, #0]
     430:	2b00      	cmp	r3, #0
     432:	d103      	bne.n	43c <GetNumDataFromUser+0xc4>
     434:	4b30      	ldr	r3, [pc, #192]	; (4f8 <GetNumDataFromUser+0x180>)
     436:	781b      	ldrb	r3, [r3, #0]
     438:	2b00      	cmp	r3, #0
     43a:	d023      	beq.n	484 <GetNumDataFromUser+0x10c>
			{
				if (NextKey)
     43c:	4b2d      	ldr	r3, [pc, #180]	; (4f4 <GetNumDataFromUser+0x17c>)
     43e:	781b      	ldrb	r3, [r3, #0]
     440:	2b00      	cmp	r3, #0
     442:	d001      	beq.n	448 <GetNumDataFromUser+0xd0>
				i--;
     444:	3d01      	subs	r5, #1
     446:	b2ed      	uxtb	r5, r5
				if (PrevKey)
     448:	4b2b      	ldr	r3, [pc, #172]	; (4f8 <GetNumDataFromUser+0x180>)
     44a:	781b      	ldrb	r3, [r3, #0]
     44c:	2b00      	cmp	r3, #0
     44e:	d001      	beq.n	454 <GetNumDataFromUser+0xdc>
				i++;
     450:	3501      	adds	r5, #1
     452:	b2ed      	uxtb	r5, r5
				
				if (i>(NoofDigit-1))
     454:	b26b      	sxtb	r3, r5
     456:	4652      	mov	r2, sl
     458:	3a01      	subs	r2, #1
     45a:	4293      	cmp	r3, r2
     45c:	dc02      	bgt.n	464 <GetNumDataFromUser+0xec>
				i=0;
				if (i<0)
     45e:	2b00      	cmp	r3, #0
     460:	db02      	blt.n	468 <GetNumDataFromUser+0xf0>
     462:	e002      	b.n	46a <GetNumDataFromUser+0xf2>
				i--;
				if (PrevKey)
				i++;
				
				if (i>(NoofDigit-1))
				i=0;
     464:	2500      	movs	r5, #0
     466:	e000      	b.n	46a <GetNumDataFromUser+0xf2>
				if (i<0)
				i=NoofDigit-1;
     468:	68fd      	ldr	r5, [r7, #12]
				NewCol=Col+NoofDigit-1-i;
     46a:	697a      	ldr	r2, [r7, #20]
     46c:	1c16      	adds	r6, r2, #0
     46e:	4456      	add	r6, sl
     470:	1b76      	subs	r6, r6, r5
     472:	b2f6      	uxtb	r6, r6
     474:	1e73      	subs	r3, r6, #1
     476:	b2db      	uxtb	r3, r3
				if (NewCol>=(Col+NoofDigit-DecimalPos))
     478:	4452      	add	r2, sl
     47a:	6939      	ldr	r1, [r7, #16]
     47c:	1a52      	subs	r2, r2, r1
     47e:	4293      	cmp	r3, r2
     480:	da00      	bge.n	484 <GetNumDataFromUser+0x10c>
				
				if (i>(NoofDigit-1))
				i=0;
				if (i<0)
				i=NoofDigit-1;
				NewCol=Col+NoofDigit-1-i;
     482:	1c1e      	adds	r6, r3, #0
				if (NewCol>=(Col+NoofDigit-DecimalPos))
				NewCol++;
			}
			
			if (EnterKey)
     484:	4b1d      	ldr	r3, [pc, #116]	; (4fc <GetNumDataFromUser+0x184>)
     486:	781b      	ldrb	r3, [r3, #0]
     488:	2b00      	cmp	r3, #0
     48a:	d005      	beq.n	498 <GetNumDataFromUser+0x120>
			return CombineDigitstoNumber(Digit,NoofDigit);
     48c:	683a      	ldr	r2, [r7, #0]
     48e:	b251      	sxtb	r1, r2
     490:	68b8      	ldr	r0, [r7, #8]
     492:	4b1b      	ldr	r3, [pc, #108]	; (500 <GetNumDataFromUser+0x188>)
     494:	4798      	blx	r3
     496:	e012      	b.n	4be <GetNumDataFromUser+0x146>
			
			if (EscKey)
     498:	4b1a      	ldr	r3, [pc, #104]	; (504 <GetNumDataFromUser+0x18c>)
     49a:	781b      	ldrb	r3, [r3, #0]
     49c:	2b00      	cmp	r3, #0
     49e:	d10d      	bne.n	4bc <GetNumDataFromUser+0x144>
			return CurrentNum;
			
			LCD_Setcursor(Row,NewCol);
     4a0:	4658      	mov	r0, fp
     4a2:	1c31      	adds	r1, r6, #0
     4a4:	4b0d      	ldr	r3, [pc, #52]	; (4dc <GetNumDataFromUser+0x164>)
     4a6:	4699      	mov	r9, r3
     4a8:	4798      	blx	r3
			LCD_DispAscii(Digit[i]);
     4aa:	b26b      	sxtb	r3, r5
     4ac:	4641      	mov	r1, r8
     4ae:	5cc8      	ldrb	r0, [r1, r3]
     4b0:	4b15      	ldr	r3, [pc, #84]	; (508 <GetNumDataFromUser+0x190>)
     4b2:	4798      	blx	r3
			LCD_Setcursor(Row,NewCol);
     4b4:	4658      	mov	r0, fp
     4b6:	1c31      	adds	r1, r6, #0
     4b8:	47c8      	blx	r9
     4ba:	e792      	b.n	3e2 <GetNumDataFromUser+0x6a>
			
			if (EnterKey)
			return CombineDigitstoNumber(Digit,NoofDigit);
			
			if (EscKey)
			return CurrentNum;
     4bc:	6878      	ldr	r0, [r7, #4]
			LCD_Setcursor(Row,NewCol);
			LCD_DispAscii(Digit[i]);
			LCD_Setcursor(Row,NewCol);
		}
	}
     4be:	46bd      	mov	sp, r7
     4c0:	b007      	add	sp, #28
     4c2:	bc3c      	pop	{r2, r3, r4, r5}
     4c4:	4690      	mov	r8, r2
     4c6:	4699      	mov	r9, r3
     4c8:	46a2      	mov	sl, r4
     4ca:	46ab      	mov	fp, r5
     4cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
     4ce:	46c0      	nop			; (mov r8, r8)
     4d0:	00000221 	.word	0x00000221
     4d4:	00000129 	.word	0x00000129
     4d8:	00000765 	.word	0x00000765
     4dc:	000006f5 	.word	0x000006f5
     4e0:	00000949 	.word	0x00000949
     4e4:	00000985 	.word	0x00000985
     4e8:	2000007f 	.word	0x2000007f
     4ec:	00000111 	.word	0x00000111
     4f0:	20000080 	.word	0x20000080
     4f4:	20000074 	.word	0x20000074
     4f8:	2000007d 	.word	0x2000007d
     4fc:	2000007e 	.word	0x2000007e
     500:	000002f1 	.word	0x000002f1
     504:	2000007c 	.word	0x2000007c
     508:	000006b5 	.word	0x000006b5

0000050c <SERCOM0_Handler>:
	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
}

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
     50c:	b508      	push	{r3, lr}
     50e:	4b02      	ldr	r3, [pc, #8]	; (518 <SERCOM0_Handler+0xc>)
     510:	681b      	ldr	r3, [r3, #0]
     512:	2000      	movs	r0, #0
     514:	4798      	blx	r3
     516:	bd08      	pop	{r3, pc}
     518:	20000038 	.word	0x20000038

0000051c <SERCOM1_Handler>:
     51c:	b508      	push	{r3, lr}
     51e:	4b02      	ldr	r3, [pc, #8]	; (528 <SERCOM1_Handler+0xc>)
     520:	685b      	ldr	r3, [r3, #4]
     522:	2001      	movs	r0, #1
     524:	4798      	blx	r3
     526:	bd08      	pop	{r3, pc}
     528:	20000038 	.word	0x20000038

0000052c <SERCOM2_Handler>:
     52c:	b508      	push	{r3, lr}
     52e:	4b02      	ldr	r3, [pc, #8]	; (538 <SERCOM2_Handler+0xc>)
     530:	689b      	ldr	r3, [r3, #8]
     532:	2002      	movs	r0, #2
     534:	4798      	blx	r3
     536:	bd08      	pop	{r3, pc}
     538:	20000038 	.word	0x20000038

0000053c <SERCOM3_Handler>:
     53c:	b508      	push	{r3, lr}
     53e:	4b02      	ldr	r3, [pc, #8]	; (548 <SERCOM3_Handler+0xc>)
     540:	68db      	ldr	r3, [r3, #12]
     542:	2003      	movs	r0, #3
     544:	4798      	blx	r3
     546:	bd08      	pop	{r3, pc}
     548:	20000038 	.word	0x20000038

0000054c <SERCOM4_Handler>:
     54c:	b508      	push	{r3, lr}
     54e:	4b02      	ldr	r3, [pc, #8]	; (558 <SERCOM4_Handler+0xc>)
     550:	691b      	ldr	r3, [r3, #16]
     552:	2004      	movs	r0, #4
     554:	4798      	blx	r3
     556:	bd08      	pop	{r3, pc}
     558:	20000038 	.word	0x20000038

0000055c <SERCOM5_Handler>:
     55c:	b508      	push	{r3, lr}
     55e:	4b02      	ldr	r3, [pc, #8]	; (568 <SERCOM5_Handler+0xc>)
     560:	695b      	ldr	r3, [r3, #20]
     562:	2005      	movs	r0, #5
     564:	4798      	blx	r3
     566:	bd08      	pop	{r3, pc}
     568:	20000038 	.word	0x20000038

0000056c <PulseLCD_EN>:
	LCD_CmdWrite(0x80);
	checkbusy();  // Move the Cursor to First line First Position
	LCD_PowerOn();
}

void PulseLCD_EN(void){
     56c:	b510      	push	{r4, lr}
	PinSet(LCD_EN);
     56e:	2480      	movs	r4, #128	; 0x80
     570:	0364      	lsls	r4, r4, #13
     572:	4b04      	ldr	r3, [pc, #16]	; (584 <PulseLCD_EN+0x18>)
     574:	601c      	str	r4, [r3, #0]
	delay_us(ENPulse);
     576:	2002      	movs	r0, #2
     578:	4b03      	ldr	r3, [pc, #12]	; (588 <PulseLCD_EN+0x1c>)
     57a:	4798      	blx	r3
	PinClr(LCD_EN);
     57c:	4b03      	ldr	r3, [pc, #12]	; (58c <PulseLCD_EN+0x20>)
     57e:	601c      	str	r4, [r3, #0]
}
     580:	bd10      	pop	{r4, pc}
     582:	46c0      	nop			; (mov r8, r8)
     584:	41004418 	.word	0x41004418
     588:	00000891 	.word	0x00000891
     58c:	41004414 	.word	0x41004414

00000590 <write4bits>:
			break;
	}
}

void write4bits(uint8_t value)
{
     590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     592:	464f      	mov	r7, r9
     594:	4646      	mov	r6, r8
     596:	b4c0      	push	{r6, r7}
     598:	4681      	mov	r9, r0
	for (int i = 0; i < 4; i++)
     59a:	2400      	movs	r4, #0
	{
		pinMode(_data_pins[i], OUTPUT);
     59c:	4b0d      	ldr	r3, [pc, #52]	; (5d4 <write4bits+0x44>)
     59e:	4698      	mov	r8, r3
     5a0:	4f0d      	ldr	r7, [pc, #52]	; (5d8 <write4bits+0x48>)
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
     5a2:	4e0e      	ldr	r6, [pc, #56]	; (5dc <write4bits+0x4c>)

void write4bits(uint8_t value)
{
	for (int i = 0; i < 4; i++)
	{
		pinMode(_data_pins[i], OUTPUT);
     5a4:	4643      	mov	r3, r8
     5a6:	18e5      	adds	r5, r4, r3
     5a8:	7828      	ldrb	r0, [r5, #0]
     5aa:	2100      	movs	r1, #0
     5ac:	47b8      	blx	r7
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
     5ae:	7828      	ldrb	r0, [r5, #0]
     5b0:	464b      	mov	r3, r9
     5b2:	4123      	asrs	r3, r4
     5b4:	2101      	movs	r1, #1
     5b6:	4019      	ands	r1, r3
     5b8:	47b0      	blx	r6
	}
}

void write4bits(uint8_t value)
{
	for (int i = 0; i < 4; i++)
     5ba:	3401      	adds	r4, #1
     5bc:	2c04      	cmp	r4, #4
     5be:	d1f1      	bne.n	5a4 <write4bits+0x14>
	{
		pinMode(_data_pins[i], OUTPUT);
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
	}
	delay_us(2);
     5c0:	2002      	movs	r0, #2
     5c2:	4b07      	ldr	r3, [pc, #28]	; (5e0 <write4bits+0x50>)
     5c4:	4798      	blx	r3
	PulseLCD_EN();
     5c6:	4b07      	ldr	r3, [pc, #28]	; (5e4 <write4bits+0x54>)
     5c8:	4798      	blx	r3
}
     5ca:	bc0c      	pop	{r2, r3}
     5cc:	4690      	mov	r8, r2
     5ce:	4699      	mov	r9, r3
     5d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     5d2:	46c0      	nop			; (mov r8, r8)
     5d4:	20000078 	.word	0x20000078
     5d8:	00000a95 	.word	0x00000a95
     5dc:	00000b99 	.word	0x00000b99
     5e0:	00000891 	.word	0x00000891
     5e4:	0000056d 	.word	0x0000056d

000005e8 <checkbusy>:
	
}


void checkbusy()		//waits until LCD is busy
{
     5e8:	b5f0      	push	{r4, r5, r6, r7, lr}
     5ea:	464f      	mov	r7, r9
     5ec:	4646      	mov	r6, r8
     5ee:	b4c0      	push	{r6, r7}
     5f0:	b083      	sub	sp, #12
#ifndef BypassLCD
//delay_ms(2);
	volatile bool p27=1;			// temporary boolean bit var.
     5f2:	466c      	mov	r4, sp
     5f4:	2301      	movs	r3, #1
     5f6:	71e3      	strb	r3, [r4, #7]

//	WritePin(LCD_D7,1);
	pinMode(LCD_D7, INPUT);		//configure lcd_d7 as input
     5f8:	2013      	movs	r0, #19
     5fa:	2102      	movs	r1, #2
     5fc:	4b1b      	ldr	r3, [pc, #108]	; (66c <checkbusy+0x84>)
     5fe:	4798      	blx	r3
	PinClr(LCD_RS);
     600:	2280      	movs	r2, #128	; 0x80
     602:	00d2      	lsls	r2, r2, #3
     604:	4b1a      	ldr	r3, [pc, #104]	; (670 <checkbusy+0x88>)
     606:	601a      	str	r2, [r3, #0]
	PinSet(LCD_RWb);	//RWb=1 indicates read operation.
     608:	2280      	movs	r2, #128	; 0x80
     60a:	0392      	lsls	r2, r2, #14
     60c:	4b19      	ldr	r3, [pc, #100]	; (674 <checkbusy+0x8c>)
     60e:	601a      	str	r2, [r3, #0]
	
	while(p27) 
     610:	79e3      	ldrb	r3, [r4, #7]
     612:	2b00      	cmp	r3, #0
     614:	d01a      	beq.n	64c <checkbusy+0x64>
	{
	PinClr(LCD_EN);
     616:	4a16      	ldr	r2, [pc, #88]	; (670 <checkbusy+0x88>)
     618:	4690      	mov	r8, r2
     61a:	2480      	movs	r4, #128	; 0x80
     61c:	0364      	lsls	r4, r4, #13
     61e:	46a1      	mov	r9, r4
     620:	464b      	mov	r3, r9
     622:	4642      	mov	r2, r8
     624:	6013      	str	r3, [r2, #0]
	delay_us(ENPulse);
     626:	2002      	movs	r0, #2
     628:	4f13      	ldr	r7, [pc, #76]	; (678 <checkbusy+0x90>)
     62a:	47b8      	blx	r7
	PinSet(LCD_EN);
     62c:	4e11      	ldr	r6, [pc, #68]	; (674 <checkbusy+0x8c>)
     62e:	6034      	str	r4, [r6, #0]

		p27=PinRead(LCD_D7);
     630:	4b12      	ldr	r3, [pc, #72]	; (67c <checkbusy+0x94>)
     632:	681b      	ldr	r3, [r3, #0]
     634:	031b      	lsls	r3, r3, #12
     636:	0fdb      	lsrs	r3, r3, #31
     638:	466d      	mov	r5, sp
     63a:	71eb      	strb	r3, [r5, #7]
		
	PinClr(LCD_EN);
     63c:	4643      	mov	r3, r8
     63e:	601c      	str	r4, [r3, #0]
	delay_us(ENPulse);
     640:	2002      	movs	r0, #2
     642:	47b8      	blx	r7
	PinSet(LCD_EN);
     644:	6034      	str	r4, [r6, #0]
//	WritePin(LCD_D7,1);
	pinMode(LCD_D7, INPUT);		//configure lcd_d7 as input
	PinClr(LCD_RS);
	PinSet(LCD_RWb);	//RWb=1 indicates read operation.
	
	while(p27) 
     646:	79eb      	ldrb	r3, [r5, #7]
     648:	2b00      	cmp	r3, #0
     64a:	d1e9      	bne.n	620 <checkbusy+0x38>
		
	PinClr(LCD_EN);
	delay_us(ENPulse);
	PinSet(LCD_EN);
	}
	PinClr(LCD_EN);
     64c:	4b08      	ldr	r3, [pc, #32]	; (670 <checkbusy+0x88>)
     64e:	2280      	movs	r2, #128	; 0x80
     650:	0352      	lsls	r2, r2, #13
     652:	601a      	str	r2, [r3, #0]
	PinClr(LCD_RWb);
     654:	2280      	movs	r2, #128	; 0x80
     656:	0392      	lsls	r2, r2, #14
     658:	601a      	str	r2, [r3, #0]
	pinMode(LCD_D7,OUT);	//reconfigure LCD_D7 as output
     65a:	2013      	movs	r0, #19
     65c:	2100      	movs	r1, #0
     65e:	4b03      	ldr	r3, [pc, #12]	; (66c <checkbusy+0x84>)
     660:	4798      	blx	r3
#endif
}
     662:	b003      	add	sp, #12
     664:	bc0c      	pop	{r2, r3}
     666:	4690      	mov	r8, r2
     668:	4699      	mov	r9, r3
     66a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     66c:	00000a95 	.word	0x00000a95
     670:	41004414 	.word	0x41004414
     674:	41004418 	.word	0x41004418
     678:	00000891 	.word	0x00000891
     67c:	41004420 	.word	0x41004420

00000680 <LCD_DataWrite>:
	}
	delay_us(2);
	PulseLCD_EN();
}

void LCD_DataWrite(uint8_t Data){
     680:	b538      	push	{r3, r4, r5, lr}
     682:	1c05      	adds	r5, r0, #0
	// Select the Data Register by pulling RS High
	PinSet(LCD_RS);
     684:	2280      	movs	r2, #128	; 0x80
     686:	00d2      	lsls	r2, r2, #3
     688:	4b06      	ldr	r3, [pc, #24]	; (6a4 <LCD_DataWrite+0x24>)
     68a:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW LOW
	PinClr(LCD_RWb);
     68c:	2280      	movs	r2, #128	; 0x80
     68e:	0392      	lsls	r2, r2, #14
     690:	4b05      	ldr	r3, [pc, #20]	; (6a8 <LCD_DataWrite+0x28>)
     692:	601a      	str	r2, [r3, #0]
	  
	  write4bits(Data>>4);
     694:	0900      	lsrs	r0, r0, #4
     696:	4c05      	ldr	r4, [pc, #20]	; (6ac <LCD_DataWrite+0x2c>)
     698:	47a0      	blx	r4
	  write4bits(Data);
     69a:	1c28      	adds	r0, r5, #0
     69c:	47a0      	blx	r4
	  checkbusy();
     69e:	4b04      	ldr	r3, [pc, #16]	; (6b0 <LCD_DataWrite+0x30>)
     6a0:	4798      	blx	r3
}
     6a2:	bd38      	pop	{r3, r4, r5, pc}
     6a4:	41004418 	.word	0x41004418
     6a8:	41004414 	.word	0x41004414
     6ac:	00000591 	.word	0x00000591
     6b0:	000005e9 	.word	0x000005e9

000006b4 <LCD_DispAscii>:
void LCD_Print(const char *str)	//usage: LCD_disp("Hello World");
{
	while(*str) 			//Till string ends
	LCD_DataWrite(*str++); 	//Send characters one by one
}
void LCD_DispAscii(char a){	//adds 48 offset to data before sending to LCD, can be used to print single digit no on LCD
     6b4:	b508      	push	{r3, lr}
	LCD_DataWrite(a+48);
     6b6:	3030      	adds	r0, #48	; 0x30
     6b8:	b2c0      	uxtb	r0, r0
     6ba:	4b01      	ldr	r3, [pc, #4]	; (6c0 <LCD_DispAscii+0xc>)
     6bc:	4798      	blx	r3
}
     6be:	bd08      	pop	{r3, pc}
     6c0:	00000681 	.word	0x00000681

000006c4 <LCD_CmdWrite>:
	write4bits(Data);
	checkbusy();
}


void LCD_CmdWrite(uint8_t Command){
     6c4:	b538      	push	{r3, r4, r5, lr}
     6c6:	1c05      	adds	r5, r0, #0
	// Select the Command Register by pulling RS pin LOW
	PinClr(LCD_RS);
     6c8:	4b07      	ldr	r3, [pc, #28]	; (6e8 <LCD_CmdWrite+0x24>)
     6ca:	2280      	movs	r2, #128	; 0x80
     6cc:	00d2      	lsls	r2, r2, #3
     6ce:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW pin LOW
	PinClr(LCD_RWb);
     6d0:	2280      	movs	r2, #128	; 0x80
     6d2:	0392      	lsls	r2, r2, #14
     6d4:	601a      	str	r2, [r3, #0]
	
	write4bits(Command>>4);
     6d6:	0900      	lsrs	r0, r0, #4
     6d8:	4c04      	ldr	r4, [pc, #16]	; (6ec <LCD_CmdWrite+0x28>)
     6da:	47a0      	blx	r4
	write4bits(Command);
     6dc:	1c28      	adds	r0, r5, #0
     6de:	47a0      	blx	r4
	checkbusy();
     6e0:	4b03      	ldr	r3, [pc, #12]	; (6f0 <LCD_CmdWrite+0x2c>)
     6e2:	4798      	blx	r3
}
     6e4:	bd38      	pop	{r3, r4, r5, pc}
     6e6:	46c0      	nop			; (mov r8, r8)
     6e8:	41004414 	.word	0x41004414
     6ec:	00000591 	.word	0x00000591
     6f0:	000005e9 	.word	0x000005e9

000006f4 <LCD_Setcursor>:
	PinClr(LCD_EN);
}
void LCD_Setcursor(char Row, char Column)	
//pass row and column no to this function
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
     6f4:	b508      	push	{r3, lr}
	switch(Row)		
     6f6:	2802      	cmp	r0, #2
     6f8:	d00d      	beq.n	716 <LCD_Setcursor+0x22>
     6fa:	d802      	bhi.n	702 <LCD_Setcursor+0xe>
     6fc:	2801      	cmp	r0, #1
     6fe:	d005      	beq.n	70c <LCD_Setcursor+0x18>
     700:	e017      	b.n	732 <LCD_Setcursor+0x3e>
     702:	2803      	cmp	r0, #3
     704:	d00c      	beq.n	720 <LCD_Setcursor+0x2c>
     706:	2804      	cmp	r0, #4
     708:	d00f      	beq.n	72a <LCD_Setcursor+0x36>
     70a:	e012      	b.n	732 <LCD_Setcursor+0x3e>
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     70c:	317f      	adds	r1, #127	; 0x7f
     70e:	b2c8      	uxtb	r0, r1
     710:	4b08      	ldr	r3, [pc, #32]	; (734 <LCD_Setcursor+0x40>)
     712:	4798      	blx	r3
			break;
     714:	e00d      	b.n	732 <LCD_Setcursor+0x3e>
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     716:	3941      	subs	r1, #65	; 0x41
     718:	b2c8      	uxtb	r0, r1
     71a:	4b06      	ldr	r3, [pc, #24]	; (734 <LCD_Setcursor+0x40>)
     71c:	4798      	blx	r3
			break;
     71e:	e008      	b.n	732 <LCD_Setcursor+0x3e>
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     720:	396d      	subs	r1, #109	; 0x6d
     722:	b2c8      	uxtb	r0, r1
     724:	4b03      	ldr	r3, [pc, #12]	; (734 <LCD_Setcursor+0x40>)
     726:	4798      	blx	r3
			break;
     728:	e003      	b.n	732 <LCD_Setcursor+0x3e>
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     72a:	392d      	subs	r1, #45	; 0x2d
     72c:	b2c8      	uxtb	r0, r1
     72e:	4b01      	ldr	r3, [pc, #4]	; (734 <LCD_Setcursor+0x40>)
     730:	4798      	blx	r3
			break;
	}
}
     732:	bd08      	pop	{r3, pc}
     734:	000006c5 	.word	0x000006c5

00000738 <LCD_build>:
	PinClr(LCD_RWb);
	pinMode(LCD_D7,OUT);	//reconfigure LCD_D7 as output
#endif
}

void LCD_build(uint8_t location, uint8_t *ptr){		//character should be built before writing anything to lcd.
     738:	b570      	push	{r4, r5, r6, lr}
     73a:	1c0e      	adds	r6, r1, #0
	uint8_t i;
	if(location<8){
     73c:	2807      	cmp	r0, #7
     73e:	d80c      	bhi.n	75a <LCD_build+0x22>
		LCD_CmdWrite(0x40+(location*8));	//since each symbol eats up 8 bytes, location is multiplied by 8
     740:	3008      	adds	r0, #8
     742:	00c0      	lsls	r0, r0, #3
     744:	b2c0      	uxtb	r0, r0
     746:	4b05      	ldr	r3, [pc, #20]	; (75c <LCD_build+0x24>)
     748:	4798      	blx	r3
     74a:	1c34      	adds	r4, r6, #0
     74c:	3608      	adds	r6, #8
		for(i=0;i<8;i++)
		LCD_DataWrite(ptr[ i ]);
     74e:	4d04      	ldr	r5, [pc, #16]	; (760 <LCD_build+0x28>)
     750:	7820      	ldrb	r0, [r4, #0]
     752:	47a8      	blx	r5
     754:	3401      	adds	r4, #1

void LCD_build(uint8_t location, uint8_t *ptr){		//character should be built before writing anything to lcd.
	uint8_t i;
	if(location<8){
		LCD_CmdWrite(0x40+(location*8));	//since each symbol eats up 8 bytes, location is multiplied by 8
		for(i=0;i<8;i++)
     756:	42b4      	cmp	r4, r6
     758:	d1fa      	bne.n	750 <LCD_build+0x18>
		LCD_DataWrite(ptr[ i ]);
	}
	
}
     75a:	bd70      	pop	{r4, r5, r6, pc}
     75c:	000006c5 	.word	0x000006c5
     760:	00000681 	.word	0x00000681

00000764 <LCD_CursorOn>:
	LCD_DataWrite(0);
	LCD_Setcursor(3,20);
	LCD_DataWrite(0);
}

void LCD_CursorOn(){
     764:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x0E);
     766:	200e      	movs	r0, #14
     768:	4b01      	ldr	r3, [pc, #4]	; (770 <LCD_CursorOn+0xc>)
     76a:	4798      	blx	r3
}
     76c:	bd08      	pop	{r3, pc}
     76e:	46c0      	nop			; (mov r8, r8)
     770:	000006c5 	.word	0x000006c5

00000774 <LCD_CursorOff>:

void LCD_CursorOff(){
     774:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x0C);
     776:	200c      	movs	r0, #12
     778:	4b01      	ldr	r3, [pc, #4]	; (780 <LCD_CursorOff+0xc>)
     77a:	4798      	blx	r3
}
     77c:	bd08      	pop	{r3, pc}
     77e:	46c0      	nop			; (mov r8, r8)
     780:	000006c5 	.word	0x000006c5

00000784 <LCD_Clrscr>:

void LCD_CursorBlink(){
	LCD_CmdWrite(0x0F);
}

void LCD_Clrscr(){
     784:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x01);
     786:	2001      	movs	r0, #1
     788:	4b01      	ldr	r3, [pc, #4]	; (790 <LCD_Clrscr+0xc>)
     78a:	4798      	blx	r3
}
     78c:	bd08      	pop	{r3, pc}
     78e:	46c0      	nop			; (mov r8, r8)
     790:	000006c5 	.word	0x000006c5

00000794 <LCD_PowerOn>:
//  [7/25/2015 sajid]
	LCD_CmdWrite(0x13);	//sets internal power off
	checkbusy();  
//---
}
void LCD_PowerOn(){
     794:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x17);	//sets internal power ON
     796:	2017      	movs	r0, #23
     798:	4b02      	ldr	r3, [pc, #8]	; (7a4 <LCD_PowerOn+0x10>)
     79a:	4798      	blx	r3
	checkbusy();
     79c:	4b02      	ldr	r3, [pc, #8]	; (7a8 <LCD_PowerOn+0x14>)
     79e:	4798      	blx	r3
}
     7a0:	bd08      	pop	{r3, pc}
     7a2:	46c0      	nop			; (mov r8, r8)
     7a4:	000006c5 	.word	0x000006c5
     7a8:	000005e9 	.word	0x000005e9

000007ac <LCD_Init>:
#include "Delay.h"


	
void LCD_Init(void)
{
     7ac:	b538      	push	{r3, r4, r5, lr}
//First Setup All port pins properly
//Setup port as output and pin LCD_D7 as output with input read enable.
pinMode(LCD_D4, OUTPUT);		//D4
     7ae:	2010      	movs	r0, #16
     7b0:	2100      	movs	r1, #0
     7b2:	4c27      	ldr	r4, [pc, #156]	; (850 <LCD_Init+0xa4>)
     7b4:	47a0      	blx	r4
pinMode(LCD_D5, OUTPUT);		//D5
     7b6:	2011      	movs	r0, #17
     7b8:	2100      	movs	r1, #0
     7ba:	47a0      	blx	r4
pinMode(LCD_D6, OUTPUT);		//D6
     7bc:	2012      	movs	r0, #18
     7be:	2100      	movs	r1, #0
     7c0:	47a0      	blx	r4
pinMode(LCD_D7, OUTPUT);		//D7, will be changed when we need to read back busy flag
     7c2:	2013      	movs	r0, #19
     7c4:	2100      	movs	r1, #0
     7c6:	47a0      	blx	r4

pinMode(LCD_RS, OUTPUT);
     7c8:	200a      	movs	r0, #10
     7ca:	2100      	movs	r1, #0
     7cc:	47a0      	blx	r4
pinMode(LCD_RWb, OUTPUT);
     7ce:	2015      	movs	r0, #21
     7d0:	2100      	movs	r1, #0
     7d2:	47a0      	blx	r4
pinMode(LCD_EN, OUTPUT);
     7d4:	2014      	movs	r0, #20
     7d6:	2100      	movs	r1, #0
     7d8:	47a0      	blx	r4
//------------------------------------------------------------------------

 _data_pins[0] = LCD_D4;
     7da:	4b1e      	ldr	r3, [pc, #120]	; (854 <LCD_Init+0xa8>)
     7dc:	2210      	movs	r2, #16
     7de:	701a      	strb	r2, [r3, #0]
 _data_pins[1] = LCD_D5;
     7e0:	2211      	movs	r2, #17
     7e2:	705a      	strb	r2, [r3, #1]
 _data_pins[2] = LCD_D6;
     7e4:	2212      	movs	r2, #18
     7e6:	709a      	strb	r2, [r3, #2]
 _data_pins[3] = LCD_D7;
     7e8:	2213      	movs	r2, #19
     7ea:	70da      	strb	r2, [r3, #3]
	// Select the Command Register by pulling RS pin LOW
	PinClr(LCD_RS);
     7ec:	4b1a      	ldr	r3, [pc, #104]	; (858 <LCD_Init+0xac>)
     7ee:	2280      	movs	r2, #128	; 0x80
     7f0:	00d2      	lsls	r2, r2, #3
     7f2:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW pin LOW
	PinClr(LCD_RWb);
     7f4:	2280      	movs	r2, #128	; 0x80
     7f6:	0392      	lsls	r2, r2, #14
     7f8:	601a      	str	r2, [r3, #0]

//LCD commands start here

	delay_ms(100);		//w8 for power rail to stabilize
     7fa:	2064      	movs	r0, #100	; 0x64
     7fc:	4c17      	ldr	r4, [pc, #92]	; (85c <LCD_Init+0xb0>)
     7fe:	47a0      	blx	r4
	
	write4bits(0x03);	//put LCD in 8 bit mode
     800:	2003      	movs	r0, #3
     802:	4d17      	ldr	r5, [pc, #92]	; (860 <LCD_Init+0xb4>)
     804:	47a8      	blx	r5
	delay_ms(40);
     806:	2028      	movs	r0, #40	; 0x28
     808:	47a0      	blx	r4
	
	write4bits(0x03);	//again
     80a:	2003      	movs	r0, #3
     80c:	47a8      	blx	r5
	delay_ms(40);
     80e:	2028      	movs	r0, #40	; 0x28
     810:	47a0      	blx	r4
	
	write4bits(0x03);	//again
     812:	2003      	movs	r0, #3
     814:	47a8      	blx	r5
	delay_ms(30);
     816:	201e      	movs	r0, #30
     818:	47a0      	blx	r4
	
	write4bits(0x02);  //Initialize the LCD in 4bit Mode
     81a:	2002      	movs	r0, #2
     81c:	47a8      	blx	r5
	delay_ms(50);
     81e:	2032      	movs	r0, #50	; 0x32
     820:	47a0      	blx	r4
	
	
	LCD_CmdWrite(0x28);	//LCD in 4 bit, 2 lines, 5x8 dots 
     822:	2028      	movs	r0, #40	; 0x28
     824:	4d0f      	ldr	r5, [pc, #60]	; (864 <LCD_Init+0xb8>)
     826:	47a8      	blx	r5
	checkbusy();
     828:	4c0f      	ldr	r4, [pc, #60]	; (868 <LCD_Init+0xbc>)
     82a:	47a0      	blx	r4

	//  [7/25/2015 sajid]
	LCD_CmdWrite(0x08);		//Turn off display, very important for OLED
     82c:	2008      	movs	r0, #8
     82e:	47a8      	blx	r5
	checkbusy();	
     830:	47a0      	blx	r4
	//  [7/25/2015 sajid]
	
	LCD_CmdWrite(0x06);		//Entry mode:Increment, No display shift
     832:	2006      	movs	r0, #6
     834:	47a8      	blx	r5
	checkbusy();
     836:	47a0      	blx	r4
	
	LCD_CmdWrite(0x0E);		// Display ON, cursor ON, Blink Off
     838:	200e      	movs	r0, #14
     83a:	47a8      	blx	r5
	checkbusy();  
     83c:	47a0      	blx	r4
	
	LCD_CmdWrite(0x01);
     83e:	2001      	movs	r0, #1
     840:	47a8      	blx	r5
	checkbusy();  // Clear the LCD
     842:	47a0      	blx	r4
	
	LCD_CmdWrite(0x80);
     844:	2080      	movs	r0, #128	; 0x80
     846:	47a8      	blx	r5
	checkbusy();  // Move the Cursor to First line First Position
     848:	47a0      	blx	r4
	LCD_PowerOn();
     84a:	4b08      	ldr	r3, [pc, #32]	; (86c <LCD_Init+0xc0>)
     84c:	4798      	blx	r3
}
     84e:	bd38      	pop	{r3, r4, r5, pc}
     850:	00000a95 	.word	0x00000a95
     854:	20000078 	.word	0x20000078
     858:	41004414 	.word	0x41004414
     85c:	000008c9 	.word	0x000008c9
     860:	00000591 	.word	0x00000591
     864:	000006c5 	.word	0x000006c5
     868:	000005e9 	.word	0x000005e9
     86c:	00000795 	.word	0x00000795

00000870 <delay_1us>:
#include "compiler.h"

#include "Delay.h"


 void delay_1us() {			//gives 1 us delay
     870:	b082      	sub	sp, #8
	 for (volatile int iter=0; iter<2;iter++)
     872:	2300      	movs	r3, #0
     874:	9301      	str	r3, [sp, #4]
     876:	9b01      	ldr	r3, [sp, #4]
     878:	2b01      	cmp	r3, #1
     87a:	dc07      	bgt.n	88c <delay_1us+0x1c>
	 {
		 asm("NOP");		 
     87c:	46c0      	nop			; (mov r8, r8)
		 asm("NOP");		 
     87e:	46c0      	nop			; (mov r8, r8)

#include "Delay.h"


 void delay_1us() {			//gives 1 us delay
	 for (volatile int iter=0; iter<2;iter++)
     880:	9b01      	ldr	r3, [sp, #4]
     882:	3301      	adds	r3, #1
     884:	9301      	str	r3, [sp, #4]
     886:	9b01      	ldr	r3, [sp, #4]
     888:	2b01      	cmp	r3, #1
     88a:	ddf7      	ble.n	87c <delay_1us+0xc>
	 {
		 asm("NOP");		 
		 asm("NOP");		 
	 }
 }
     88c:	b002      	add	sp, #8
     88e:	4770      	bx	lr

00000890 <delay_us>:

void delay_us(volatile uint32_t iter_us){	//gives us delay
     890:	b510      	push	{r4, lr}
     892:	b082      	sub	sp, #8
     894:	9001      	str	r0, [sp, #4]
	while(iter_us!=0){
     896:	9b01      	ldr	r3, [sp, #4]
     898:	2b00      	cmp	r3, #0
     89a:	d007      	beq.n	8ac <delay_us+0x1c>
		delay_1us();
     89c:	4c04      	ldr	r4, [pc, #16]	; (8b0 <delay_us+0x20>)
     89e:	47a0      	blx	r4
		iter_us--;
     8a0:	9b01      	ldr	r3, [sp, #4]
     8a2:	3b01      	subs	r3, #1
     8a4:	9301      	str	r3, [sp, #4]
		 asm("NOP");		 
	 }
 }

void delay_us(volatile uint32_t iter_us){	//gives us delay
	while(iter_us!=0){
     8a6:	9b01      	ldr	r3, [sp, #4]
     8a8:	2b00      	cmp	r3, #0
     8aa:	d1f8      	bne.n	89e <delay_us+0xe>
		delay_1us();
		iter_us--;
	}
}
     8ac:	b002      	add	sp, #8
     8ae:	bd10      	pop	{r4, pc}
     8b0:	00000871 	.word	0x00000871

000008b4 <delay_1ms>:

void delay_1ms() {
     8b4:	b508      	push	{r3, lr}
		delay_us(1050);	//value adjusted to give 1ms delay
     8b6:	4802      	ldr	r0, [pc, #8]	; (8c0 <delay_1ms+0xc>)
     8b8:	4b02      	ldr	r3, [pc, #8]	; (8c4 <delay_1ms+0x10>)
     8ba:	4798      	blx	r3

}
     8bc:	bd08      	pop	{r3, pc}
     8be:	46c0      	nop			; (mov r8, r8)
     8c0:	0000041a 	.word	0x0000041a
     8c4:	00000891 	.word	0x00000891

000008c8 <delay_ms>:

void delay_ms(volatile uint32_t iter_ms){
     8c8:	b510      	push	{r4, lr}
     8ca:	b082      	sub	sp, #8
     8cc:	9001      	str	r0, [sp, #4]
	while (iter_ms)
     8ce:	9b01      	ldr	r3, [sp, #4]
     8d0:	2b00      	cmp	r3, #0
     8d2:	d007      	beq.n	8e4 <delay_ms+0x1c>
	{
		delay_1ms();
     8d4:	4c04      	ldr	r4, [pc, #16]	; (8e8 <delay_ms+0x20>)
     8d6:	47a0      	blx	r4
		iter_ms--;
     8d8:	9b01      	ldr	r3, [sp, #4]
     8da:	3b01      	subs	r3, #1
     8dc:	9301      	str	r3, [sp, #4]
		delay_us(1050);	//value adjusted to give 1ms delay

}

void delay_ms(volatile uint32_t iter_ms){
	while (iter_ms)
     8de:	9b01      	ldr	r3, [sp, #4]
     8e0:	2b00      	cmp	r3, #0
     8e2:	d1f8      	bne.n	8d6 <delay_ms+0xe>
	{
		delay_1ms();
		iter_ms--;
	}
}
     8e4:	b002      	add	sp, #8
     8e6:	bd10      	pop	{r4, pc}
     8e8:	000008b5 	.word	0x000008b5

000008ec <Config_MatrixKeypad>:
2 COL configured as Input with Pull up resistor, and 3 rows as Totem-pole OUTPUT
	1. We will first roughly chk for any key press by making all Rows LOW and Checking Both COL for LOW
	2. If any key detected we will wait for debounce period      
	3. And then clear each ROW and check each col to determine which key is pressed   */
/**********************************************************************************************************/
void Config_MatrixKeypad(){	//call this once in your program
     8ec:	b510      	push	{r4, lr}
	pinMode(COL1, INPUP);		//Make Columns Input with pull up.
     8ee:	202d      	movs	r0, #45	; 0x2d
     8f0:	2103      	movs	r1, #3
     8f2:	4c07      	ldr	r4, [pc, #28]	; (910 <Config_MatrixKeypad+0x24>)
     8f4:	47a0      	blx	r4
	pinMode(COL2, INPUP);		//INPUP stands for input with pull up.
     8f6:	202e      	movs	r0, #46	; 0x2e
     8f8:	2103      	movs	r1, #3
     8fa:	47a0      	blx	r4
	pinMode(ROW1, OUTPUT);		//Make ROWs as Output
     8fc:	202a      	movs	r0, #42	; 0x2a
     8fe:	2100      	movs	r1, #0
     900:	47a0      	blx	r4
	pinMode(ROW2, OUTPUT);
     902:	202b      	movs	r0, #43	; 0x2b
     904:	2100      	movs	r1, #0
     906:	47a0      	blx	r4
	pinMode(ROW3, OUTPUT);
     908:	202c      	movs	r0, #44	; 0x2c
     90a:	2100      	movs	r1, #0
     90c:	47a0      	blx	r4
}
     90e:	bd10      	pop	{r4, pc}
     910:	00000a95 	.word	0x00000a95

00000914 <ClearKeys>:

void ClearKeys(){
	ParaKey	=0;
     914:	2300      	movs	r3, #0
     916:	4a06      	ldr	r2, [pc, #24]	; (930 <ClearKeys+0x1c>)
     918:	7013      	strb	r3, [r2, #0]
	RunKey	=0;
     91a:	4a06      	ldr	r2, [pc, #24]	; (934 <ClearKeys+0x20>)
     91c:	7013      	strb	r3, [r2, #0]
	StartKey=0;
     91e:	4a06      	ldr	r2, [pc, #24]	; (938 <ClearKeys+0x24>)
     920:	7013      	strb	r3, [r2, #0]
	StopKey	=0;
     922:	4a06      	ldr	r2, [pc, #24]	; (93c <ClearKeys+0x28>)
     924:	7013      	strb	r3, [r2, #0]
	UpdateKey=0;
     926:	4a06      	ldr	r2, [pc, #24]	; (940 <ClearKeys+0x2c>)
     928:	7013      	strb	r3, [r2, #0]
	EnterKey =0;
     92a:	4a06      	ldr	r2, [pc, #24]	; (944 <ClearKeys+0x30>)
     92c:	7013      	strb	r3, [r2, #0]
}
     92e:	4770      	bx	lr
     930:	2000007c 	.word	0x2000007c
     934:	2000007d 	.word	0x2000007d
     938:	2000007f 	.word	0x2000007f
     93c:	20000080 	.word	0x20000080
     940:	20000074 	.word	0x20000074
     944:	2000007e 	.word	0x2000007e

00000948 <KeyDetected>:

bool KeyDetected(){
     948:	b508      	push	{r3, lr}
	PinClr(ROW1);
     94a:	4b0c      	ldr	r3, [pc, #48]	; (97c <KeyDetected+0x34>)
     94c:	2280      	movs	r2, #128	; 0x80
     94e:	00d2      	lsls	r2, r2, #3
     950:	601a      	str	r2, [r3, #0]
	PinClr(ROW2);
     952:	2280      	movs	r2, #128	; 0x80
     954:	0112      	lsls	r2, r2, #4
     956:	601a      	str	r2, [r3, #0]
	PinClr(ROW3);
     958:	2280      	movs	r2, #128	; 0x80
     95a:	0152      	lsls	r2, r2, #5
     95c:	601a      	str	r2, [r3, #0]
	if ((digitalRead(COL1)==0) || (digitalRead(COL2)==0))
     95e:	202d      	movs	r0, #45	; 0x2d
     960:	4b07      	ldr	r3, [pc, #28]	; (980 <KeyDetected+0x38>)
     962:	4798      	blx	r3
     964:	1c03      	adds	r3, r0, #0
	{
		return(true);
     966:	2001      	movs	r0, #1

bool KeyDetected(){
	PinClr(ROW1);
	PinClr(ROW2);
	PinClr(ROW3);
	if ((digitalRead(COL1)==0) || (digitalRead(COL2)==0))
     968:	2b00      	cmp	r3, #0
     96a:	d005      	beq.n	978 <KeyDetected+0x30>
     96c:	202e      	movs	r0, #46	; 0x2e
     96e:	4b04      	ldr	r3, [pc, #16]	; (980 <KeyDetected+0x38>)
     970:	4798      	blx	r3
     972:	2301      	movs	r3, #1
     974:	4058      	eors	r0, r3
     976:	b2c0      	uxtb	r0, r0
	{
		return(true);
	}
	else
		return(false);
}
     978:	bd08      	pop	{r3, pc}
     97a:	46c0      	nop			; (mov r8, r8)
     97c:	41004494 	.word	0x41004494
     980:	00000bcd 	.word	0x00000bcd

00000984 <Keyscan>:


void Keyscan(){			//call this whenever key status required
     984:	b5f0      	push	{r4, r5, r6, r7, lr}
     986:	4657      	mov	r7, sl
     988:	464e      	mov	r6, r9
     98a:	4645      	mov	r5, r8
     98c:	b4e0      	push	{r5, r6, r7}

	if (KeyDetected())	//if both columns are high, then no key is pressed
     98e:	4b2f      	ldr	r3, [pc, #188]	; (a4c <Keyscan+0xc8>)
     990:	4798      	blx	r3
     992:	2800      	cmp	r0, #0
     994:	d052      	beq.n	a3c <Keyscan+0xb8>
	{	//program will enter when any key is pressed
		delay_ms(debounce_ms);	//debounce delay
     996:	2014      	movs	r0, #20
     998:	4b2d      	ldr	r3, [pc, #180]	; (a50 <Keyscan+0xcc>)
     99a:	4798      	blx	r3
		if (KeyDetected())	//check again
     99c:	4b2b      	ldr	r3, [pc, #172]	; (a4c <Keyscan+0xc8>)
     99e:	4798      	blx	r3
     9a0:	2800      	cmp	r0, #0
     9a2:	d048      	beq.n	a36 <Keyscan+0xb2>
		{						 
			//ROW1
			PinClr(ROW1);		//activate ROW 1 and check both columns
     9a4:	4f2b      	ldr	r7, [pc, #172]	; (a54 <Keyscan+0xd0>)
     9a6:	2380      	movs	r3, #128	; 0x80
     9a8:	00db      	lsls	r3, r3, #3
     9aa:	469a      	mov	sl, r3
     9ac:	603b      	str	r3, [r7, #0]
			PinSet(ROW2);
     9ae:	4e2a      	ldr	r6, [pc, #168]	; (a58 <Keyscan+0xd4>)
     9b0:	2380      	movs	r3, #128	; 0x80
     9b2:	011b      	lsls	r3, r3, #4
     9b4:	4699      	mov	r9, r3
     9b6:	6033      	str	r3, [r6, #0]
			PinSet(ROW3);
     9b8:	2380      	movs	r3, #128	; 0x80
     9ba:	015b      	lsls	r3, r3, #5
     9bc:	4698      	mov	r8, r3
     9be:	6033      	str	r3, [r6, #0]
			ParaKey	= !(digitalRead(COL1));
     9c0:	202d      	movs	r0, #45	; 0x2d
     9c2:	4d26      	ldr	r5, [pc, #152]	; (a5c <Keyscan+0xd8>)
     9c4:	47a8      	blx	r5
     9c6:	2401      	movs	r4, #1
     9c8:	4060      	eors	r0, r4
     9ca:	b2c0      	uxtb	r0, r0
     9cc:	4b24      	ldr	r3, [pc, #144]	; (a60 <Keyscan+0xdc>)
     9ce:	7018      	strb	r0, [r3, #0]
			RunKey	= !(digitalRead(COL2));
     9d0:	202e      	movs	r0, #46	; 0x2e
     9d2:	47a8      	blx	r5
     9d4:	4060      	eors	r0, r4
     9d6:	b2c0      	uxtb	r0, r0
     9d8:	4b22      	ldr	r3, [pc, #136]	; (a64 <Keyscan+0xe0>)
     9da:	7018      	strb	r0, [r3, #0]
			
			//ROW2
			PinSet(ROW1);
     9dc:	4653      	mov	r3, sl
     9de:	6033      	str	r3, [r6, #0]
			PinClr(ROW2);		//activate ROW 2 and check both columns
     9e0:	464b      	mov	r3, r9
     9e2:	603b      	str	r3, [r7, #0]
			PinSet(ROW3);
     9e4:	4643      	mov	r3, r8
     9e6:	6033      	str	r3, [r6, #0]
			 StartKey= !(digitalRead(COL1));
     9e8:	202d      	movs	r0, #45	; 0x2d
     9ea:	47a8      	blx	r5
     9ec:	4060      	eors	r0, r4
     9ee:	b2c0      	uxtb	r0, r0
     9f0:	4b1d      	ldr	r3, [pc, #116]	; (a68 <Keyscan+0xe4>)
     9f2:	7018      	strb	r0, [r3, #0]
			 StopKey	= !(digitalRead(COL2));
     9f4:	202e      	movs	r0, #46	; 0x2e
     9f6:	47a8      	blx	r5
     9f8:	4060      	eors	r0, r4
     9fa:	b2c0      	uxtb	r0, r0
     9fc:	4b1b      	ldr	r3, [pc, #108]	; (a6c <Keyscan+0xe8>)
     9fe:	7018      	strb	r0, [r3, #0]
			
			//ROW3
			PinSet(ROW1);		//activate ROW 3 and check both columns
     a00:	4653      	mov	r3, sl
     a02:	6033      	str	r3, [r6, #0]
			PinSet(ROW2);
     a04:	464b      	mov	r3, r9
     a06:	6033      	str	r3, [r6, #0]
			PinClr(ROW3);
     a08:	4643      	mov	r3, r8
     a0a:	603b      	str	r3, [r7, #0]
			 UpdateKey= !(digitalRead(COL1));
     a0c:	202d      	movs	r0, #45	; 0x2d
     a0e:	47a8      	blx	r5
     a10:	4060      	eors	r0, r4
     a12:	b2c0      	uxtb	r0, r0
     a14:	4b16      	ldr	r3, [pc, #88]	; (a70 <Keyscan+0xec>)
     a16:	7018      	strb	r0, [r3, #0]
			 EnterKey = !(digitalRead(COL2));
     a18:	202e      	movs	r0, #46	; 0x2e
     a1a:	47a8      	blx	r5
     a1c:	4044      	eors	r4, r0
     a1e:	b2e0      	uxtb	r0, r4
     a20:	4b14      	ldr	r3, [pc, #80]	; (a74 <Keyscan+0xf0>)
     a22:	7018      	strb	r0, [r3, #0]
			while (KeyDetected())
     a24:	4c09      	ldr	r4, [pc, #36]	; (a4c <Keyscan+0xc8>)
			{
				delay_ms(1);	//w8 until all keys are released
     a26:	4d0a      	ldr	r5, [pc, #40]	; (a50 <Keyscan+0xcc>)
			PinSet(ROW1);		//activate ROW 3 and check both columns
			PinSet(ROW2);
			PinClr(ROW3);
			 UpdateKey= !(digitalRead(COL1));
			 EnterKey = !(digitalRead(COL2));
			while (KeyDetected())
     a28:	e001      	b.n	a2e <Keyscan+0xaa>
			{
				delay_ms(1);	//w8 until all keys are released
     a2a:	2001      	movs	r0, #1
     a2c:	47a8      	blx	r5
			PinSet(ROW1);		//activate ROW 3 and check both columns
			PinSet(ROW2);
			PinClr(ROW3);
			 UpdateKey= !(digitalRead(COL1));
			 EnterKey = !(digitalRead(COL2));
			while (KeyDetected())
     a2e:	47a0      	blx	r4
     a30:	2800      	cmp	r0, #0
     a32:	d1fa      	bne.n	a2a <Keyscan+0xa6>
     a34:	e004      	b.n	a40 <Keyscan+0xbc>
			{
				delay_ms(1);	//w8 until all keys are released
			}
		}
		else
			ClearKeys();	
     a36:	4b10      	ldr	r3, [pc, #64]	; (a78 <Keyscan+0xf4>)
     a38:	4798      	blx	r3
     a3a:	e001      	b.n	a40 <Keyscan+0xbc>
	}
	else
		ClearKeys();
     a3c:	4b0e      	ldr	r3, [pc, #56]	; (a78 <Keyscan+0xf4>)
     a3e:	4798      	blx	r3
}
     a40:	bc1c      	pop	{r2, r3, r4}
     a42:	4690      	mov	r8, r2
     a44:	4699      	mov	r9, r3
     a46:	46a2      	mov	sl, r4
     a48:	bdf0      	pop	{r4, r5, r6, r7, pc}
     a4a:	46c0      	nop			; (mov r8, r8)
     a4c:	00000949 	.word	0x00000949
     a50:	000008c9 	.word	0x000008c9
     a54:	41004494 	.word	0x41004494
     a58:	41004498 	.word	0x41004498
     a5c:	00000bcd 	.word	0x00000bcd
     a60:	2000007c 	.word	0x2000007c
     a64:	2000007d 	.word	0x2000007d
     a68:	2000007f 	.word	0x2000007f
     a6c:	20000080 	.word	0x20000080
     a70:	20000074 	.word	0x20000074
     a74:	2000007e 	.word	0x2000007e
     a78:	00000915 	.word	0x00000915

00000a7c <GCLKGen_Peripheral>:
void GCLKGen_Peripheral(uint8_t GclockGen, uint8_t Peripheral){
//this function writes to 16 bit CLKCTRL register
// [WRTLOCK|CLKEN|GEN()]
	uint16_t Data=0;
  //Data=(CLKEN) |    (GEN[0:3])   | (Peripheral ID[5:0])
	Data=(1<<14) |  (GclockGen<<8) | (Peripheral<<0) ;
     a7c:	2380      	movs	r3, #128	; 0x80
     a7e:	01db      	lsls	r3, r3, #7
     a80:	4319      	orrs	r1, r3
     a82:	0203      	lsls	r3, r0, #8
     a84:	1c08      	adds	r0, r1, #0
     a86:	4318      	orrs	r0, r3
	CLKCTRL=Data;
     a88:	4b01      	ldr	r3, [pc, #4]	; (a90 <GCLKGen_Peripheral+0x14>)
     a8a:	8018      	strh	r0, [r3, #0]
}
     a8c:	4770      	bx	lr
     a8e:	46c0      	nop			; (mov r8, r8)
     a90:	40000c02 	.word	0x40000c02

00000a94 <pinMode>:

 OLD approach*/

//usage pinMode(PA15, OUTPUT)
void pinMode(uint8_t Pin, uint8_t mode)
{
     a94:	b510      	push	{r4, lr}
	if (mode==OUTPUT) {			//strong Totem Pole output
     a96:	2900      	cmp	r1, #0
     a98:	d10e      	bne.n	ab8 <pinMode+0x24>
		DIRSET(Pin);			//enable pin as output
     a9a:	0943      	lsrs	r3, r0, #5
     a9c:	01db      	lsls	r3, r3, #7
     a9e:	4939      	ldr	r1, [pc, #228]	; (b84 <pinMode+0xf0>)
     aa0:	185a      	adds	r2, r3, r1
     aa2:	211f      	movs	r1, #31
     aa4:	4008      	ands	r0, r1
     aa6:	2101      	movs	r1, #1
     aa8:	4081      	lsls	r1, r0
     aaa:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)=0;			//disable pull up, input, low drive strength
     aac:	4a36      	ldr	r2, [pc, #216]	; (b88 <pinMode+0xf4>)
     aae:	1880      	adds	r0, r0, r2
     ab0:	18c3      	adds	r3, r0, r3
     ab2:	2200      	movs	r2, #0
     ab4:	701a      	strb	r2, [r3, #0]
     ab6:	e063      	b.n	b80 <pinMode+0xec>
	}
		
	else if (mode==WEAKOUT){	//pin configured as output with weak pull
     ab8:	2901      	cmp	r1, #1
     aba:	d110      	bne.n	ade <pinMode+0x4a>
		DIRCLR(Pin);			//enable pin as output
     abc:	0943      	lsrs	r3, r0, #5
     abe:	01db      	lsls	r3, r3, #7
     ac0:	4932      	ldr	r1, [pc, #200]	; (b8c <pinMode+0xf8>)
     ac2:	185a      	adds	r2, r3, r1
     ac4:	211f      	movs	r1, #31
     ac6:	4008      	ands	r0, r1
     ac8:	2101      	movs	r1, #1
     aca:	4081      	lsls	r1, r0
     acc:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b100;		//enable pull RESISTOR
     ace:	4a2e      	ldr	r2, [pc, #184]	; (b88 <pinMode+0xf4>)
     ad0:	1880      	adds	r0, r0, r2
     ad2:	18c0      	adds	r0, r0, r3
     ad4:	7802      	ldrb	r2, [r0, #0]
     ad6:	2304      	movs	r3, #4
     ad8:	4313      	orrs	r3, r2
     ada:	7003      	strb	r3, [r0, #0]
     adc:	e050      	b.n	b80 <pinMode+0xec>
	//Pull value will be decided by OUT register value
	//when OUT bit is 1 for a particular pin it will be pulled high and for out bit =0 pin will be pulled low
	}
	
	else if(mode==INPUT) {		//high impedance input
     ade:	2902      	cmp	r1, #2
     ae0:	d110      	bne.n	b04 <pinMode+0x70>
		DIRCLR(Pin);			//make pin input
     ae2:	0943      	lsrs	r3, r0, #5
     ae4:	01db      	lsls	r3, r3, #7
     ae6:	4929      	ldr	r1, [pc, #164]	; (b8c <pinMode+0xf8>)
     ae8:	185a      	adds	r2, r3, r1
     aea:	211f      	movs	r1, #31
     aec:	4008      	ands	r0, r1
     aee:	2101      	movs	r1, #1
     af0:	4081      	lsls	r1, r0
     af2:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b10;		//enable input pin sampling, pull disabled		
     af4:	4a24      	ldr	r2, [pc, #144]	; (b88 <pinMode+0xf4>)
     af6:	1880      	adds	r0, r0, r2
     af8:	18c0      	adds	r0, r0, r3
     afa:	7802      	ldrb	r2, [r0, #0]
     afc:	2302      	movs	r3, #2
     afe:	4313      	orrs	r3, r2
     b00:	7003      	strb	r3, [r0, #0]
     b02:	e03d      	b.n	b80 <pinMode+0xec>
	}
	
	else if (mode==INOUT){		//pin configured as input and output
     b04:	2905      	cmp	r1, #5
     b06:	d110      	bne.n	b2a <pinMode+0x96>
		DIRSET(Pin);			//enable pin as output
     b08:	0943      	lsrs	r3, r0, #5
     b0a:	01db      	lsls	r3, r3, #7
     b0c:	491d      	ldr	r1, [pc, #116]	; (b84 <pinMode+0xf0>)
     b0e:	185a      	adds	r2, r3, r1
     b10:	211f      	movs	r1, #31
     b12:	4008      	ands	r0, r1
     b14:	2101      	movs	r1, #1
     b16:	4081      	lsls	r1, r0
     b18:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b10;		//enable input pin sampling
     b1a:	4a1b      	ldr	r2, [pc, #108]	; (b88 <pinMode+0xf4>)
     b1c:	1880      	adds	r0, r0, r2
     b1e:	18c0      	adds	r0, r0, r3
     b20:	7802      	ldrb	r2, [r0, #0]
     b22:	2302      	movs	r3, #2
     b24:	4313      	orrs	r3, r2
     b26:	7003      	strb	r3, [r0, #0]
     b28:	e02a      	b.n	b80 <pinMode+0xec>
	}
	
	else if (mode==INPUP){		//pin configured as input with pull up resistor
     b2a:	2903      	cmp	r1, #3
     b2c:	d113      	bne.n	b56 <pinMode+0xc2>
		DIRCLR(Pin);			//enable pin as input
     b2e:	0943      	lsrs	r3, r0, #5
     b30:	01db      	lsls	r3, r3, #7
     b32:	4a16      	ldr	r2, [pc, #88]	; (b8c <pinMode+0xf8>)
     b34:	1899      	adds	r1, r3, r2
     b36:	221f      	movs	r2, #31
     b38:	4010      	ands	r0, r2
     b3a:	2201      	movs	r2, #1
     b3c:	4082      	lsls	r2, r0
     b3e:	600a      	str	r2, [r1, #0]
		PINCFG(Pin)|=0b110;		//enable pull and input pin sampling
     b40:	4911      	ldr	r1, [pc, #68]	; (b88 <pinMode+0xf4>)
     b42:	1840      	adds	r0, r0, r1
     b44:	18c0      	adds	r0, r0, r3
     b46:	7804      	ldrb	r4, [r0, #0]
     b48:	2106      	movs	r1, #6
     b4a:	4321      	orrs	r1, r4
     b4c:	7001      	strb	r1, [r0, #0]
	//pull value(1 or 0) depends on OUT register value, since we want pull up so we will set 'OUT' register bit
		PinSet(Pin);											
     b4e:	4910      	ldr	r1, [pc, #64]	; (b90 <pinMode+0xfc>)
     b50:	185b      	adds	r3, r3, r1
     b52:	601a      	str	r2, [r3, #0]
     b54:	e014      	b.n	b80 <pinMode+0xec>
	}
	
	else if (mode==INPDN){		//pin configured as input with pull down resistor
     b56:	2904      	cmp	r1, #4
     b58:	d112      	bne.n	b80 <pinMode+0xec>
		DIRCLR(Pin);			//enable pin as input
     b5a:	0943      	lsrs	r3, r0, #5
     b5c:	01db      	lsls	r3, r3, #7
     b5e:	4a0b      	ldr	r2, [pc, #44]	; (b8c <pinMode+0xf8>)
     b60:	1899      	adds	r1, r3, r2
     b62:	221f      	movs	r2, #31
     b64:	4010      	ands	r0, r2
     b66:	2201      	movs	r2, #1
     b68:	4082      	lsls	r2, r0
     b6a:	600a      	str	r2, [r1, #0]
		PINCFG(Pin)|=0b110;		//enable pull and input pin sampling
     b6c:	4906      	ldr	r1, [pc, #24]	; (b88 <pinMode+0xf4>)
     b6e:	1840      	adds	r0, r0, r1
     b70:	18c0      	adds	r0, r0, r3
     b72:	7804      	ldrb	r4, [r0, #0]
     b74:	2106      	movs	r1, #6
     b76:	4321      	orrs	r1, r4
     b78:	7001      	strb	r1, [r0, #0]
	//pull value(1 or 0) depends on OUT register value, since we want pull dwn so we will clear 'OUT' register bit
		PinClr(Pin);
     b7a:	4906      	ldr	r1, [pc, #24]	; (b94 <pinMode+0x100>)
     b7c:	185b      	adds	r3, r3, r1
     b7e:	601a      	str	r2, [r3, #0]
	}
		
}
     b80:	bd10      	pop	{r4, pc}
     b82:	46c0      	nop			; (mov r8, r8)
     b84:	41004408 	.word	0x41004408
     b88:	41004440 	.word	0x41004440
     b8c:	41004404 	.word	0x41004404
     b90:	41004418 	.word	0x41004418
     b94:	41004414 	.word	0x41004414

00000b98 <digitalWrite>:

//usage digitalWrite(PA20, HIGH); to set pin PA20
//Alternatively you can use PinSet(PA20) and PinClr(pin_no) macros
void digitalWrite(uint8_t pin_no, bool val){
	if (val==1)
     b98:	2900      	cmp	r1, #0
     b9a:	d009      	beq.n	bb0 <digitalWrite+0x18>
	{
		PinSet(pin_no);
     b9c:	0943      	lsrs	r3, r0, #5
     b9e:	01db      	lsls	r3, r3, #7
     ba0:	4a08      	ldr	r2, [pc, #32]	; (bc4 <digitalWrite+0x2c>)
     ba2:	189b      	adds	r3, r3, r2
     ba4:	221f      	movs	r2, #31
     ba6:	4010      	ands	r0, r2
     ba8:	2201      	movs	r2, #1
     baa:	4082      	lsls	r2, r0
     bac:	601a      	str	r2, [r3, #0]
     bae:	e008      	b.n	bc2 <digitalWrite+0x2a>
	}
	else
	{
		
		PinClr(pin_no);
     bb0:	0943      	lsrs	r3, r0, #5
     bb2:	01db      	lsls	r3, r3, #7
     bb4:	4a04      	ldr	r2, [pc, #16]	; (bc8 <digitalWrite+0x30>)
     bb6:	189b      	adds	r3, r3, r2
     bb8:	221f      	movs	r2, #31
     bba:	4010      	ands	r0, r2
     bbc:	2201      	movs	r2, #1
     bbe:	4082      	lsls	r2, r0
     bc0:	601a      	str	r2, [r3, #0]
	}
}
     bc2:	4770      	bx	lr
     bc4:	41004418 	.word	0x41004418
     bc8:	41004414 	.word	0x41004414

00000bcc <digitalRead>:

//usage bool a= digitalRead(PB20); a will contain status of pin PB20
//Alternatively You can use macro function eg:PinRead(PA04), since this function also does the same.
bool digitalRead(uint8_t Pin){
	return(PinRead(Pin));
     bcc:	0943      	lsrs	r3, r0, #5
     bce:	01db      	lsls	r3, r3, #7
     bd0:	4a06      	ldr	r2, [pc, #24]	; (bec <digitalRead+0x20>)
     bd2:	189b      	adds	r3, r3, r2
     bd4:	681b      	ldr	r3, [r3, #0]
     bd6:	221f      	movs	r2, #31
     bd8:	4010      	ands	r0, r2
     bda:	2201      	movs	r2, #1
     bdc:	4082      	lsls	r2, r0
     bde:	1c10      	adds	r0, r2, #0
     be0:	4018      	ands	r0, r3
     be2:	1e43      	subs	r3, r0, #1
     be4:	4198      	sbcs	r0, r3
     be6:	b2c0      	uxtb	r0, r0
}
     be8:	4770      	bx	lr
     bea:	46c0      	nop			; (mov r8, r8)
     bec:	41004420 	.word	0x41004420

00000bf0 <pinMux>:


	/*		Usage: pinMux(PA2, ADC);		*/
//REFER S_PORT.h To get list of PINMUX peripheral names
	 
void pinMux(uint8_t Pin, uint8_t peripheral){ //refer S_PORT.h for available options for peripheral.
     bf0:	b530      	push	{r4, r5, lr}
//Enable PINMUX for the pin
if (peripheral==0x0A)
     bf2:	290a      	cmp	r1, #10
     bf4:	d10b      	bne.n	c0e <pinMux+0x1e>
{
	PINCFG(Pin)&=0xFE;	//clr bit 0
     bf6:	231f      	movs	r3, #31
     bf8:	4003      	ands	r3, r0
     bfa:	4a17      	ldr	r2, [pc, #92]	; (c58 <pinMux+0x68>)
     bfc:	189b      	adds	r3, r3, r2
     bfe:	0940      	lsrs	r0, r0, #5
     c00:	01c0      	lsls	r0, r0, #7
     c02:	1818      	adds	r0, r3, r0
     c04:	7803      	ldrb	r3, [r0, #0]
     c06:	2201      	movs	r2, #1
     c08:	4393      	bics	r3, r2
     c0a:	7003      	strb	r3, [r0, #0]
     c0c:	e023      	b.n	c56 <pinMux+0x66>
}
else
{
	PINCFG(Pin) = 0b1;
     c0e:	0942      	lsrs	r2, r0, #5
     c10:	01d2      	lsls	r2, r2, #7
     c12:	231f      	movs	r3, #31
     c14:	4003      	ands	r3, r0
     c16:	4d10      	ldr	r5, [pc, #64]	; (c58 <pinMux+0x68>)
     c18:	195c      	adds	r4, r3, r5
     c1a:	18a4      	adds	r4, r4, r2
     c1c:	2501      	movs	r5, #1
     c1e:	7025      	strb	r5, [r4, #0]
	//peripheral &= 0x0F;						//makes sure peripheral is 4 bit value
	if ((Pin%32) %2==0)						//even pin no. corresponds to lower nibble in Pmux reg
     c20:	07c4      	lsls	r4, r0, #31
     c22:	d40b      	bmi.n	c3c <pinMux+0x4c>
	{
		PMUX(Pin)&=0xF0;		//clr all lower bits
     c24:	085b      	lsrs	r3, r3, #1
     c26:	4d0d      	ldr	r5, [pc, #52]	; (c5c <pinMux+0x6c>)
     c28:	195b      	adds	r3, r3, r5
     c2a:	189a      	adds	r2, r3, r2
     c2c:	7813      	ldrb	r3, [r2, #0]
     c2e:	200f      	movs	r0, #15
     c30:	4383      	bics	r3, r0
     c32:	7013      	strb	r3, [r2, #0]
		PMUX(Pin)|= peripheral;	// place data in lower nibble
     c34:	7813      	ldrb	r3, [r2, #0]
     c36:	4319      	orrs	r1, r3
     c38:	7011      	strb	r1, [r2, #0]
     c3a:	e00c      	b.n	c56 <pinMux+0x66>
	} 
	else  {								//odd pin no. corresponds to higher nibble in Pmux register
		PMUX(Pin)&=0x0F;		//set all higher bits
     c3c:	085b      	lsrs	r3, r3, #1
     c3e:	4807      	ldr	r0, [pc, #28]	; (c5c <pinMux+0x6c>)
     c40:	181b      	adds	r3, r3, r0
     c42:	189b      	adds	r3, r3, r2
     c44:	7818      	ldrb	r0, [r3, #0]
     c46:	220f      	movs	r2, #15
     c48:	4002      	ands	r2, r0
     c4a:	701a      	strb	r2, [r3, #0]
		PMUX(Pin)|=(peripheral<<4);	// place data in higher nibble
     c4c:	781a      	ldrb	r2, [r3, #0]
     c4e:	0109      	lsls	r1, r1, #4
     c50:	4311      	orrs	r1, r2
     c52:	b2c9      	uxtb	r1, r1
     c54:	7019      	strb	r1, [r3, #0]
	}
}
     c56:	bd30      	pop	{r4, r5, pc}
     c58:	41004440 	.word	0x41004440
     c5c:	41004430 	.word	0x41004430

00000c60 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
     c60:	4b0c      	ldr	r3, [pc, #48]	; (c94 <cpu_irq_enter_critical+0x34>)
     c62:	681b      	ldr	r3, [r3, #0]
     c64:	2b00      	cmp	r3, #0
     c66:	d110      	bne.n	c8a <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     c68:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
     c6c:	2b00      	cmp	r3, #0
     c6e:	d109      	bne.n	c84 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
     c70:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
     c72:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
     c76:	2200      	movs	r2, #0
     c78:	4b07      	ldr	r3, [pc, #28]	; (c98 <cpu_irq_enter_critical+0x38>)
     c7a:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
     c7c:	2201      	movs	r2, #1
     c7e:	4b07      	ldr	r3, [pc, #28]	; (c9c <cpu_irq_enter_critical+0x3c>)
     c80:	701a      	strb	r2, [r3, #0]
     c82:	e002      	b.n	c8a <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
     c84:	2200      	movs	r2, #0
     c86:	4b05      	ldr	r3, [pc, #20]	; (c9c <cpu_irq_enter_critical+0x3c>)
     c88:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
     c8a:	4b02      	ldr	r3, [pc, #8]	; (c94 <cpu_irq_enter_critical+0x34>)
     c8c:	681a      	ldr	r2, [r3, #0]
     c8e:	3201      	adds	r2, #1
     c90:	601a      	str	r2, [r3, #0]
}
     c92:	4770      	bx	lr
     c94:	20000050 	.word	0x20000050
     c98:	20000000 	.word	0x20000000
     c9c:	20000054 	.word	0x20000054

00000ca0 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
     ca0:	4b08      	ldr	r3, [pc, #32]	; (cc4 <cpu_irq_leave_critical+0x24>)
     ca2:	681a      	ldr	r2, [r3, #0]
     ca4:	3a01      	subs	r2, #1
     ca6:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
     ca8:	681b      	ldr	r3, [r3, #0]
     caa:	2b00      	cmp	r3, #0
     cac:	d109      	bne.n	cc2 <cpu_irq_leave_critical+0x22>
     cae:	4b06      	ldr	r3, [pc, #24]	; (cc8 <cpu_irq_leave_critical+0x28>)
     cb0:	781b      	ldrb	r3, [r3, #0]
     cb2:	2b00      	cmp	r3, #0
     cb4:	d005      	beq.n	cc2 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
     cb6:	2201      	movs	r2, #1
     cb8:	4b04      	ldr	r3, [pc, #16]	; (ccc <cpu_irq_leave_critical+0x2c>)
     cba:	701a      	strb	r2, [r3, #0]
     cbc:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
     cc0:	b662      	cpsie	i
	}
}
     cc2:	4770      	bx	lr
     cc4:	20000050 	.word	0x20000050
     cc8:	20000054 	.word	0x20000054
     ccc:	20000000 	.word	0x20000000

00000cd0 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
     cd0:	b5f0      	push	{r4, r5, r6, r7, lr}
     cd2:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     cd4:	ac01      	add	r4, sp, #4
     cd6:	2501      	movs	r5, #1
     cd8:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
     cda:	2700      	movs	r7, #0
     cdc:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
     cde:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
     ce0:	203e      	movs	r0, #62	; 0x3e
     ce2:	1c21      	adds	r1, r4, #0
     ce4:	4e06      	ldr	r6, [pc, #24]	; (d00 <system_board_init+0x30>)
     ce6:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     ce8:	2280      	movs	r2, #128	; 0x80
     cea:	05d2      	lsls	r2, r2, #23
     cec:	4b05      	ldr	r3, [pc, #20]	; (d04 <system_board_init+0x34>)
     cee:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
     cf0:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
     cf2:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
     cf4:	200f      	movs	r0, #15
     cf6:	1c21      	adds	r1, r4, #0
     cf8:	47b0      	blx	r6
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
     cfa:	b003      	add	sp, #12
     cfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
     cfe:	46c0      	nop			; (mov r8, r8)
     d00:	00000d09 	.word	0x00000d09
     d04:	41004480 	.word	0x41004480

00000d08 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
     d08:	b500      	push	{lr}
     d0a:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     d0c:	ab01      	add	r3, sp, #4
     d0e:	2280      	movs	r2, #128	; 0x80
     d10:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
     d12:	780a      	ldrb	r2, [r1, #0]
     d14:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
     d16:	784a      	ldrb	r2, [r1, #1]
     d18:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
     d1a:	788a      	ldrb	r2, [r1, #2]
     d1c:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
     d1e:	1c19      	adds	r1, r3, #0
     d20:	4b01      	ldr	r3, [pc, #4]	; (d28 <port_pin_set_config+0x20>)
     d22:	4798      	blx	r3
}
     d24:	b003      	add	sp, #12
     d26:	bd00      	pop	{pc}
     d28:	000012f1 	.word	0x000012f1

00000d2c <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
     d2c:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
     d2e:	4b0c      	ldr	r3, [pc, #48]	; (d60 <system_clock_source_osc8m_set_config+0x34>)
     d30:	6a1c      	ldr	r4, [r3, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
     d32:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
     d34:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
     d36:	7840      	ldrb	r0, [r0, #1]
     d38:	2201      	movs	r2, #1
     d3a:	4010      	ands	r0, r2
     d3c:	0180      	lsls	r0, r0, #6
     d3e:	2640      	movs	r6, #64	; 0x40
     d40:	43b4      	bics	r4, r6
     d42:	4304      	orrs	r4, r0
     d44:	402a      	ands	r2, r5
     d46:	01d0      	lsls	r0, r2, #7
     d48:	2280      	movs	r2, #128	; 0x80
     d4a:	4394      	bics	r4, r2
     d4c:	1c22      	adds	r2, r4, #0
     d4e:	4302      	orrs	r2, r0
     d50:	2003      	movs	r0, #3
     d52:	4001      	ands	r1, r0
     d54:	0209      	lsls	r1, r1, #8
     d56:	4803      	ldr	r0, [pc, #12]	; (d64 <system_clock_source_osc8m_set_config+0x38>)
     d58:	4002      	ands	r2, r0
     d5a:	430a      	orrs	r2, r1
     d5c:	621a      	str	r2, [r3, #32]
}
     d5e:	bd70      	pop	{r4, r5, r6, pc}
     d60:	40000800 	.word	0x40000800
     d64:	fffffcff 	.word	0xfffffcff

00000d68 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
     d68:	b5f0      	push	{r4, r5, r6, r7, lr}
     d6a:	465f      	mov	r7, fp
     d6c:	4656      	mov	r6, sl
     d6e:	464d      	mov	r5, r9
     d70:	4644      	mov	r4, r8
     d72:	b4f0      	push	{r4, r5, r6, r7}
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
     d74:	4a25      	ldr	r2, [pc, #148]	; (e0c <system_clock_source_xosc32k_set_config+0xa4>)
     d76:	8a94      	ldrh	r4, [r2, #20]

	temp.bit.STARTUP = config->startup_time;
     d78:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
     d7a:	7803      	ldrb	r3, [r0, #0]
     d7c:	4259      	negs	r1, r3
     d7e:	4159      	adcs	r1, r3
     d80:	468a      	mov	sl, r1
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
     d82:	7883      	ldrb	r3, [r0, #2]
     d84:	469c      	mov	ip, r3
	temp.bit.EN1K = config->enable_1khz_output;
     d86:	78c1      	ldrb	r1, [r0, #3]
     d88:	4688      	mov	r8, r1
	temp.bit.EN32K = config->enable_32khz_output;
     d8a:	7903      	ldrb	r3, [r0, #4]
     d8c:	4699      	mov	r9, r3

	temp.bit.ONDEMAND = config->on_demand;
     d8e:	7b46      	ldrb	r6, [r0, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
     d90:	7b07      	ldrb	r7, [r0, #12]
	temp.bit.WRTLOCK  = config->write_once;
     d92:	7b81      	ldrb	r1, [r0, #14]
     d94:	468b      	mov	fp, r1

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
     d96:	6880      	ldr	r0, [r0, #8]
     d98:	4b1d      	ldr	r3, [pc, #116]	; (e10 <system_clock_source_xosc32k_set_config+0xa8>)
     d9a:	6158      	str	r0, [r3, #20]

	SYSCTRL->XOSC32K = temp;
     d9c:	2301      	movs	r3, #1
     d9e:	4651      	mov	r1, sl
     da0:	0088      	lsls	r0, r1, #2
     da2:	2104      	movs	r1, #4
     da4:	438c      	bics	r4, r1
     da6:	4304      	orrs	r4, r0
     da8:	4648      	mov	r0, r9
     daa:	4018      	ands	r0, r3
     dac:	00c0      	lsls	r0, r0, #3
     dae:	2108      	movs	r1, #8
     db0:	438c      	bics	r4, r1
     db2:	4304      	orrs	r4, r0
     db4:	4640      	mov	r0, r8
     db6:	4018      	ands	r0, r3
     db8:	0100      	lsls	r0, r0, #4
     dba:	2110      	movs	r1, #16
     dbc:	438c      	bics	r4, r1
     dbe:	4304      	orrs	r4, r0
     dc0:	4660      	mov	r0, ip
     dc2:	4018      	ands	r0, r3
     dc4:	0140      	lsls	r0, r0, #5
     dc6:	2120      	movs	r1, #32
     dc8:	438c      	bics	r4, r1
     dca:	4304      	orrs	r4, r0
     dcc:	1c18      	adds	r0, r3, #0
     dce:	4038      	ands	r0, r7
     dd0:	0180      	lsls	r0, r0, #6
     dd2:	2740      	movs	r7, #64	; 0x40
     dd4:	43bc      	bics	r4, r7
     dd6:	4304      	orrs	r4, r0
     dd8:	1c18      	adds	r0, r3, #0
     dda:	4030      	ands	r0, r6
     ddc:	01c0      	lsls	r0, r0, #7
     dde:	2680      	movs	r6, #128	; 0x80
     de0:	43b4      	bics	r4, r6
     de2:	4304      	orrs	r4, r0
     de4:	2007      	movs	r0, #7
     de6:	4028      	ands	r0, r5
     de8:	0200      	lsls	r0, r0, #8
     dea:	4d0a      	ldr	r5, [pc, #40]	; (e14 <system_clock_source_xosc32k_set_config+0xac>)
     dec:	402c      	ands	r4, r5
     dee:	4304      	orrs	r4, r0
     df0:	4659      	mov	r1, fp
     df2:	400b      	ands	r3, r1
     df4:	0319      	lsls	r1, r3, #12
     df6:	4808      	ldr	r0, [pc, #32]	; (e18 <system_clock_source_xosc32k_set_config+0xb0>)
     df8:	1c23      	adds	r3, r4, #0
     dfa:	4003      	ands	r3, r0
     dfc:	430b      	orrs	r3, r1
     dfe:	8293      	strh	r3, [r2, #20]
}
     e00:	bc3c      	pop	{r2, r3, r4, r5}
     e02:	4690      	mov	r8, r2
     e04:	4699      	mov	r9, r3
     e06:	46a2      	mov	sl, r4
     e08:	46ab      	mov	fp, r5
     e0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e0c:	40000800 	.word	0x40000800
     e10:	20000058 	.word	0x20000058
     e14:	fffff8ff 	.word	0xfffff8ff
     e18:	ffffefff 	.word	0xffffefff

00000e1c <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
     e1c:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
     e1e:	7a02      	ldrb	r2, [r0, #8]
     e20:	0692      	lsls	r2, r2, #26
     e22:	0c12      	lsrs	r2, r2, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
     e24:	8943      	ldrh	r3, [r0, #10]
     e26:	059b      	lsls	r3, r3, #22
     e28:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
     e2a:	431a      	orrs	r2, r3
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
     e2c:	4b15      	ldr	r3, [pc, #84]	; (e84 <system_clock_source_dfll_set_config+0x68>)
     e2e:	605a      	str	r2, [r3, #4]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
     e30:	8881      	ldrh	r1, [r0, #4]
     e32:	8842      	ldrh	r2, [r0, #2]
     e34:	4311      	orrs	r1, r2
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
     e36:	79c4      	ldrb	r4, [r0, #7]
     e38:	7982      	ldrb	r2, [r0, #6]
     e3a:	4322      	orrs	r2, r4
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
     e3c:	430a      	orrs	r2, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
     e3e:	7841      	ldrb	r1, [r0, #1]
     e40:	01c9      	lsls	r1, r1, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
     e42:	430a      	orrs	r2, r1
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
     e44:	601a      	str	r2, [r3, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
     e46:	7803      	ldrb	r3, [r0, #0]
     e48:	2b04      	cmp	r3, #4
     e4a:	d10f      	bne.n	e6c <system_clock_source_dfll_set_config+0x50>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
     e4c:	7b02      	ldrb	r2, [r0, #12]
     e4e:	0692      	lsls	r2, r2, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
     e50:	8a03      	ldrh	r3, [r0, #16]
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
     e52:	431a      	orrs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
     e54:	89c3      	ldrh	r3, [r0, #14]
     e56:	041b      	lsls	r3, r3, #16
     e58:	490b      	ldr	r1, [pc, #44]	; (e88 <system_clock_source_dfll_set_config+0x6c>)
     e5a:	400b      	ands	r3, r1
     e5c:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
     e5e:	4b09      	ldr	r3, [pc, #36]	; (e84 <system_clock_source_dfll_set_config+0x68>)
     e60:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
     e62:	6819      	ldr	r1, [r3, #0]
     e64:	2204      	movs	r2, #4
     e66:	430a      	orrs	r2, r1
     e68:	601a      	str	r2, [r3, #0]
     e6a:	e009      	b.n	e80 <system_clock_source_dfll_set_config+0x64>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
     e6c:	2b20      	cmp	r3, #32
     e6e:	d107      	bne.n	e80 <system_clock_source_dfll_set_config+0x64>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
     e70:	8a02      	ldrh	r2, [r0, #16]
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
     e72:	4b04      	ldr	r3, [pc, #16]	; (e84 <system_clock_source_dfll_set_config+0x68>)
     e74:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
     e76:	6819      	ldr	r1, [r3, #0]
     e78:	2284      	movs	r2, #132	; 0x84
     e7a:	00d2      	lsls	r2, r2, #3
     e7c:	430a      	orrs	r2, r1
     e7e:	601a      	str	r2, [r3, #0]
				SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
     e80:	bd10      	pop	{r4, pc}
     e82:	46c0      	nop			; (mov r8, r8)
     e84:	20000058 	.word	0x20000058
     e88:	03ff0000 	.word	0x03ff0000

00000e8c <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
     e8c:	2808      	cmp	r0, #8
     e8e:	d843      	bhi.n	f18 <system_clock_source_enable+0x8c>
     e90:	0080      	lsls	r0, r0, #2
     e92:	4b22      	ldr	r3, [pc, #136]	; (f1c <system_clock_source_enable+0x90>)
     e94:	581b      	ldr	r3, [r3, r0]
     e96:	469f      	mov	pc, r3
		break;
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
     e98:	2000      	movs	r0, #0
     e9a:	e03e      	b.n	f1a <system_clock_source_enable+0x8e>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
     e9c:	4b20      	ldr	r3, [pc, #128]	; (f20 <system_clock_source_enable+0x94>)
     e9e:	6a19      	ldr	r1, [r3, #32]
     ea0:	2202      	movs	r2, #2
     ea2:	430a      	orrs	r2, r1
     ea4:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
     ea6:	2000      	movs	r0, #0
     ea8:	e037      	b.n	f1a <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
     eaa:	4b1d      	ldr	r3, [pc, #116]	; (f20 <system_clock_source_enable+0x94>)
     eac:	6999      	ldr	r1, [r3, #24]
     eae:	2202      	movs	r2, #2
     eb0:	430a      	orrs	r2, r1
     eb2:	619a      	str	r2, [r3, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     eb4:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
     eb6:	e030      	b.n	f1a <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
     eb8:	4b19      	ldr	r3, [pc, #100]	; (f20 <system_clock_source_enable+0x94>)
     eba:	8a19      	ldrh	r1, [r3, #16]
     ebc:	2202      	movs	r2, #2
     ebe:	430a      	orrs	r2, r1
     ec0:	821a      	strh	r2, [r3, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     ec2:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
     ec4:	e029      	b.n	f1a <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
     ec6:	4b16      	ldr	r3, [pc, #88]	; (f20 <system_clock_source_enable+0x94>)
     ec8:	8a99      	ldrh	r1, [r3, #20]
     eca:	2202      	movs	r2, #2
     ecc:	430a      	orrs	r2, r1
     ece:	829a      	strh	r2, [r3, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     ed0:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
     ed2:	e022      	b.n	f1a <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
     ed4:	4b13      	ldr	r3, [pc, #76]	; (f24 <system_clock_source_enable+0x98>)
     ed6:	6819      	ldr	r1, [r3, #0]
     ed8:	2202      	movs	r2, #2
     eda:	430a      	orrs	r2, r1
     edc:	601a      	str	r2, [r3, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
     ede:	681a      	ldr	r2, [r3, #0]
     ee0:	4b11      	ldr	r3, [pc, #68]	; (f28 <system_clock_source_enable+0x9c>)
     ee2:	401a      	ands	r2, r3
     ee4:	4b0e      	ldr	r3, [pc, #56]	; (f20 <system_clock_source_enable+0x94>)
     ee6:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
     ee8:	1c19      	adds	r1, r3, #0
     eea:	2210      	movs	r2, #16
     eec:	68cb      	ldr	r3, [r1, #12]
     eee:	421a      	tst	r2, r3
     ef0:	d0fc      	beq.n	eec <system_clock_source_enable+0x60>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
     ef2:	4a0c      	ldr	r2, [pc, #48]	; (f24 <system_clock_source_enable+0x98>)
     ef4:	6891      	ldr	r1, [r2, #8]
     ef6:	4b0a      	ldr	r3, [pc, #40]	; (f20 <system_clock_source_enable+0x94>)
     ef8:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
     efa:	6851      	ldr	r1, [r2, #4]
     efc:	6299      	str	r1, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
     efe:	6812      	ldr	r2, [r2, #0]
     f00:	b292      	uxth	r2, r2
     f02:	849a      	strh	r2, [r3, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     f04:	2000      	movs	r0, #0
     f06:	e008      	b.n	f1a <system_clock_source_enable+0x8e>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
     f08:	4a05      	ldr	r2, [pc, #20]	; (f20 <system_clock_source_enable+0x94>)
     f0a:	2344      	movs	r3, #68	; 0x44
     f0c:	5cd0      	ldrb	r0, [r2, r3]
     f0e:	2102      	movs	r1, #2
     f10:	4301      	orrs	r1, r0
     f12:	54d1      	strb	r1, [r2, r3]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
     f14:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
     f16:	e000      	b.n	f1a <system_clock_source_enable+0x8e>
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
     f18:	2017      	movs	r0, #23
	}

	return STATUS_OK;
}
     f1a:	4770      	bx	lr
     f1c:	00001630 	.word	0x00001630
     f20:	40000800 	.word	0x40000800
     f24:	20000058 	.word	0x20000058
     f28:	0000ff7f 	.word	0x0000ff7f

00000f2c <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
     f2c:	b5f0      	push	{r4, r5, r6, r7, lr}
     f2e:	b08f      	sub	sp, #60	; 0x3c
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
     f30:	22c2      	movs	r2, #194	; 0xc2
     f32:	00d2      	lsls	r2, r2, #3
     f34:	4b4b      	ldr	r3, [pc, #300]	; (1064 <system_clock_init+0x138>)
     f36:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
     f38:	4b4b      	ldr	r3, [pc, #300]	; (1068 <system_clock_init+0x13c>)
     f3a:	685a      	ldr	r2, [r3, #4]
     f3c:	211e      	movs	r1, #30
     f3e:	438a      	bics	r2, r1
     f40:	2104      	movs	r1, #4
     f42:	430a      	orrs	r2, r1
     f44:	605a      	str	r2, [r3, #4]
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
     f46:	2202      	movs	r2, #2
     f48:	ab01      	add	r3, sp, #4
     f4a:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
     f4c:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
     f4e:	4d47      	ldr	r5, [pc, #284]	; (106c <system_clock_init+0x140>)
     f50:	b2e0      	uxtb	r0, r4
     f52:	a901      	add	r1, sp, #4
     f54:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
     f56:	3401      	adds	r4, #1
     f58:	2c25      	cmp	r4, #37	; 0x25
     f5a:	d1f9      	bne.n	f50 <system_clock_init+0x24>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
     f5c:	a80a      	add	r0, sp, #40	; 0x28
     f5e:	2300      	movs	r3, #0
     f60:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
     f62:	2204      	movs	r2, #4
     f64:	7042      	strb	r2, [r0, #1]
	config->auto_gain_control   = false;
     f66:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
     f68:	2280      	movs	r2, #128	; 0x80
     f6a:	0212      	lsls	r2, r2, #8
     f6c:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
     f6e:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
     f70:	2201      	movs	r2, #1
     f72:	7102      	strb	r2, [r0, #4]
	config->run_in_standby      = false;
     f74:	7303      	strb	r3, [r0, #12]
	config->on_demand           = true;
	config->write_once          = false;
     f76:	7383      	strb	r3, [r0, #14]
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
     f78:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
     f7a:	466a      	mov	r2, sp
     f7c:	84d3      	strh	r3, [r2, #38]	; 0x26
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
     f7e:	4b3c      	ldr	r3, [pc, #240]	; (1070 <system_clock_init+0x144>)
     f80:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
     f82:	2005      	movs	r0, #5
     f84:	4b3b      	ldr	r3, [pc, #236]	; (1074 <system_clock_init+0x148>)
     f86:	4798      	blx	r3

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
     f88:	4836      	ldr	r0, [pc, #216]	; (1064 <system_clock_init+0x138>)
     f8a:	2102      	movs	r1, #2
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
		XOSC32RDYCount++;
     f8c:	466b      	mov	r3, sp
     f8e:	3326      	adds	r3, #38	; 0x26
		if(XOSC32RDYCount>60000){
     f90:	4c39      	ldr	r4, [pc, #228]	; (1078 <system_clock_init+0x14c>)
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
     f92:	e00b      	b.n	fac <system_clock_init+0x80>
		XOSC32RDYCount++;
     f94:	881a      	ldrh	r2, [r3, #0]
     f96:	3201      	adds	r2, #1
     f98:	b292      	uxth	r2, r2
     f9a:	801a      	strh	r2, [r3, #0]
		if(XOSC32RDYCount>60000){
     f9c:	881a      	ldrh	r2, [r3, #0]
     f9e:	b292      	uxth	r2, r2
     fa0:	42a2      	cmp	r2, r4
     fa2:	d903      	bls.n	fac <system_clock_init+0x80>
			XOSC32Fail=1;
     fa4:	2201      	movs	r2, #1
     fa6:	4b35      	ldr	r3, [pc, #212]	; (107c <system_clock_init+0x150>)
     fa8:	701a      	strb	r2, [r3, #0]
			break;
     faa:	e002      	b.n	fb2 <system_clock_init+0x86>

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
     fac:	68c2      	ldr	r2, [r0, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
     fae:	4211      	tst	r1, r2
     fb0:	d0f0      	beq.n	f94 <system_clock_init+0x68>
			XOSC32Fail=1;
			break;
		}
		}			//sajid here it waits for XOSC32
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
     fb2:	4b2c      	ldr	r3, [pc, #176]	; (1064 <system_clock_init+0x138>)
     fb4:	8a99      	ldrh	r1, [r3, #20]
     fb6:	2280      	movs	r2, #128	; 0x80
     fb8:	430a      	orrs	r2, r1
     fba:	829a      	strh	r2, [r3, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
     fbc:	a805      	add	r0, sp, #20
     fbe:	2300      	movs	r3, #0
     fc0:	2500      	movs	r5, #0
     fc2:	8043      	strh	r3, [r0, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
     fc4:	8083      	strh	r3, [r0, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
     fc6:	7185      	strb	r5, [r0, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
     fc8:	71c5      	strb	r5, [r0, #7]
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
     fca:	2207      	movs	r2, #7
     fcc:	7202      	strb	r2, [r0, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
     fce:	233f      	movs	r3, #63	; 0x3f
     fd0:	8143      	strh	r3, [r0, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
     fd2:	2104      	movs	r1, #4
     fd4:	7001      	strb	r1, [r0, #0]
	dfll_conf.on_demand      = false;
     fd6:	7045      	strb	r5, [r0, #1]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
     fd8:	4929      	ldr	r1, [pc, #164]	; (1080 <system_clock_init+0x154>)
     fda:	8201      	strh	r1, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
     fdc:	7302      	strb	r2, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
     fde:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
     fe0:	4b28      	ldr	r3, [pc, #160]	; (1084 <system_clock_init+0x158>)
     fe2:	4798      	blx	r3
		struct system_clock_source_osc8m_config *const config)
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
     fe4:	a804      	add	r0, sp, #16
     fe6:	7045      	strb	r5, [r0, #1]
	config->on_demand       = true;
     fe8:	2601      	movs	r6, #1
     fea:	7086      	strb	r6, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
     fec:	7005      	strb	r5, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
     fee:	4b26      	ldr	r3, [pc, #152]	; (1088 <system_clock_init+0x15c>)
     ff0:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
     ff2:	2006      	movs	r0, #6
     ff4:	4f1f      	ldr	r7, [pc, #124]	; (1074 <system_clock_init+0x148>)
     ff6:	47b8      	blx	r7


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
     ff8:	4b24      	ldr	r3, [pc, #144]	; (108c <system_clock_init+0x160>)
     ffa:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
     ffc:	ac01      	add	r4, sp, #4
     ffe:	9602      	str	r6, [sp, #8]
	config->high_when_disabled = false;
    1000:	7065      	strb	r5, [r4, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    1002:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
    1004:	7265      	strb	r5, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(8, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    1006:	2305      	movs	r3, #5
    1008:	7023      	strb	r3, [r4, #0]
    100a:	2001      	movs	r0, #1
    100c:	1c21      	adds	r1, r4, #0
    100e:	4b20      	ldr	r3, [pc, #128]	; (1090 <system_clock_init+0x164>)
    1010:	4798      	blx	r3
    1012:	2001      	movs	r0, #1
    1014:	4b1f      	ldr	r3, [pc, #124]	; (1094 <system_clock_init+0x168>)
    1016:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    1018:	7026      	strb	r6, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    101a:	2000      	movs	r0, #0
    101c:	1c21      	adds	r1, r4, #0
    101e:	4b13      	ldr	r3, [pc, #76]	; (106c <system_clock_init+0x140>)
    1020:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    1022:	2000      	movs	r0, #0
    1024:	4b1c      	ldr	r3, [pc, #112]	; (1098 <system_clock_init+0x16c>)
    1026:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    1028:	2007      	movs	r0, #7
    102a:	47b8      	blx	r7

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    102c:	490d      	ldr	r1, [pc, #52]	; (1064 <system_clock_init+0x138>)
    102e:	22d0      	movs	r2, #208	; 0xd0
    1030:	68cb      	ldr	r3, [r1, #12]
    1032:	4013      	ands	r3, r2


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    1034:	2bd0      	cmp	r3, #208	; 0xd0
    1036:	d1fb      	bne.n	1030 <system_clock_init+0x104>
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    1038:	4a18      	ldr	r2, [pc, #96]	; (109c <system_clock_init+0x170>)
    103a:	2300      	movs	r3, #0
    103c:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    103e:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    1040:	7293      	strb	r3, [r2, #10]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    1042:	a901      	add	r1, sp, #4
    1044:	2201      	movs	r2, #1
    1046:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
    1048:	704b      	strb	r3, [r1, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    104a:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    104c:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    104e:	2307      	movs	r3, #7
    1050:	700b      	strb	r3, [r1, #0]
    1052:	2000      	movs	r0, #0
    1054:	4b0e      	ldr	r3, [pc, #56]	; (1090 <system_clock_init+0x164>)
    1056:	4798      	blx	r3
    1058:	2000      	movs	r0, #0
    105a:	4b0e      	ldr	r3, [pc, #56]	; (1094 <system_clock_init+0x168>)
    105c:	4798      	blx	r3
#endif
}
    105e:	b00f      	add	sp, #60	; 0x3c
    1060:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1062:	46c0      	nop			; (mov r8, r8)
    1064:	40000800 	.word	0x40000800
    1068:	41004000 	.word	0x41004000
    106c:	00001249 	.word	0x00001249
    1070:	00000d69 	.word	0x00000d69
    1074:	00000e8d 	.word	0x00000e8d
    1078:	0000ea60 	.word	0x0000ea60
    107c:	20000070 	.word	0x20000070
    1080:	000005b9 	.word	0x000005b9
    1084:	00000e1d 	.word	0x00000e1d
    1088:	00000d2d 	.word	0x00000d2d
    108c:	000010a1 	.word	0x000010a1
    1090:	000010c5 	.word	0x000010c5
    1094:	00001179 	.word	0x00001179
    1098:	000011bd 	.word	0x000011bd
    109c:	40000400 	.word	0x40000400

000010a0 <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    10a0:	4b06      	ldr	r3, [pc, #24]	; (10bc <system_gclk_init+0x1c>)
    10a2:	6999      	ldr	r1, [r3, #24]
    10a4:	2208      	movs	r2, #8
    10a6:	430a      	orrs	r2, r1
    10a8:	619a      	str	r2, [r3, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    10aa:	2201      	movs	r2, #1
    10ac:	4b04      	ldr	r3, [pc, #16]	; (10c0 <system_gclk_init+0x20>)
    10ae:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    10b0:	1c19      	adds	r1, r3, #0
    10b2:	780b      	ldrb	r3, [r1, #0]
    10b4:	4213      	tst	r3, r2
    10b6:	d1fc      	bne.n	10b2 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    10b8:	4770      	bx	lr
    10ba:	46c0      	nop			; (mov r8, r8)
    10bc:	40000400 	.word	0x40000400
    10c0:	40000c00 	.word	0x40000c00

000010c4 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    10c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    10c6:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    10c8:	1c07      	adds	r7, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    10ca:	780d      	ldrb	r5, [r1, #0]
    10cc:	022d      	lsls	r5, r5, #8
    10ce:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    10d0:	784b      	ldrb	r3, [r1, #1]
    10d2:	2b00      	cmp	r3, #0
    10d4:	d002      	beq.n	10dc <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    10d6:	2380      	movs	r3, #128	; 0x80
    10d8:	02db      	lsls	r3, r3, #11
    10da:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    10dc:	7a4b      	ldrb	r3, [r1, #9]
    10de:	2b00      	cmp	r3, #0
    10e0:	d002      	beq.n	10e8 <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    10e2:	2380      	movs	r3, #128	; 0x80
    10e4:	031b      	lsls	r3, r3, #12
    10e6:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    10e8:	684c      	ldr	r4, [r1, #4]
    10ea:	2c01      	cmp	r4, #1
    10ec:	d917      	bls.n	111e <system_gclk_gen_set_config+0x5a>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    10ee:	1e63      	subs	r3, r4, #1
    10f0:	421c      	tst	r4, r3
    10f2:	d10f      	bne.n	1114 <system_gclk_gen_set_config+0x50>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    10f4:	2c02      	cmp	r4, #2
    10f6:	d906      	bls.n	1106 <system_gclk_gen_set_config+0x42>
    10f8:	2302      	movs	r3, #2
    10fa:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    10fc:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    10fe:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    1100:	429c      	cmp	r4, r3
    1102:	d8fb      	bhi.n	10fc <system_gclk_gen_set_config+0x38>
    1104:	e000      	b.n	1108 <system_gclk_gen_set_config+0x44>
    1106:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    1108:	0217      	lsls	r7, r2, #8
    110a:	4337      	orrs	r7, r6
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    110c:	2380      	movs	r3, #128	; 0x80
    110e:	035b      	lsls	r3, r3, #13
    1110:	431d      	orrs	r5, r3
    1112:	e004      	b.n	111e <system_gclk_gen_set_config+0x5a>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    1114:	0227      	lsls	r7, r4, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    1116:	4337      	orrs	r7, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    1118:	2380      	movs	r3, #128	; 0x80
    111a:	029b      	lsls	r3, r3, #10
    111c:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    111e:	7a0b      	ldrb	r3, [r1, #8]
    1120:	2b00      	cmp	r3, #0
    1122:	d002      	beq.n	112a <system_gclk_gen_set_config+0x66>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    1124:	2380      	movs	r3, #128	; 0x80
    1126:	039b      	lsls	r3, r3, #14
    1128:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    112a:	4a0f      	ldr	r2, [pc, #60]	; (1168 <system_gclk_gen_set_config+0xa4>)
    112c:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
    112e:	b25b      	sxtb	r3, r3
    1130:	2b00      	cmp	r3, #0
    1132:	dbfb      	blt.n	112c <system_gclk_gen_set_config+0x68>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1134:	4b0d      	ldr	r3, [pc, #52]	; (116c <system_gclk_gen_set_config+0xa8>)
    1136:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1138:	4b0d      	ldr	r3, [pc, #52]	; (1170 <system_gclk_gen_set_config+0xac>)
    113a:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    113c:	4a0a      	ldr	r2, [pc, #40]	; (1168 <system_gclk_gen_set_config+0xa4>)
    113e:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    1140:	b25b      	sxtb	r3, r3
    1142:	2b00      	cmp	r3, #0
    1144:	dbfb      	blt.n	113e <system_gclk_gen_set_config+0x7a>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    1146:	4b08      	ldr	r3, [pc, #32]	; (1168 <system_gclk_gen_set_config+0xa4>)
    1148:	609f      	str	r7, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    114a:	1c1a      	adds	r2, r3, #0
    114c:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
    114e:	b25b      	sxtb	r3, r3
    1150:	2b00      	cmp	r3, #0
    1152:	dbfb      	blt.n	114c <system_gclk_gen_set_config+0x88>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    1154:	4b04      	ldr	r3, [pc, #16]	; (1168 <system_gclk_gen_set_config+0xa4>)
    1156:	6859      	ldr	r1, [r3, #4]
    1158:	2280      	movs	r2, #128	; 0x80
    115a:	0252      	lsls	r2, r2, #9
    115c:	400a      	ands	r2, r1
    115e:	4315      	orrs	r5, r2
    1160:	605d      	str	r5, [r3, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1162:	4b04      	ldr	r3, [pc, #16]	; (1174 <system_gclk_gen_set_config+0xb0>)
    1164:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1168:	40000c00 	.word	0x40000c00
    116c:	00000c61 	.word	0x00000c61
    1170:	40000c08 	.word	0x40000c08
    1174:	00000ca1 	.word	0x00000ca1

00001178 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    1178:	b510      	push	{r4, lr}
    117a:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    117c:	4a0b      	ldr	r2, [pc, #44]	; (11ac <system_gclk_gen_enable+0x34>)
    117e:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    1180:	b25b      	sxtb	r3, r3
    1182:	2b00      	cmp	r3, #0
    1184:	dbfb      	blt.n	117e <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1186:	4b0a      	ldr	r3, [pc, #40]	; (11b0 <system_gclk_gen_enable+0x38>)
    1188:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    118a:	4b0a      	ldr	r3, [pc, #40]	; (11b4 <system_gclk_gen_enable+0x3c>)
    118c:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    118e:	4a07      	ldr	r2, [pc, #28]	; (11ac <system_gclk_gen_enable+0x34>)
    1190:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    1192:	b25b      	sxtb	r3, r3
    1194:	2b00      	cmp	r3, #0
    1196:	dbfb      	blt.n	1190 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    1198:	4b04      	ldr	r3, [pc, #16]	; (11ac <system_gclk_gen_enable+0x34>)
    119a:	6859      	ldr	r1, [r3, #4]
    119c:	2280      	movs	r2, #128	; 0x80
    119e:	0252      	lsls	r2, r2, #9
    11a0:	430a      	orrs	r2, r1
    11a2:	605a      	str	r2, [r3, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    11a4:	4b04      	ldr	r3, [pc, #16]	; (11b8 <system_gclk_gen_enable+0x40>)
    11a6:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    11a8:	bd10      	pop	{r4, pc}
    11aa:	46c0      	nop			; (mov r8, r8)
    11ac:	40000c00 	.word	0x40000c00
    11b0:	00000c61 	.word	0x00000c61
    11b4:	40000c04 	.word	0x40000c04
    11b8:	00000ca1 	.word	0x00000ca1

000011bc <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    11bc:	b510      	push	{r4, lr}
    11be:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    11c0:	4b06      	ldr	r3, [pc, #24]	; (11dc <system_gclk_chan_enable+0x20>)
    11c2:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    11c4:	4b06      	ldr	r3, [pc, #24]	; (11e0 <system_gclk_chan_enable+0x24>)
    11c6:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    11c8:	4b06      	ldr	r3, [pc, #24]	; (11e4 <system_gclk_chan_enable+0x28>)
    11ca:	8859      	ldrh	r1, [r3, #2]
    11cc:	2280      	movs	r2, #128	; 0x80
    11ce:	01d2      	lsls	r2, r2, #7
    11d0:	430a      	orrs	r2, r1
    11d2:	805a      	strh	r2, [r3, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    11d4:	4b04      	ldr	r3, [pc, #16]	; (11e8 <system_gclk_chan_enable+0x2c>)
    11d6:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    11d8:	bd10      	pop	{r4, pc}
    11da:	46c0      	nop			; (mov r8, r8)
    11dc:	00000c61 	.word	0x00000c61
    11e0:	40000c02 	.word	0x40000c02
    11e4:	40000c00 	.word	0x40000c00
    11e8:	00000ca1 	.word	0x00000ca1

000011ec <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    11ec:	b510      	push	{r4, lr}
    11ee:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    11f0:	4b0f      	ldr	r3, [pc, #60]	; (1230 <system_gclk_chan_disable+0x44>)
    11f2:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    11f4:	4b0f      	ldr	r3, [pc, #60]	; (1234 <system_gclk_chan_disable+0x48>)
    11f6:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    11f8:	4b0f      	ldr	r3, [pc, #60]	; (1238 <system_gclk_chan_disable+0x4c>)
    11fa:	8858      	ldrh	r0, [r3, #2]
    11fc:	0500      	lsls	r0, r0, #20
    11fe:	0f00      	lsrs	r0, r0, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    1200:	8859      	ldrh	r1, [r3, #2]
    1202:	4a0e      	ldr	r2, [pc, #56]	; (123c <system_gclk_chan_disable+0x50>)
    1204:	400a      	ands	r2, r1
    1206:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    1208:	8859      	ldrh	r1, [r3, #2]
    120a:	4a0d      	ldr	r2, [pc, #52]	; (1240 <system_gclk_chan_disable+0x54>)
    120c:	400a      	ands	r2, r1
    120e:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    1210:	1c19      	adds	r1, r3, #0
    1212:	2280      	movs	r2, #128	; 0x80
    1214:	01d2      	lsls	r2, r2, #7
    1216:	884b      	ldrh	r3, [r1, #2]
    1218:	4213      	tst	r3, r2
    121a:	d1fc      	bne.n	1216 <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    121c:	4b06      	ldr	r3, [pc, #24]	; (1238 <system_gclk_chan_disable+0x4c>)
    121e:	0201      	lsls	r1, r0, #8
    1220:	8858      	ldrh	r0, [r3, #2]
    1222:	4a06      	ldr	r2, [pc, #24]	; (123c <system_gclk_chan_disable+0x50>)
    1224:	4002      	ands	r2, r0
    1226:	430a      	orrs	r2, r1
    1228:	805a      	strh	r2, [r3, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    122a:	4b06      	ldr	r3, [pc, #24]	; (1244 <system_gclk_chan_disable+0x58>)
    122c:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    122e:	bd10      	pop	{r4, pc}
    1230:	00000c61 	.word	0x00000c61
    1234:	40000c02 	.word	0x40000c02
    1238:	40000c00 	.word	0x40000c00
    123c:	fffff0ff 	.word	0xfffff0ff
    1240:	ffffbfff 	.word	0xffffbfff
    1244:	00000ca1 	.word	0x00000ca1

00001248 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    1248:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    124a:	780c      	ldrb	r4, [r1, #0]
    124c:	0224      	lsls	r4, r4, #8
    124e:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    1250:	4b02      	ldr	r3, [pc, #8]	; (125c <system_gclk_chan_set_config+0x14>)
    1252:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    1254:	b2a4      	uxth	r4, r4
    1256:	4b02      	ldr	r3, [pc, #8]	; (1260 <system_gclk_chan_set_config+0x18>)
    1258:	805c      	strh	r4, [r3, #2]
}
    125a:	bd10      	pop	{r4, pc}
    125c:	000011ed 	.word	0x000011ed
    1260:	40000c00 	.word	0x40000c00

00001264 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    1264:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    1266:	78d3      	ldrb	r3, [r2, #3]
    1268:	2b00      	cmp	r3, #0
    126a:	d11e      	bne.n	12aa <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    126c:	7813      	ldrb	r3, [r2, #0]
    126e:	2b80      	cmp	r3, #128	; 0x80
    1270:	d004      	beq.n	127c <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    1272:	061b      	lsls	r3, r3, #24
    1274:	2480      	movs	r4, #128	; 0x80
    1276:	0264      	lsls	r4, r4, #9
    1278:	4323      	orrs	r3, r4
    127a:	e000      	b.n	127e <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    127c:	2300      	movs	r3, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    127e:	7854      	ldrb	r4, [r2, #1]
    1280:	2502      	movs	r5, #2
    1282:	43ac      	bics	r4, r5
    1284:	d10a      	bne.n	129c <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    1286:	7894      	ldrb	r4, [r2, #2]
    1288:	2c00      	cmp	r4, #0
    128a:	d103      	bne.n	1294 <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    128c:	2480      	movs	r4, #128	; 0x80
    128e:	02a4      	lsls	r4, r4, #10
    1290:	4323      	orrs	r3, r4
    1292:	e002      	b.n	129a <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    1294:	24c0      	movs	r4, #192	; 0xc0
    1296:	02e4      	lsls	r4, r4, #11
    1298:	4323      	orrs	r3, r4
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    129a:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    129c:	7854      	ldrb	r4, [r2, #1]
    129e:	3c01      	subs	r4, #1
    12a0:	2c01      	cmp	r4, #1
    12a2:	d804      	bhi.n	12ae <_system_pinmux_config+0x4a>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pullup if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    12a4:	4c11      	ldr	r4, [pc, #68]	; (12ec <_system_pinmux_config+0x88>)
    12a6:	4023      	ands	r3, r4
    12a8:	e001      	b.n	12ae <_system_pinmux_config+0x4a>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    12aa:	6041      	str	r1, [r0, #4]
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    12ac:	2300      	movs	r3, #0
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    12ae:	040d      	lsls	r5, r1, #16
    12b0:	0c2d      	lsrs	r5, r5, #16
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    12b2:	24a0      	movs	r4, #160	; 0xa0
    12b4:	05e4      	lsls	r4, r4, #23
    12b6:	432c      	orrs	r4, r5
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    12b8:	431c      	orrs	r4, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    12ba:	6284      	str	r4, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    12bc:	0c0d      	lsrs	r5, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    12be:	24d0      	movs	r4, #208	; 0xd0
    12c0:	0624      	lsls	r4, r4, #24
    12c2:	432c      	orrs	r4, r5
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    12c4:	431c      	orrs	r4, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    12c6:	6284      	str	r4, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    12c8:	78d4      	ldrb	r4, [r2, #3]
    12ca:	2c00      	cmp	r4, #0
    12cc:	d10c      	bne.n	12e8 <_system_pinmux_config+0x84>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    12ce:	035c      	lsls	r4, r3, #13
    12d0:	d505      	bpl.n	12de <_system_pinmux_config+0x7a>
			/* Set the OUT register bits to enable the pullup if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    12d2:	7893      	ldrb	r3, [r2, #2]
    12d4:	2b01      	cmp	r3, #1
    12d6:	d101      	bne.n	12dc <_system_pinmux_config+0x78>
				port->OUTSET.reg = pin_mask;
    12d8:	6181      	str	r1, [r0, #24]
    12da:	e000      	b.n	12de <_system_pinmux_config+0x7a>
			} else {
				port->OUTCLR.reg = pin_mask;
    12dc:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    12de:	7853      	ldrb	r3, [r2, #1]
    12e0:	3b01      	subs	r3, #1
    12e2:	2b01      	cmp	r3, #1
    12e4:	d800      	bhi.n	12e8 <_system_pinmux_config+0x84>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    12e6:	6081      	str	r1, [r0, #8]
		}
	}
}
    12e8:	bd30      	pop	{r4, r5, pc}
    12ea:	46c0      	nop			; (mov r8, r8)
    12ec:	fffbffff 	.word	0xfffbffff

000012f0 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    12f0:	b508      	push	{r3, lr}
    12f2:	1c03      	adds	r3, r0, #0
    12f4:	1c0a      	adds	r2, r1, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    12f6:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    12f8:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    12fa:	2900      	cmp	r1, #0
    12fc:	d103      	bne.n	1306 <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
    12fe:	0958      	lsrs	r0, r3, #5
    1300:	01c0      	lsls	r0, r0, #7
    1302:	4904      	ldr	r1, [pc, #16]	; (1314 <system_pinmux_pin_set_config+0x24>)
    1304:	1840      	adds	r0, r0, r1
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    1306:	211f      	movs	r1, #31
    1308:	400b      	ands	r3, r1
    130a:	2101      	movs	r1, #1
    130c:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
    130e:	4b02      	ldr	r3, [pc, #8]	; (1318 <system_pinmux_pin_set_config+0x28>)
    1310:	4798      	blx	r3
}
    1312:	bd08      	pop	{r3, pc}
    1314:	41004400 	.word	0x41004400
    1318:	00001265 	.word	0x00001265

0000131c <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    131c:	4770      	bx	lr
    131e:	46c0      	nop			; (mov r8, r8)

00001320 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    1320:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    1322:	4b04      	ldr	r3, [pc, #16]	; (1334 <system_init+0x14>)
    1324:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    1326:	4b04      	ldr	r3, [pc, #16]	; (1338 <system_init+0x18>)
    1328:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    132a:	4b04      	ldr	r3, [pc, #16]	; (133c <system_init+0x1c>)
    132c:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    132e:	4b04      	ldr	r3, [pc, #16]	; (1340 <system_init+0x20>)
    1330:	4798      	blx	r3
}
    1332:	bd08      	pop	{r3, pc}
    1334:	00000f2d 	.word	0x00000f2d
    1338:	00000cd1 	.word	0x00000cd1
    133c:	0000131d 	.word	0x0000131d
    1340:	0000131d 	.word	0x0000131d

00001344 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    1344:	e7fe      	b.n	1344 <Dummy_Handler>
    1346:	46c0      	nop			; (mov r8, r8)

00001348 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    1348:	b570      	push	{r4, r5, r6, lr}
        uint32_t *pSrc, *pDest;

        /* Change default QOS values to have the best performance and correct USB behavior */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    134a:	2102      	movs	r1, #2
    134c:	2390      	movs	r3, #144	; 0x90
    134e:	005b      	lsls	r3, r3, #1
    1350:	4a28      	ldr	r2, [pc, #160]	; (13f4 <Reset_Handler+0xac>)
    1352:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    1354:	4b28      	ldr	r3, [pc, #160]	; (13f8 <Reset_Handler+0xb0>)
    1356:	78d8      	ldrb	r0, [r3, #3]
    1358:	2103      	movs	r1, #3
    135a:	4388      	bics	r0, r1
    135c:	2202      	movs	r2, #2
    135e:	4310      	orrs	r0, r2
    1360:	70d8      	strb	r0, [r3, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    1362:	78dd      	ldrb	r5, [r3, #3]
    1364:	240c      	movs	r4, #12
    1366:	43a5      	bics	r5, r4
    1368:	2008      	movs	r0, #8
    136a:	4305      	orrs	r5, r0
    136c:	70dd      	strb	r5, [r3, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    136e:	4b23      	ldr	r3, [pc, #140]	; (13fc <Reset_Handler+0xb4>)
    1370:	7b9e      	ldrb	r6, [r3, #14]
    1372:	2530      	movs	r5, #48	; 0x30
    1374:	43ae      	bics	r6, r5
    1376:	2520      	movs	r5, #32
    1378:	4335      	orrs	r5, r6
    137a:	739d      	strb	r5, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    137c:	7b9d      	ldrb	r5, [r3, #14]
    137e:	43a5      	bics	r5, r4
    1380:	4328      	orrs	r0, r5
    1382:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    1384:	7b98      	ldrb	r0, [r3, #14]
    1386:	4388      	bics	r0, r1
    1388:	4302      	orrs	r2, r0
    138a:	739a      	strb	r2, [r3, #14]

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    138c:	4b1c      	ldr	r3, [pc, #112]	; (1400 <Reset_Handler+0xb8>)
    138e:	4a1d      	ldr	r2, [pc, #116]	; (1404 <Reset_Handler+0xbc>)
    1390:	429a      	cmp	r2, r3
    1392:	d003      	beq.n	139c <Reset_Handler+0x54>
                for (; pDest < &_erelocate;) {
    1394:	4b1c      	ldr	r3, [pc, #112]	; (1408 <Reset_Handler+0xc0>)
    1396:	4a1a      	ldr	r2, [pc, #104]	; (1400 <Reset_Handler+0xb8>)
    1398:	429a      	cmp	r2, r3
    139a:	d304      	bcc.n	13a6 <Reset_Handler+0x5e>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    139c:	4b1b      	ldr	r3, [pc, #108]	; (140c <Reset_Handler+0xc4>)
    139e:	4a1c      	ldr	r2, [pc, #112]	; (1410 <Reset_Handler+0xc8>)
    13a0:	429a      	cmp	r2, r3
    13a2:	d310      	bcc.n	13c6 <Reset_Handler+0x7e>
    13a4:	e01b      	b.n	13de <Reset_Handler+0x96>
    13a6:	4b1b      	ldr	r3, [pc, #108]	; (1414 <Reset_Handler+0xcc>)
    13a8:	4817      	ldr	r0, [pc, #92]	; (1408 <Reset_Handler+0xc0>)
    13aa:	3003      	adds	r0, #3
    13ac:	1ac0      	subs	r0, r0, r3
    13ae:	0880      	lsrs	r0, r0, #2
    13b0:	3001      	adds	r0, #1
    13b2:	0080      	lsls	r0, r0, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    13b4:	2300      	movs	r3, #0
                        *pDest++ = *pSrc++;
    13b6:	4912      	ldr	r1, [pc, #72]	; (1400 <Reset_Handler+0xb8>)
    13b8:	4a12      	ldr	r2, [pc, #72]	; (1404 <Reset_Handler+0xbc>)
    13ba:	58d4      	ldr	r4, [r2, r3]
    13bc:	50cc      	str	r4, [r1, r3]
    13be:	3304      	adds	r3, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    13c0:	4283      	cmp	r3, r0
    13c2:	d1fa      	bne.n	13ba <Reset_Handler+0x72>
    13c4:	e7ea      	b.n	139c <Reset_Handler+0x54>
    13c6:	4b12      	ldr	r3, [pc, #72]	; (1410 <Reset_Handler+0xc8>)
    13c8:	1d1a      	adds	r2, r3, #4
    13ca:	4910      	ldr	r1, [pc, #64]	; (140c <Reset_Handler+0xc4>)
    13cc:	3103      	adds	r1, #3
    13ce:	1a89      	subs	r1, r1, r2
    13d0:	0889      	lsrs	r1, r1, #2
    13d2:	0089      	lsls	r1, r1, #2
    13d4:	1852      	adds	r2, r2, r1
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
                *pDest++ = 0;
    13d6:	2100      	movs	r1, #0
    13d8:	c302      	stmia	r3!, {r1}
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    13da:	4293      	cmp	r3, r2
    13dc:	d1fc      	bne.n	13d8 <Reset_Handler+0x90>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    13de:	4b0e      	ldr	r3, [pc, #56]	; (1418 <Reset_Handler+0xd0>)
    13e0:	217f      	movs	r1, #127	; 0x7f
    13e2:	4a0e      	ldr	r2, [pc, #56]	; (141c <Reset_Handler+0xd4>)
    13e4:	438a      	bics	r2, r1
    13e6:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
        __libc_init_array();
    13e8:	4b0d      	ldr	r3, [pc, #52]	; (1420 <Reset_Handler+0xd8>)
    13ea:	4798      	blx	r3

        /* Branch to main function */
        main();
    13ec:	4b0d      	ldr	r3, [pc, #52]	; (1424 <Reset_Handler+0xdc>)
    13ee:	4798      	blx	r3
    13f0:	e7fe      	b.n	13f0 <Reset_Handler+0xa8>
    13f2:	46c0      	nop			; (mov r8, r8)
    13f4:	41007000 	.word	0x41007000
    13f8:	41005000 	.word	0x41005000
    13fc:	41004800 	.word	0x41004800
    1400:	20000000 	.word	0x20000000
    1404:	00001674 	.word	0x00001674
    1408:	2000001c 	.word	0x2000001c
    140c:	2000014c 	.word	0x2000014c
    1410:	2000001c 	.word	0x2000001c
    1414:	20000004 	.word	0x20000004
    1418:	e000ed00 	.word	0xe000ed00
    141c:	00000000 	.word	0x00000000
    1420:	000015e5 	.word	0x000015e5
    1424:	000014bd 	.word	0x000014bd

00001428 <Config_Contrast_PWM>:


/************************************************************************/
/* Sets up Timer to output PWM wave to drive LCD contrast charge pump*/
/************************************************************************/
void Config_Contrast_PWM(void){
    1428:	b510      	push	{r4, lr}
	
	//Enable TC5 in power manager
	REG_PM_APBCMASK |= (1<<13);		
    142a:	4b0d      	ldr	r3, [pc, #52]	; (1460 <Config_Contrast_PWM+0x38>)
    142c:	6819      	ldr	r1, [r3, #0]
    142e:	2280      	movs	r2, #128	; 0x80
    1430:	0192      	lsls	r2, r2, #6
    1432:	430a      	orrs	r2, r1
    1434:	601a      	str	r2, [r3, #0]
	
	//Assign GCLK0 to Timer //GCLK0 runs at 48 MHz
	GCLKGen_Peripheral(GCLKGEN0 , GCLK_TC4_GCLK_TC5);
    1436:	2000      	movs	r0, #0
    1438:	211c      	movs	r1, #28
    143a:	4b0a      	ldr	r3, [pc, #40]	; (1464 <Config_Contrast_PWM+0x3c>)
    143c:	4798      	blx	r3
	
	//Reset Timer
	REG_TC5_CTRLA=(1<<0);	
    143e:	4c0a      	ldr	r4, [pc, #40]	; (1468 <Config_Contrast_PWM+0x40>)
    1440:	2301      	movs	r3, #1
    1442:	8023      	strh	r3, [r4, #0]
	//	Start Timer
	REG_TC5_CTRLBSET=(1<<6);	
    1444:	2240      	movs	r2, #64	; 0x40
    1446:	4b09      	ldr	r3, [pc, #36]	; (146c <Config_Contrast_PWM+0x44>)
    1448:	701a      	strb	r2, [r3, #0]
	//PWM output pin
	pinMux(PB15,ETCmux);				
    144a:	202f      	movs	r0, #47	; 0x2f
    144c:	2104      	movs	r1, #4
    144e:	4b08      	ldr	r3, [pc, #32]	; (1470 <Config_Contrast_PWM+0x48>)
    1450:	4798      	blx	r3
					//presync |prescale|wave mode|TC Mode| Enable
	REG_TC5_CTRLA = (0<<12) | (5<<8) | (2<<5) | (1<<2) | (1<<1);	
    1452:	4b08      	ldr	r3, [pc, #32]	; (1474 <Config_Contrast_PWM+0x4c>)
    1454:	8023      	strh	r3, [r4, #0]
	//127 =50%, will need value from EEPROM
	REG_TC5_COUNT8_CC1= 127;	 //This register's not enable protected
    1456:	227f      	movs	r2, #127	; 0x7f
    1458:	4b07      	ldr	r3, [pc, #28]	; (1478 <Config_Contrast_PWM+0x50>)
    145a:	701a      	strb	r2, [r3, #0]
}
    145c:	bd10      	pop	{r4, pc}
    145e:	46c0      	nop			; (mov r8, r8)
    1460:	40000420 	.word	0x40000420
    1464:	00000a7d 	.word	0x00000a7d
    1468:	42003400 	.word	0x42003400
    146c:	42003405 	.word	0x42003405
    1470:	00000bf1 	.word	0x00000bf1
    1474:	00000546 	.word	0x00000546
    1478:	42003419 	.word	0x42003419

0000147c <Config_LCD>:
	REG_TC5_COUNT8_CC1= 26*ContrastValue;
}
/************************************************************************/
/* Initializes LCD, Contrast, and Builds some required symbols          */
/************************************************************************/
void Config_LCD(void){
    147c:	b510      	push	{r4, lr}
	Config_Contrast_PWM();
    147e:	4b08      	ldr	r3, [pc, #32]	; (14a0 <Config_LCD+0x24>)
    1480:	4798      	blx	r3
	//LCD_Init();
	LCD_Init();
    1482:	4b08      	ldr	r3, [pc, #32]	; (14a4 <Config_LCD+0x28>)
    1484:	4798      	blx	r3
	LCD_CursorOff();
    1486:	4b08      	ldr	r3, [pc, #32]	; (14a8 <Config_LCD+0x2c>)
    1488:	4798      	blx	r3
	//Build symbol in LCD's CGRAM to be used later on
	LCD_build(0, framelement);	//build '||' symbol at location 0, used to draw frame
    148a:	2000      	movs	r0, #0
    148c:	4907      	ldr	r1, [pc, #28]	; (14ac <Config_LCD+0x30>)
    148e:	4c08      	ldr	r4, [pc, #32]	; (14b0 <Config_LCD+0x34>)
    1490:	47a0      	blx	r4
	LCD_build(1, polltech);		//build Polltech LOGO at location 1
    1492:	2001      	movs	r0, #1
    1494:	4907      	ldr	r1, [pc, #28]	; (14b4 <Config_LCD+0x38>)
    1496:	47a0      	blx	r4
	LCD_build(2,degree);
    1498:	2002      	movs	r0, #2
    149a:	4907      	ldr	r1, [pc, #28]	; (14b8 <Config_LCD+0x3c>)
    149c:	47a0      	blx	r4
}
    149e:	bd10      	pop	{r4, pc}
    14a0:	00001429 	.word	0x00001429
    14a4:	000007ad 	.word	0x000007ad
    14a8:	00000775 	.word	0x00000775
    14ac:	2000000c 	.word	0x2000000c
    14b0:	00000739 	.word	0x00000739
    14b4:	20000004 	.word	0x20000004
    14b8:	20000014 	.word	0x20000014

000014bc <main>:
volatile BCDStruct BCDGrp1, BCDgrp2, BCDGrp2;	//for general global usage 



int main (void)
{
    14bc:	b530      	push	{r4, r5, lr}
    14be:	b083      	sub	sp, #12
	system_init();
    14c0:	4b14      	ldr	r3, [pc, #80]	; (1514 <main+0x58>)
    14c2:	4798      	blx	r3

	Config_MatrixKeypad();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
    14c4:	4b14      	ldr	r3, [pc, #80]	; (1518 <main+0x5c>)
    14c6:	4798      	blx	r3
	#ifndef BypassLCD

	Config_LCD();	
    14c8:	4b14      	ldr	r3, [pc, #80]	; (151c <main+0x60>)
    14ca:	4798      	blx	r3

//	Disp_IntroLcdMsgs();	//Display company name, model name 
//	DoAutoZero();
	LCD_Clrscr();
    14cc:	4d14      	ldr	r5, [pc, #80]	; (1520 <main+0x64>)
    14ce:	47a8      	blx	r5
	#endif
	LCD_Setcursor(3,20);
    14d0:	2003      	movs	r0, #3
    14d2:	2114      	movs	r1, #20
    14d4:	4c13      	ldr	r4, [pc, #76]	; (1524 <main+0x68>)
    14d6:	47a0      	blx	r4
	LCD_DataWrite(ARROW);
    14d8:	207f      	movs	r0, #127	; 0x7f
    14da:	4b13      	ldr	r3, [pc, #76]	; (1528 <main+0x6c>)
    14dc:	4798      	blx	r3
	
	LCD_Setcursor(1,1);
    14de:	2001      	movs	r0, #1
    14e0:	2101      	movs	r1, #1
    14e2:	47a0      	blx	r4
//volatile uint8_t selected=LCD_MenuHandle(MenuSize(CalibrationMenu),CalibrationMenu);
//	LCD_FullDisp(MSG[0],MSG[1],MSG[2],MSG[3]);
//	LCD_FullDisp(CalibrationMenu[0],CalibrationMenu[1],CalibrationMenu[2],CalibrationMenu[3]);
//	LCD_MenuDisplay(CalibrationMenu, 4);
	
	LCD_Clrscr();
    14e4:	47a8      	blx	r5
	LCD_Setcursor(1,2);
    14e6:	2001      	movs	r0, #1
    14e8:	2102      	movs	r1, #2
    14ea:	47a0      	blx	r4
	LCD_CursorOn();
    14ec:	4b0f      	ldr	r3, [pc, #60]	; (152c <main+0x70>)
    14ee:	4798      	blx	r3
	
	//LCD_DispAscii(selected);
//	LCD_DispVariable(12345,2,10,0,1);

	Ambient_PT100.STDvalue=10021;
    14f0:	4a0f      	ldr	r2, [pc, #60]	; (1530 <main+0x74>)
    14f2:	4b10      	ldr	r3, [pc, #64]	; (1534 <main+0x78>)
    14f4:	831a      	strh	r2, [r3, #24]
	uint32_t ans=GetNumDataFromUser(327648,4,7,1,10);
    14f6:	240a      	movs	r4, #10
    14f8:	9400      	str	r4, [sp, #0]
    14fa:	480f      	ldr	r0, [pc, #60]	; (1538 <main+0x7c>)
    14fc:	2104      	movs	r1, #4
    14fe:	2207      	movs	r2, #7
    1500:	2301      	movs	r3, #1
    1502:	4d0e      	ldr	r5, [pc, #56]	; (153c <main+0x80>)
    1504:	47a8      	blx	r5
	LCD_DispVariable(ans, 2, 7, 3, 10);
    1506:	9400      	str	r4, [sp, #0]
    1508:	2102      	movs	r1, #2
    150a:	2207      	movs	r2, #7
    150c:	2303      	movs	r3, #3
    150e:	4c0c      	ldr	r4, [pc, #48]	; (1540 <main+0x84>)
    1510:	47a0      	blx	r4
    1512:	e7fe      	b.n	1512 <main+0x56>
    1514:	00001321 	.word	0x00001321
    1518:	000008ed 	.word	0x000008ed
    151c:	0000147d 	.word	0x0000147d
    1520:	00000785 	.word	0x00000785
    1524:	000006f5 	.word	0x000006f5
    1528:	00000681 	.word	0x00000681
    152c:	00000765 	.word	0x00000765
    1530:	00002725 	.word	0x00002725
    1534:	200000a0 	.word	0x200000a0
    1538:	0004ffe0 	.word	0x0004ffe0
    153c:	00000379 	.word	0x00000379
    1540:	00000221 	.word	0x00000221

00001544 <__aeabi_uidiv>:
    1544:	2900      	cmp	r1, #0
    1546:	d034      	beq.n	15b2 <.udivsi3_skip_div0_test+0x6a>

00001548 <.udivsi3_skip_div0_test>:
    1548:	2301      	movs	r3, #1
    154a:	2200      	movs	r2, #0
    154c:	b410      	push	{r4}
    154e:	4288      	cmp	r0, r1
    1550:	d32c      	bcc.n	15ac <.udivsi3_skip_div0_test+0x64>
    1552:	2401      	movs	r4, #1
    1554:	0724      	lsls	r4, r4, #28
    1556:	42a1      	cmp	r1, r4
    1558:	d204      	bcs.n	1564 <.udivsi3_skip_div0_test+0x1c>
    155a:	4281      	cmp	r1, r0
    155c:	d202      	bcs.n	1564 <.udivsi3_skip_div0_test+0x1c>
    155e:	0109      	lsls	r1, r1, #4
    1560:	011b      	lsls	r3, r3, #4
    1562:	e7f8      	b.n	1556 <.udivsi3_skip_div0_test+0xe>
    1564:	00e4      	lsls	r4, r4, #3
    1566:	42a1      	cmp	r1, r4
    1568:	d204      	bcs.n	1574 <.udivsi3_skip_div0_test+0x2c>
    156a:	4281      	cmp	r1, r0
    156c:	d202      	bcs.n	1574 <.udivsi3_skip_div0_test+0x2c>
    156e:	0049      	lsls	r1, r1, #1
    1570:	005b      	lsls	r3, r3, #1
    1572:	e7f8      	b.n	1566 <.udivsi3_skip_div0_test+0x1e>
    1574:	4288      	cmp	r0, r1
    1576:	d301      	bcc.n	157c <.udivsi3_skip_div0_test+0x34>
    1578:	1a40      	subs	r0, r0, r1
    157a:	431a      	orrs	r2, r3
    157c:	084c      	lsrs	r4, r1, #1
    157e:	42a0      	cmp	r0, r4
    1580:	d302      	bcc.n	1588 <.udivsi3_skip_div0_test+0x40>
    1582:	1b00      	subs	r0, r0, r4
    1584:	085c      	lsrs	r4, r3, #1
    1586:	4322      	orrs	r2, r4
    1588:	088c      	lsrs	r4, r1, #2
    158a:	42a0      	cmp	r0, r4
    158c:	d302      	bcc.n	1594 <.udivsi3_skip_div0_test+0x4c>
    158e:	1b00      	subs	r0, r0, r4
    1590:	089c      	lsrs	r4, r3, #2
    1592:	4322      	orrs	r2, r4
    1594:	08cc      	lsrs	r4, r1, #3
    1596:	42a0      	cmp	r0, r4
    1598:	d302      	bcc.n	15a0 <.udivsi3_skip_div0_test+0x58>
    159a:	1b00      	subs	r0, r0, r4
    159c:	08dc      	lsrs	r4, r3, #3
    159e:	4322      	orrs	r2, r4
    15a0:	2800      	cmp	r0, #0
    15a2:	d003      	beq.n	15ac <.udivsi3_skip_div0_test+0x64>
    15a4:	091b      	lsrs	r3, r3, #4
    15a6:	d001      	beq.n	15ac <.udivsi3_skip_div0_test+0x64>
    15a8:	0909      	lsrs	r1, r1, #4
    15aa:	e7e3      	b.n	1574 <.udivsi3_skip_div0_test+0x2c>
    15ac:	1c10      	adds	r0, r2, #0
    15ae:	bc10      	pop	{r4}
    15b0:	4770      	bx	lr
    15b2:	2800      	cmp	r0, #0
    15b4:	d001      	beq.n	15ba <.udivsi3_skip_div0_test+0x72>
    15b6:	2000      	movs	r0, #0
    15b8:	43c0      	mvns	r0, r0
    15ba:	b407      	push	{r0, r1, r2}
    15bc:	4802      	ldr	r0, [pc, #8]	; (15c8 <.udivsi3_skip_div0_test+0x80>)
    15be:	a102      	add	r1, pc, #8	; (adr r1, 15c8 <.udivsi3_skip_div0_test+0x80>)
    15c0:	1840      	adds	r0, r0, r1
    15c2:	9002      	str	r0, [sp, #8]
    15c4:	bd03      	pop	{r0, r1, pc}
    15c6:	46c0      	nop			; (mov r8, r8)
    15c8:	00000019 	.word	0x00000019

000015cc <__aeabi_uidivmod>:
    15cc:	2900      	cmp	r1, #0
    15ce:	d0f0      	beq.n	15b2 <.udivsi3_skip_div0_test+0x6a>
    15d0:	b503      	push	{r0, r1, lr}
    15d2:	f7ff ffb9 	bl	1548 <.udivsi3_skip_div0_test>
    15d6:	bc0e      	pop	{r1, r2, r3}
    15d8:	4342      	muls	r2, r0
    15da:	1a89      	subs	r1, r1, r2
    15dc:	4718      	bx	r3
    15de:	46c0      	nop			; (mov r8, r8)

000015e0 <__aeabi_idiv0>:
    15e0:	4770      	bx	lr
    15e2:	46c0      	nop			; (mov r8, r8)

000015e4 <__libc_init_array>:
    15e4:	b570      	push	{r4, r5, r6, lr}
    15e6:	4b0e      	ldr	r3, [pc, #56]	; (1620 <__libc_init_array+0x3c>)
    15e8:	4d0e      	ldr	r5, [pc, #56]	; (1624 <__libc_init_array+0x40>)
    15ea:	2400      	movs	r4, #0
    15ec:	1aed      	subs	r5, r5, r3
    15ee:	10ad      	asrs	r5, r5, #2
    15f0:	1c1e      	adds	r6, r3, #0
    15f2:	42ac      	cmp	r4, r5
    15f4:	d004      	beq.n	1600 <__libc_init_array+0x1c>
    15f6:	00a3      	lsls	r3, r4, #2
    15f8:	58f3      	ldr	r3, [r6, r3]
    15fa:	4798      	blx	r3
    15fc:	3401      	adds	r4, #1
    15fe:	e7f8      	b.n	15f2 <__libc_init_array+0xe>
    1600:	f000 f828 	bl	1654 <_init>
    1604:	4b08      	ldr	r3, [pc, #32]	; (1628 <__libc_init_array+0x44>)
    1606:	4d09      	ldr	r5, [pc, #36]	; (162c <__libc_init_array+0x48>)
    1608:	2400      	movs	r4, #0
    160a:	1aed      	subs	r5, r5, r3
    160c:	10ad      	asrs	r5, r5, #2
    160e:	1c1e      	adds	r6, r3, #0
    1610:	42ac      	cmp	r4, r5
    1612:	d004      	beq.n	161e <__libc_init_array+0x3a>
    1614:	00a3      	lsls	r3, r4, #2
    1616:	58f3      	ldr	r3, [r6, r3]
    1618:	4798      	blx	r3
    161a:	3401      	adds	r4, #1
    161c:	e7f8      	b.n	1610 <__libc_init_array+0x2c>
    161e:	bd70      	pop	{r4, r5, r6, pc}
    1620:	00001660 	.word	0x00001660
    1624:	00001660 	.word	0x00001660
    1628:	00001660 	.word	0x00001660
    162c:	00001664 	.word	0x00001664
    1630:	00000eb8 	.word	0x00000eb8
    1634:	00000f18 	.word	0x00000f18
    1638:	00000f18 	.word	0x00000f18
    163c:	00000e98 	.word	0x00000e98
    1640:	00000eaa 	.word	0x00000eaa
    1644:	00000ec6 	.word	0x00000ec6
    1648:	00000e9c 	.word	0x00000e9c
    164c:	00000ed4 	.word	0x00000ed4
    1650:	00000f08 	.word	0x00000f08

00001654 <_init>:
    1654:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1656:	46c0      	nop			; (mov r8, r8)
    1658:	bcf8      	pop	{r3, r4, r5, r6, r7}
    165a:	bc08      	pop	{r3}
    165c:	469e      	mov	lr, r3
    165e:	4770      	bx	lr

00001660 <__init_array_start>:
    1660:	000000d9 	.word	0x000000d9

00001664 <_fini>:
    1664:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1666:	46c0      	nop			; (mov r8, r8)
    1668:	bcf8      	pop	{r3, r4, r5, r6, r7}
    166a:	bc08      	pop	{r3}
    166c:	469e      	mov	lr, r3
    166e:	4770      	bx	lr

00001670 <__fini_array_start>:
    1670:	000000b1 	.word	0x000000b1
