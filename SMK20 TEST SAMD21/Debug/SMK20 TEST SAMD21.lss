
SMK20 TEST SAMD21.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000026dc  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000001c  20000000  000026dc  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000134  2000001c  000026f8  0001001c  2**2
                  ALLOC
  3 .stack        00002000  20000150  0000282c  0001001c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0001001c  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010044  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001b453  00000000  00000000  0001009f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002cc6  00000000  00000000  0002b4f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000529b  00000000  00000000  0002e1b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000650  00000000  00000000  00033453  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000570  00000000  00000000  00033aa3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001a972  00000000  00000000  00034013  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ca99  00000000  00000000  0004e985  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0008a888  00000000  00000000  0005b41e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000010a4  00000000  00000000  000e5ca8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
}

/************************************************************************/
/* After Zero and Span Values are read from EEPROM Slope value of all sensors will be calculated once*/
/************************************************************************/
void ComputeEquation_ofall_Sensors(void){
       0:	20002150 	.word	0x20002150
       4:	00001edd 	.word	0x00001edd
	//AZ sensors requiring Slope from 1 point equation
	OrifPart_DP.Slope	= ComputeSlopefrom1point(&OrifPart_DP);
       8:	00001ed9 	.word	0x00001ed9
       c:	00001ed9 	.word	0x00001ed9
	...
	OrifGas_DP.Slope	= ComputeSlopefrom1point(&OrifGas_DP);
	Pitot_DP.Slope		= ComputeSlopefrom1point(&Pitot_DP);
	Stack_TC.Slope		= ComputeSlopefrom1point(&Stack_TC);
	
	//nAZ sensors requiring slope form 2 point equation
	Absolute_Pres.Slope	= ComputeSlopefrom2Point(&Absolute_Pres);	
      2c:	00001ed9 	.word	0x00001ed9
	...
	Orifice_PT100.Slope	= ComputeSlopefrom2Point(&Orifice_PT100);
      38:	00001ed9 	.word	0x00001ed9
      3c:	00001ed9 	.word	0x00001ed9
	Ambient_PT100.Slope	= ComputeSlopefrom2Point(&Ambient_PT100);
      40:	00001ed9 	.word	0x00001ed9
      44:	00001ed9 	.word	0x00001ed9
	Aux_Temp.Slope		= ComputeSlopefrom2Point(&Aux_Temp);
      48:	00001ed9 	.word	0x00001ed9
      4c:	00001ed9 	.word	0x00001ed9
	
	//nAZ Sensors requiring Intercept form Slope-point equation
	Absolute_Pres.Intercept	= ComputeIntercept(&Absolute_Pres);
      50:	00001ed9 	.word	0x00001ed9
      54:	00001ed9 	.word	0x00001ed9
	Orifice_PT100.Intercept	= ComputeIntercept(&Orifice_PT100);
      58:	00001ed9 	.word	0x00001ed9
      5c:	00001ed9 	.word	0x00001ed9
	Ambient_PT100.Intercept	= ComputeIntercept(&Ambient_PT100);
      60:	00001ed9 	.word	0x00001ed9
	Aux_Temp.Intercept		= ComputeIntercept(&Aux_Temp);
      64:	00000a75 	.word	0x00000a75
      68:	00000a85 	.word	0x00000a85
	
}
      6c:	00000a95 	.word	0x00000a95
      70:	00000aa5 	.word	0x00000aa5
      74:	00000ab5 	.word	0x00000ab5
      78:	00000ac5 	.word	0x00000ac5
      7c:	00001ed9 	.word	0x00001ed9
      80:	00001ed9 	.word	0x00001ed9
      84:	00001ed9 	.word	0x00001ed9
      88:	00001ed9 	.word	0x00001ed9
      8c:	00001ed9 	.word	0x00001ed9
      90:	00001ed9 	.word	0x00001ed9
      94:	00001ed9 	.word	0x00001ed9
      98:	00001ed9 	.word	0x00001ed9
      9c:	00001ed9 	.word	0x00001ed9
      a0:	00001ed9 	.word	0x00001ed9
      a4:	00001ed9 	.word	0x00001ed9
      a8:	00001ed9 	.word	0x00001ed9
      ac:	00001ed9 	.word	0x00001ed9

000000b0 <__do_global_dtors_aux>:
      b0:	b510      	push	{r4, lr}
      b2:	4c06      	ldr	r4, [pc, #24]	; (cc <__do_global_dtors_aux+0x1c>)
      b4:	7823      	ldrb	r3, [r4, #0]
      b6:	2b00      	cmp	r3, #0
      b8:	d107      	bne.n	ca <__do_global_dtors_aux+0x1a>
      ba:	4b05      	ldr	r3, [pc, #20]	; (d0 <__do_global_dtors_aux+0x20>)
      bc:	2b00      	cmp	r3, #0
      be:	d002      	beq.n	c6 <__do_global_dtors_aux+0x16>
      c0:	4804      	ldr	r0, [pc, #16]	; (d4 <__do_global_dtors_aux+0x24>)
      c2:	e000      	b.n	c6 <__do_global_dtors_aux+0x16>
      c4:	bf00      	nop
      c6:	2301      	movs	r3, #1
      c8:	7023      	strb	r3, [r4, #0]
      ca:	bd10      	pop	{r4, pc}
      cc:	2000001c 	.word	0x2000001c
      d0:	00000000 	.word	0x00000000
      d4:	000026dc 	.word	0x000026dc

000000d8 <frame_dummy>:
      d8:	b508      	push	{r3, lr}
      da:	4b08      	ldr	r3, [pc, #32]	; (fc <frame_dummy+0x24>)
      dc:	2b00      	cmp	r3, #0
      de:	d003      	beq.n	e8 <frame_dummy+0x10>
      e0:	4807      	ldr	r0, [pc, #28]	; (100 <frame_dummy+0x28>)
      e2:	4908      	ldr	r1, [pc, #32]	; (104 <frame_dummy+0x2c>)
      e4:	e000      	b.n	e8 <frame_dummy+0x10>
      e6:	bf00      	nop
      e8:	4807      	ldr	r0, [pc, #28]	; (108 <frame_dummy+0x30>)
      ea:	6803      	ldr	r3, [r0, #0]
      ec:	2b00      	cmp	r3, #0
      ee:	d003      	beq.n	f8 <frame_dummy+0x20>
      f0:	4b06      	ldr	r3, [pc, #24]	; (10c <frame_dummy+0x34>)
      f2:	2b00      	cmp	r3, #0
      f4:	d000      	beq.n	f8 <frame_dummy+0x20>
      f6:	4798      	blx	r3
      f8:	bd08      	pop	{r3, pc}
      fa:	46c0      	nop			; (mov r8, r8)
      fc:	00000000 	.word	0x00000000
     100:	000026dc 	.word	0x000026dc
     104:	20000020 	.word	0x20000020
     108:	000026dc 	.word	0x000026dc
     10c:	00000000 	.word	0x00000000

00000110 <i2c_master_init>:
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
				packet->data[counter++] = i2c_module->DATA.reg;
				/* Wait for response. */
				tmp_status = _i2c_master_wait_for_bus(module);
     110:	b5f0      	push	{r4, r5, r6, r7, lr}
			if (tmp_status != STATUS_OK) {
				break;
			}
		}

		if (module->send_stop) {
     112:	4647      	mov	r7, r8
     114:	b480      	push	{r7}
     116:	b082      	sub	sp, #8
			/* Send stop command unless arbitration is lost. */
			_i2c_master_wait_for_sync(module);
     118:	1c07      	adds	r7, r0, #0
     11a:	1c0c      	adds	r4, r1, #0
     11c:	1c15      	adds	r5, r2, #0
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
     11e:	6039      	str	r1, [r7, #0]
     120:	1c08      	adds	r0, r1, #0
     122:	4b5d      	ldr	r3, [pc, #372]	; (298 <i2c_master_init+0x188>)
     124:	4798      	blx	r3
     126:	1c06      	adds	r6, r0, #0
		}

		/* Save last data to buffer. */
		_i2c_master_wait_for_sync(module);
     128:	4b5c      	ldr	r3, [pc, #368]	; (29c <i2c_master_init+0x18c>)
     12a:	6a19      	ldr	r1, [r3, #32]
     12c:	1c82      	adds	r2, r0, #2
		packet->data[counter] = i2c_module->DATA.reg;
     12e:	2001      	movs	r0, #1
     130:	4090      	lsls	r0, r2
     132:	1c02      	adds	r2, r0, #0
     134:	430a      	orrs	r2, r1
     136:	621a      	str	r2, [r3, #32]
     138:	a901      	add	r1, sp, #4
     13a:	7b2b      	ldrb	r3, [r5, #12]
	if (tmp_status == STATUS_OK) {
		/* Read data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
				return STATUS_ERR_PACKET_COLLISION;
     13c:	700b      	strb	r3, [r1, #0]
		_i2c_master_wait_for_sync(module);
		packet->data[counter] = i2c_module->DATA.reg;
	}

	return tmp_status;
}
     13e:	3614      	adds	r6, #20
     140:	b2f6      	uxtb	r6, r6
     142:	1c30      	adds	r0, r6, #0
     144:	4b56      	ldr	r3, [pc, #344]	; (2a0 <i2c_master_init+0x190>)
     146:	4798      	blx	r3
     148:	1c30      	adds	r0, r6, #0
     14a:	4b56      	ldr	r3, [pc, #344]	; (2a4 <i2c_master_init+0x194>)
     14c:	4798      	blx	r3
     14e:	7b28      	ldrb	r0, [r5, #12]
     150:	2100      	movs	r1, #0
     152:	4b55      	ldr	r3, [pc, #340]	; (2a8 <i2c_master_init+0x198>)
     154:	4798      	blx	r3
     156:	6823      	ldr	r3, [r4, #0]
     158:	201c      	movs	r0, #28
     15a:	0799      	lsls	r1, r3, #30
     15c:	d500      	bpl.n	160 <i2c_master_init+0x50>
     15e:	e097      	b.n	290 <i2c_master_init+0x180>
     160:	6823      	ldr	r3, [r4, #0]
     162:	2005      	movs	r0, #5
     164:	07da      	lsls	r2, r3, #31
     166:	d500      	bpl.n	16a <i2c_master_init+0x5a>
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
		return STATUS_ERR_DENIED;
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
     168:	e092      	b.n	290 <i2c_master_init+0x180>
	module->status = STATUS_OK;
	module->buffer = NULL;
#endif

	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);
     16a:	2314      	movs	r3, #20
     16c:	6023      	str	r3, [r4, #0]
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     16e:	683c      	ldr	r4, [r7, #0]
	Sercom *const sercom_hw = module->hw;

	uint8_t sercom_index = _sercom_get_sercom_inst_index(sercom_hw);
     170:	1c20      	adds	r0, r4, #0
     172:	4b49      	ldr	r3, [pc, #292]	; (298 <i2c_master_init+0x188>)
     174:	4798      	blx	r3
     176:	4680      	mov	r8, r0
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     178:	2380      	movs	r3, #128	; 0x80
     17a:	4669      	mov	r1, sp
     17c:	700b      	strb	r3, [r1, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
     17e:	2300      	movs	r3, #0
     180:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
     182:	2201      	movs	r2, #1
     184:	708a      	strb	r2, [r1, #2]
	config->powersave    = false;
     186:	70cb      	strb	r3, [r1, #3]

	/* Pin configuration */
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);

	uint32_t pad0 = config->pinmux_pad0;
     188:	69e8      	ldr	r0, [r5, #28]
	uint32_t pad1 = config->pinmux_pad1;
     18a:	6a2e      	ldr	r6, [r5, #32]

	/* SERCOM PAD0 - SDA */
	if (pad0 == PINMUX_DEFAULT) {
     18c:	2800      	cmp	r0, #0
     18e:	d103      	bne.n	198 <i2c_master_init+0x88>
		pad0 = _sercom_get_default_pad(sercom_hw, 0);
     190:	1c20      	adds	r0, r4, #0
     192:	2100      	movs	r1, #0
     194:	4b45      	ldr	r3, [pc, #276]	; (2ac <i2c_master_init+0x19c>)
     196:	4798      	blx	r3
	}
	pin_conf.mux_position = pad0 & 0xFFFF;
     198:	466a      	mov	r2, sp
     19a:	7010      	strb	r0, [r2, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
     19c:	2202      	movs	r2, #2
     19e:	466b      	mov	r3, sp
     1a0:	705a      	strb	r2, [r3, #1]
	system_pinmux_pin_set_config(pad0 >> 16, &pin_conf);
     1a2:	0c03      	lsrs	r3, r0, #16
     1a4:	b2d8      	uxtb	r0, r3
     1a6:	4669      	mov	r1, sp
     1a8:	4b41      	ldr	r3, [pc, #260]	; (2b0 <i2c_master_init+0x1a0>)
     1aa:	4798      	blx	r3

	/* SERCOM PAD1 - SCL */
	if (pad1 == PINMUX_DEFAULT) {
     1ac:	2e00      	cmp	r6, #0
     1ae:	d104      	bne.n	1ba <i2c_master_init+0xaa>
		pad1 = _sercom_get_default_pad(sercom_hw, 1);
     1b0:	1c20      	adds	r0, r4, #0
     1b2:	2101      	movs	r1, #1
     1b4:	4b3d      	ldr	r3, [pc, #244]	; (2ac <i2c_master_init+0x19c>)
     1b6:	4798      	blx	r3
     1b8:	1c06      	adds	r6, r0, #0
	}
	pin_conf.mux_position = pad1 & 0xFFFF;
     1ba:	4669      	mov	r1, sp
     1bc:	700e      	strb	r6, [r1, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
     1be:	2302      	movs	r3, #2
     1c0:	704b      	strb	r3, [r1, #1]
	system_pinmux_pin_set_config(pad1 >> 16, &pin_conf);
     1c2:	0c36      	lsrs	r6, r6, #16
     1c4:	b2f0      	uxtb	r0, r6
     1c6:	4b3a      	ldr	r3, [pc, #232]	; (2b0 <i2c_master_init+0x1a0>)
     1c8:	4798      	blx	r3

	/* Save timeout on unknown bus state in software module. */
	module->unknown_bus_state_timeout = config->unknown_bus_state_timeout;
     1ca:	8aab      	ldrh	r3, [r5, #20]
     1cc:	80fb      	strh	r3, [r7, #6]

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;
     1ce:	8aeb      	ldrh	r3, [r5, #22]
     1d0:	813b      	strh	r3, [r7, #8]

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
     1d2:	7e2a      	ldrb	r2, [r5, #24]
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
     1d4:	2380      	movs	r3, #128	; 0x80

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
     1d6:	2a00      	cmp	r2, #0
     1d8:	d104      	bne.n	1e4 <i2c_master_init+0xd4>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
     1da:	4b36      	ldr	r3, [pc, #216]	; (2b4 <i2c_master_init+0x1a4>)
     1dc:	789b      	ldrb	r3, [r3, #2]
     1de:	079b      	lsls	r3, r3, #30
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
	} else {
		tmp_ctrla = 0;
     1e0:	0fdb      	lsrs	r3, r3, #31
     1e2:	01db      	lsls	r3, r3, #7
	}

	/* Check and set start data hold timeout. */
	if (config->start_hold_time != I2C_MASTER_START_HOLD_TIME_DISABLED) {
     1e4:	692a      	ldr	r2, [r5, #16]
     1e6:	2a00      	cmp	r2, #0
     1e8:	d000      	beq.n	1ec <i2c_master_init+0xdc>
		tmp_ctrla |= config->start_hold_time;
     1ea:	4313      	orrs	r3, r2
	}

	/* Check and set transfer speed */
	tmp_ctrla |= config->transfer_speed;
     1ec:	68aa      	ldr	r2, [r5, #8]
     1ee:	4313      	orrs	r3, r2

	/* Check and set SCL low timeout. */
	if (config->scl_low_timeout) {
     1f0:	2224      	movs	r2, #36	; 0x24
     1f2:	5caa      	ldrb	r2, [r5, r2]
     1f4:	2a00      	cmp	r2, #0
     1f6:	d002      	beq.n	1fe <i2c_master_init+0xee>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_LOWTOUTEN;
     1f8:	2280      	movs	r2, #128	; 0x80
     1fa:	05d2      	lsls	r2, r2, #23
     1fc:	4313      	orrs	r3, r2
	}

	/* Check and set inactive bus timeout. */
	if (config->inactive_timeout != I2C_MASTER_INACTIVE_TIMEOUT_DISABLED) {
     1fe:	6aaa      	ldr	r2, [r5, #40]	; 0x28
     200:	2a00      	cmp	r2, #0
     202:	d000      	beq.n	206 <i2c_master_init+0xf6>
		tmp_ctrla |= config->inactive_timeout;
     204:	4313      	orrs	r3, r2
	}

	/* Check and set SCL clock stretch mode. */
	if (config->scl_stretch_only_after_ack_bit) {
     206:	222c      	movs	r2, #44	; 0x2c
     208:	5caa      	ldrb	r2, [r5, r2]
     20a:	2a00      	cmp	r2, #0
     20c:	d002      	beq.n	214 <i2c_master_init+0x104>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SCLSM;
     20e:	2280      	movs	r2, #128	; 0x80
     210:	0512      	lsls	r2, r2, #20
     212:	4313      	orrs	r3, r2
	}

	/* Check and set slave SCL low extend timeout. */
	if (config->slave_scl_low_extend_timeout) {
     214:	222d      	movs	r2, #45	; 0x2d
     216:	5caa      	ldrb	r2, [r5, r2]
     218:	2a00      	cmp	r2, #0
     21a:	d002      	beq.n	222 <i2c_master_init+0x112>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SEXTTOEN;
     21c:	2280      	movs	r2, #128	; 0x80
     21e:	0412      	lsls	r2, r2, #16
     220:	4313      	orrs	r3, r2
	}

	/* Check and set master SCL low extend timeout. */
	if (config->master_scl_low_extend_timeout) {
     222:	222e      	movs	r2, #46	; 0x2e
     224:	5caa      	ldrb	r2, [r5, r2]
     226:	2a00      	cmp	r2, #0
     228:	d002      	beq.n	230 <i2c_master_init+0x120>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_MEXTTOEN;
     22a:	2280      	movs	r2, #128	; 0x80
     22c:	03d2      	lsls	r2, r2, #15
     22e:	4313      	orrs	r3, r2
	}

	/* Write config to register CTRLA. */
	i2c_module->CTRLA.reg |= tmp_ctrla;
     230:	6822      	ldr	r2, [r4, #0]
     232:	4313      	orrs	r3, r2
     234:	6023      	str	r3, [r4, #0]

	/* Set configurations in CTRLB. */
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
     236:	2380      	movs	r3, #128	; 0x80
     238:	005b      	lsls	r3, r3, #1
     23a:	6063      	str	r3, [r4, #4]

	/* Find and set baudrate. */
	tmp_baud = (int32_t)(div_ceil(
     23c:	4646      	mov	r6, r8
     23e:	3614      	adds	r6, #20
     240:	b2f6      	uxtb	r6, r6
     242:	1c30      	adds	r0, r6, #0
     244:	4b1c      	ldr	r3, [pc, #112]	; (2b8 <i2c_master_init+0x1a8>)
     246:	4798      	blx	r3
     248:	21fa      	movs	r1, #250	; 0xfa
     24a:	00c9      	lsls	r1, r1, #3
     24c:	682b      	ldr	r3, [r5, #0]
     24e:	4359      	muls	r1, r3
     250:	1e4b      	subs	r3, r1, #1
     252:	1818      	adds	r0, r3, r0
     254:	4b19      	ldr	r3, [pc, #100]	; (2bc <i2c_master_init+0x1ac>)
     256:	4798      	blx	r3
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate))) - 5);
     258:	1f47      	subs	r7, r0, #5

	/* Check that baudrate is supported at current speed. */
	if (tmp_baud > 255 || tmp_baud < 0) {
     25a:	2fff      	cmp	r7, #255	; 0xff
     25c:	d80d      	bhi.n	27a <i2c_master_init+0x16a>
		/* Baud rate not supported. */
		tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		/* Find baudrate for high speed */
		tmp_baud_hs = (int32_t)(div_ceil(
     25e:	1c30      	adds	r0, r6, #0
     260:	4b15      	ldr	r3, [pc, #84]	; (2b8 <i2c_master_init+0x1a8>)
     262:	4798      	blx	r3
     264:	686b      	ldr	r3, [r5, #4]
     266:	21fa      	movs	r1, #250	; 0xfa
     268:	00c9      	lsls	r1, r1, #3
     26a:	4359      	muls	r1, r3
     26c:	1e4b      	subs	r3, r1, #1
     26e:	1818      	adds	r0, r3, r0
     270:	4b12      	ldr	r3, [pc, #72]	; (2bc <i2c_master_init+0x1ac>)
     272:	4798      	blx	r3
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate_high_speed))) - 1);
     274:	3801      	subs	r0, #1

		/* Check that baudrate is supported at current speed. */
		if (tmp_baud_hs > 255 || tmp_baud_hs < 0) {
     276:	28ff      	cmp	r0, #255	; 0xff
     278:	d901      	bls.n	27e <i2c_master_init+0x16e>
	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
     27a:	2040      	movs	r0, #64	; 0x40
     27c:	e008      	b.n	290 <i2c_master_init+0x180>
		}
	}
	if (tmp_status_code != STATUS_ERR_BAUDRATE_UNAVAILABLE) {
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
			SERCOM_I2CM_BAUD_HSBAUD(tmp_baud_hs);
     27e:	0400      	lsls	r0, r0, #16
     280:	23ff      	movs	r3, #255	; 0xff
     282:	041b      	lsls	r3, r3, #16
     284:	4018      	ands	r0, r3
			tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
	}
	if (tmp_status_code != STATUS_ERR_BAUDRATE_UNAVAILABLE) {
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
     286:	23ff      	movs	r3, #255	; 0xff
     288:	401f      	ands	r7, r3
     28a:	4307      	orrs	r7, r0
     28c:	60e7      	str	r7, [r4, #12]

	/* Temporary variables. */
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;
     28e:	2000      	movs	r0, #0
	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);

	/* Set config and return status. */
	return _i2c_master_set_config(module, config);
}
     290:	b002      	add	sp, #8
     292:	bc04      	pop	{r2}
     294:	4690      	mov	r8, r2
     296:	bdf0      	pop	{r4, r5, r6, r7, pc}
     298:	00000a39 	.word	0x00000a39
     29c:	40000400 	.word	0x40000400
     2a0:	00001da9 	.word	0x00001da9
     2a4:	00001d1d 	.word	0x00001d1d
     2a8:	00000861 	.word	0x00000861
     2ac:	000008b1 	.word	0x000008b1
     2b0:	00001e85 	.word	0x00001e85
     2b4:	41002000 	.word	0x41002000
     2b8:	00001dc5 	.word	0x00001dc5
     2bc:	000022c5 	.word	0x000022c5

000002c0 <_i2c_master_wait_for_sync>:
{
	/* Sanity check. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
     2c0:	6801      	ldr	r1, [r0, #0]

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
     2c2:	2207      	movs	r2, #7
     2c4:	69cb      	ldr	r3, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check. */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
     2c6:	421a      	tst	r2, r3
     2c8:	d1fc      	bne.n	2c4 <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
     2ca:	4770      	bx	lr

000002cc <configure_EEPROM>:



//! [initialize_i2c]
void configure_EEPROM(void)
{
     2cc:	b530      	push	{r4, r5, lr}
     2ce:	b08d      	sub	sp, #52	; 0x34
	
	pinMode(WP, OUTPUT);
     2d0:	200f      	movs	r0, #15
     2d2:	2100      	movs	r1, #0
     2d4:	4b21      	ldr	r3, [pc, #132]	; (35c <configure_EEPROM+0x90>)
     2d6:	4798      	blx	r3
	PinSet(WP);
     2d8:	2280      	movs	r2, #128	; 0x80
     2da:	0212      	lsls	r2, r2, #8
     2dc:	4b20      	ldr	r3, [pc, #128]	; (360 <configure_EEPROM+0x94>)
     2de:	601a      	str	r2, [r3, #0]
static inline void i2c_master_get_config_defaults(
		struct i2c_master_config *const config)
{
	/*Sanity check argument. */
	Assert(config);
	config->baud_rate        = I2C_MASTER_BAUD_RATE_100KHZ;
     2e0:	2364      	movs	r3, #100	; 0x64
     2e2:	9300      	str	r3, [sp, #0]
#ifdef FEATURE_I2C_FAST_MODE_PLUS_AND_HIGH_SPEED
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
     2e4:	4b1f      	ldr	r3, [pc, #124]	; (364 <configure_EEPROM+0x98>)
     2e6:	9301      	str	r3, [sp, #4]
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
     2e8:	2300      	movs	r3, #0
     2ea:	9302      	str	r3, [sp, #8]
#endif
	config->generator_source = GCLK_GENERATOR_0;
     2ec:	4669      	mov	r1, sp
     2ee:	730b      	strb	r3, [r1, #12]
	config->run_in_standby   = false;
     2f0:	760b      	strb	r3, [r1, #24]
	config->start_hold_time  = I2C_MASTER_START_HOLD_TIME_300NS_600NS;
     2f2:	2280      	movs	r2, #128	; 0x80
     2f4:	0392      	lsls	r2, r2, #14
     2f6:	9204      	str	r2, [sp, #16]
	config->buffer_timeout   = 65535;
	config->unknown_bus_state_timeout = 65535;
     2f8:	2201      	movs	r2, #1
     2fa:	4252      	negs	r2, r2
     2fc:	828a      	strh	r2, [r1, #20]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->scl_low_timeout  = false;
     2fe:	2224      	movs	r2, #36	; 0x24
     300:	548b      	strb	r3, [r1, r2]
	config->inactive_timeout = I2C_MASTER_INACTIVE_TIMEOUT_DISABLED;
     302:	930a      	str	r3, [sp, #40]	; 0x28
#ifdef FEATURE_I2C_SCL_STRETCH_MODE
	config->scl_stretch_only_after_ack_bit = false;
     304:	222c      	movs	r2, #44	; 0x2c
     306:	548b      	strb	r3, [r1, r2]
#endif
#ifdef FEATURE_I2C_SCL_EXTEND_TIMEOUT
	config->slave_scl_low_extend_timeout   = false;
     308:	222d      	movs	r2, #45	; 0x2d
     30a:	548b      	strb	r3, [r1, r2]
	config->master_scl_low_extend_timeout  = false;
     30c:	222e      	movs	r2, #46	; 0x2e
     30e:	548b      	strb	r3, [r1, r2]
	i2c_master_get_config_defaults(&config_i2c_master);
	//! [init_conf]

	/* Change buffer timeout to something longer. */
	//! [conf_change]
	config_i2c_master.buffer_timeout = 10000;
     310:	4b15      	ldr	r3, [pc, #84]	; (368 <configure_EEPROM+0x9c>)
     312:	466a      	mov	r2, sp
     314:	82cb      	strh	r3, [r1, #22]
	config_i2c_master.generator_source=GCLK_GENERATOR_0;
	config_i2c_master.pinmux_pad0=PINMUX_PA12C_SERCOM2_PAD0;
     316:	4b15      	ldr	r3, [pc, #84]	; (36c <configure_EEPROM+0xa0>)
     318:	9307      	str	r3, [sp, #28]
	config_i2c_master.pinmux_pad1=PINMUX_PA13C_SERCOM2_PAD1;
     31a:	4b15      	ldr	r3, [pc, #84]	; (370 <configure_EEPROM+0xa4>)
     31c:	9308      	str	r3, [sp, #32]
	//! [conf_change]

	/* Initialize and enable device with config. */
	//! [init_module]
	i2c_master_init(&i2c_master_instance, SERCOM2, &config_i2c_master);
     31e:	4d15      	ldr	r5, [pc, #84]	; (374 <configure_EEPROM+0xa8>)
     320:	1c28      	adds	r0, r5, #0
     322:	4915      	ldr	r1, [pc, #84]	; (378 <configure_EEPROM+0xac>)
     324:	4b15      	ldr	r3, [pc, #84]	; (37c <configure_EEPROM+0xb0>)
     326:	4798      	blx	r3
	
	/*BAUD=GCLK0freq(48Mhz)*Thigh
	/i.e SCLfreq=GCLK/(2*Baud)*/
	REG_SERCOM2_I2CM_BAUD=200;				//force baud rate after above setting gives around 100Khz
     328:	22c8      	movs	r2, #200	; 0xc8
     32a:	4b15      	ldr	r3, [pc, #84]	; (380 <configure_EEPROM+0xb4>)
     32c:	601a      	str	r2, [r3, #0]
{
	/* Sanity check of arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     32e:	682c      	ldr	r4, [r5, #0]

	/* Timeout counter used to force bus state. */
	uint32_t timeout_counter = 0;

	/* Wait for module to sync. */
	_i2c_master_wait_for_sync(module);
     330:	1c28      	adds	r0, r5, #0
     332:	4b14      	ldr	r3, [pc, #80]	; (384 <configure_EEPROM+0xb8>)
     334:	4798      	blx	r3

	/* Enable module. */
	i2c_module->CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
     336:	6822      	ldr	r2, [r4, #0]
     338:	2302      	movs	r3, #2
     33a:	4313      	orrs	r3, r2
     33c:	6023      	str	r3, [r4, #0]
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown. */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
		timeout_counter++;
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
     33e:	88e8      	ldrh	r0, [r5, #6]
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Timeout counter used to force bus state. */
	uint32_t timeout_counter = 0;
     340:	2300      	movs	r3, #0
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown. */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
     342:	2110      	movs	r1, #16
     344:	e005      	b.n	352 <configure_EEPROM+0x86>
		timeout_counter++;
     346:	3301      	adds	r3, #1
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
     348:	4283      	cmp	r3, r0
     34a:	d302      	bcc.n	352 <configure_EEPROM+0x86>
			/* Timeout, force bus state to idle. */
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
     34c:	2310      	movs	r3, #16
     34e:	8363      	strh	r3, [r4, #26]
     350:	e002      	b.n	358 <configure_EEPROM+0x8c>
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown. */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
     352:	8b62      	ldrh	r2, [r4, #26]
     354:	420a      	tst	r2, r1
     356:	d0f6      	beq.n	346 <configure_EEPROM+0x7a>

	//! [enable_module]
	i2c_master_enable(&i2c_master_instance);
	//! [enable_module]
	
}
     358:	b00d      	add	sp, #52	; 0x34
     35a:	bd30      	pop	{r4, r5, pc}
     35c:	00001549 	.word	0x00001549
     360:	41004418 	.word	0x41004418
     364:	00000d48 	.word	0x00000d48
     368:	00002710 	.word	0x00002710
     36c:	000c0002 	.word	0x000c0002
     370:	000d0002 	.word	0x000d0002
     374:	2000007c 	.word	0x2000007c
     378:	42001000 	.word	0x42001000
     37c:	00000111 	.word	0x00000111
     380:	4200100c 	.word	0x4200100c
     384:	000002c1 	.word	0x000002c1

00000388 <CheckDigitBound>:
/************************************************************************/
/* When a Digit is incremented or decremented by User, it should not go above 9 or below 0
This function takes care of proper bounds off.*/
/************************************************************************/
int8_t CheckDigitBound(int8_t Num){
	if (Num<0)
     388:	2800      	cmp	r0, #0
     38a:	db07      	blt.n	39c <CheckDigitBound+0x14>
	Num=9;			//roll to 10
	if (Num>9)
	Num=0;			//roll to 0
     38c:	2309      	movs	r3, #9
     38e:	0fc1      	lsrs	r1, r0, #31
     390:	17da      	asrs	r2, r3, #31
     392:	4283      	cmp	r3, r0
     394:	4151      	adcs	r1, r2
     396:	424b      	negs	r3, r1
     398:	4018      	ands	r0, r3
     39a:	e000      	b.n	39e <CheckDigitBound+0x16>
/* When a Digit is incremented or decremented by User, it should not go above 9 or below 0
This function takes care of proper bounds off.*/
/************************************************************************/
int8_t CheckDigitBound(int8_t Num){
	if (Num<0)
	Num=9;			//roll to 10
     39c:	2009      	movs	r0, #9
	if (Num>9)
	Num=0;			//roll to 0
	
	return Num;
}
     39e:	4770      	bx	lr

000003a0 <SplitNumbertoDigits>:
the Splitted BCD digits are stored in DigitArray that is passed to the function
Usage:
int8_t BCDarray;	//Initialize and array to Store the BCD digits
SplitNumbertoDigits(Variable, BCDarray, 5);*/
/************************************************************************/
void SplitNumbertoDigits(uint32_t Num, int8_t DigitArray[], int8_t NoofDigits){
     3a0:	b5f0      	push	{r4, r5, r6, r7, lr}
     3a2:	4647      	mov	r7, r8
     3a4:	b480      	push	{r7}
     3a6:	1c05      	adds	r5, r0, #0
	
	int8_t i=0, val=0;
	uint32_t Temp=Num;
	
	while (i<NoofDigits)
     3a8:	2a00      	cmp	r2, #0
     3aa:	dd12      	ble.n	3d2 <SplitNumbertoDigits+0x32>
     3ac:	1c0c      	adds	r4, r1, #0
     3ae:	3101      	adds	r1, #1
     3b0:	3a01      	subs	r2, #1
     3b2:	b2d2      	uxtb	r2, r2
     3b4:	1889      	adds	r1, r1, r2
     3b6:	4688      	mov	r8, r1
	{
		val=Temp%10;
     3b8:	4f07      	ldr	r7, [pc, #28]	; (3d8 <SplitNumbertoDigits+0x38>)
		DigitArray[i]= val;
		Temp=Temp/10;
     3ba:	4e08      	ldr	r6, [pc, #32]	; (3dc <SplitNumbertoDigits+0x3c>)
	int8_t i=0, val=0;
	uint32_t Temp=Num;
	
	while (i<NoofDigits)
	{
		val=Temp%10;
     3bc:	1c28      	adds	r0, r5, #0
     3be:	210a      	movs	r1, #10
     3c0:	47b8      	blx	r7
     3c2:	7021      	strb	r1, [r4, #0]
		DigitArray[i]= val;
		Temp=Temp/10;
     3c4:	1c28      	adds	r0, r5, #0
     3c6:	210a      	movs	r1, #10
     3c8:	47b0      	blx	r6
     3ca:	1c05      	adds	r5, r0, #0
     3cc:	3401      	adds	r4, #1
void SplitNumbertoDigits(uint32_t Num, int8_t DigitArray[], int8_t NoofDigits){
	
	int8_t i=0, val=0;
	uint32_t Temp=Num;
	
	while (i<NoofDigits)
     3ce:	4544      	cmp	r4, r8
     3d0:	d1f4      	bne.n	3bc <SplitNumbertoDigits+0x1c>
		DigitArray[i]= val;
		Temp=Temp/10;
		i++;
	}
	
}
     3d2:	bc04      	pop	{r2}
     3d4:	4690      	mov	r8, r2
     3d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     3d8:	0000234d 	.word	0x0000234d
     3dc:	000022c5 	.word	0x000022c5

000003e0 <LCD_DispVariable>:

Usage: LCD_DispVariable(12345, 2, 4, 1, 10);
23.45 will be displayed on LCD at 1st Row and 10th Column.
MSd will be neglected since only 4 digit are asked to be displayed */
/*********************************************************************************************************************/
void LCD_DispVariable(uint32_t Number, char DecimalPos, uint8_t NoofDigitsToDisplay, char Row, char Col){
     3e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     3e2:	464f      	mov	r7, r9
     3e4:	4646      	mov	r6, r8
     3e6:	b4c0      	push	{r6, r7}
     3e8:	af00      	add	r7, sp, #0
     3ea:	1c0d      	adds	r5, r1, #0
     3ec:	1c14      	adds	r4, r2, #0
     3ee:	4699      	mov	r9, r3
     3f0:	2220      	movs	r2, #32
     3f2:	5dd2      	ldrb	r2, [r2, r7]
     3f4:	4690      	mov	r8, r2
	int8_t Digit[NoofDigitsToDisplay];	//temporary array to store BCD
     3f6:	1de3      	adds	r3, r4, #7
     3f8:	08db      	lsrs	r3, r3, #3
     3fa:	00db      	lsls	r3, r3, #3
     3fc:	466a      	mov	r2, sp
     3fe:	1ad2      	subs	r2, r2, r3
     400:	4695      	mov	sp, r2
     402:	466e      	mov	r6, sp
	SplitNumbertoDigits(Number,  Digit, NoofDigitsToDisplay);
     404:	b262      	sxtb	r2, r4
     406:	4669      	mov	r1, sp
     408:	4b25      	ldr	r3, [pc, #148]	; (4a0 <LCD_DispVariable+0xc0>)
     40a:	4798      	blx	r3
	
	LCD_Setcursor(Row, Col);	
     40c:	4648      	mov	r0, r9
     40e:	4641      	mov	r1, r8
     410:	4b24      	ldr	r3, [pc, #144]	; (4a4 <LCD_DispVariable+0xc4>)
     412:	4798      	blx	r3
	if (NoofDigitsToDisplay>=7)
     414:	2c06      	cmp	r4, #6
     416:	d902      	bls.n	41e <LCD_DispVariable+0x3e>
	LCD_DispAscii(Digit[6]);
     418:	79b0      	ldrb	r0, [r6, #6]
     41a:	4b23      	ldr	r3, [pc, #140]	; (4a8 <LCD_DispVariable+0xc8>)
     41c:	4798      	blx	r3
	if (DecimalPos==6)
     41e:	2d06      	cmp	r5, #6
     420:	d102      	bne.n	428 <LCD_DispVariable+0x48>
	LCD_DataWrite('.');
     422:	202e      	movs	r0, #46	; 0x2e
     424:	4b21      	ldr	r3, [pc, #132]	; (4ac <LCD_DispVariable+0xcc>)
     426:	4798      	blx	r3
	
	
	if (NoofDigitsToDisplay>=6)
     428:	2c05      	cmp	r4, #5
     42a:	d902      	bls.n	432 <LCD_DispVariable+0x52>
	LCD_DispAscii(Digit[5]);
     42c:	7970      	ldrb	r0, [r6, #5]
     42e:	4b1e      	ldr	r3, [pc, #120]	; (4a8 <LCD_DispVariable+0xc8>)
     430:	4798      	blx	r3
	if (DecimalPos==5)
     432:	2d05      	cmp	r5, #5
     434:	d102      	bne.n	43c <LCD_DispVariable+0x5c>
	LCD_DataWrite('.');
     436:	202e      	movs	r0, #46	; 0x2e
     438:	4b1c      	ldr	r3, [pc, #112]	; (4ac <LCD_DispVariable+0xcc>)
     43a:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=5)
     43c:	2c04      	cmp	r4, #4
     43e:	d902      	bls.n	446 <LCD_DispVariable+0x66>
	LCD_DispAscii(Digit[4]);
     440:	7930      	ldrb	r0, [r6, #4]
     442:	4b19      	ldr	r3, [pc, #100]	; (4a8 <LCD_DispVariable+0xc8>)
     444:	4798      	blx	r3
	if (DecimalPos==4)
     446:	2d04      	cmp	r5, #4
     448:	d102      	bne.n	450 <LCD_DispVariable+0x70>
	LCD_DataWrite('.');
     44a:	202e      	movs	r0, #46	; 0x2e
     44c:	4b17      	ldr	r3, [pc, #92]	; (4ac <LCD_DispVariable+0xcc>)
     44e:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=4)
     450:	2c03      	cmp	r4, #3
     452:	d902      	bls.n	45a <LCD_DispVariable+0x7a>
	LCD_DispAscii(Digit[3]);
     454:	78f0      	ldrb	r0, [r6, #3]
     456:	4b14      	ldr	r3, [pc, #80]	; (4a8 <LCD_DispVariable+0xc8>)
     458:	4798      	blx	r3
	if (DecimalPos==3)
     45a:	2d03      	cmp	r5, #3
     45c:	d102      	bne.n	464 <LCD_DispVariable+0x84>
	LCD_DataWrite('.');
     45e:	202e      	movs	r0, #46	; 0x2e
     460:	4b12      	ldr	r3, [pc, #72]	; (4ac <LCD_DispVariable+0xcc>)
     462:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=3)
     464:	2c02      	cmp	r4, #2
     466:	d902      	bls.n	46e <LCD_DispVariable+0x8e>
	LCD_DispAscii(Digit[2]);
     468:	78b0      	ldrb	r0, [r6, #2]
     46a:	4b0f      	ldr	r3, [pc, #60]	; (4a8 <LCD_DispVariable+0xc8>)
     46c:	4798      	blx	r3
	if (DecimalPos==2)
     46e:	2d02      	cmp	r5, #2
     470:	d102      	bne.n	478 <LCD_DispVariable+0x98>
	LCD_DataWrite('.');
     472:	202e      	movs	r0, #46	; 0x2e
     474:	4b0d      	ldr	r3, [pc, #52]	; (4ac <LCD_DispVariable+0xcc>)
     476:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=2)
     478:	2c01      	cmp	r4, #1
     47a:	d902      	bls.n	482 <LCD_DispVariable+0xa2>
	LCD_DispAscii(Digit[1]);
     47c:	7870      	ldrb	r0, [r6, #1]
     47e:	4b0a      	ldr	r3, [pc, #40]	; (4a8 <LCD_DispVariable+0xc8>)
     480:	4798      	blx	r3
	if (DecimalPos==1)
     482:	2d01      	cmp	r5, #1
     484:	d102      	bne.n	48c <LCD_DispVariable+0xac>
	LCD_DataWrite('.');
     486:	202e      	movs	r0, #46	; 0x2e
     488:	4b08      	ldr	r3, [pc, #32]	; (4ac <LCD_DispVariable+0xcc>)
     48a:	4798      	blx	r3
	
	if (NoofDigitsToDisplay>=1)
     48c:	2c00      	cmp	r4, #0
     48e:	d002      	beq.n	496 <LCD_DispVariable+0xb6>
	LCD_DispAscii(Digit[0]);
     490:	7830      	ldrb	r0, [r6, #0]
     492:	4b05      	ldr	r3, [pc, #20]	; (4a8 <LCD_DispVariable+0xc8>)
     494:	4798      	blx	r3

}
     496:	46bd      	mov	sp, r7
     498:	bc0c      	pop	{r2, r3}
     49a:	4690      	mov	r8, r2
     49c:	4699      	mov	r9, r3
     49e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     4a0:	000003a1 	.word	0x000003a1
     4a4:	00000c79 	.word	0x00000c79
     4a8:	00000c39 	.word	0x00000c39
     4ac:	00000be9 	.word	0x00000be9

000004b0 <CombineDigitstoNumber>:
Array Index=  0 1 2 3 4 
Say Digit[5]={2,4,5,6,8}; is the array of 5 element containing 5 BCD digit
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
     4b0:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
	
		
	if (NoofDigits>0)
     4b2:	2900      	cmp	r1, #0
     4b4:	dd02      	ble.n	4bc <CombineDigitstoNumber+0xc>
		BCD1 = Digit[0];
     4b6:	2700      	movs	r7, #0
     4b8:	57c7      	ldrsb	r7, [r0, r7]
     4ba:	e000      	b.n	4be <CombineDigitstoNumber+0xe>
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     4bc:	2700      	movs	r7, #0
	
		
	if (NoofDigits>0)
		BCD1 = Digit[0];
	
	if (NoofDigits>1)
     4be:	2901      	cmp	r1, #1
     4c0:	dd06      	ble.n	4d0 <CombineDigitstoNumber+0x20>
		BCD2 = Digit[1]*10;
     4c2:	2301      	movs	r3, #1
     4c4:	56c3      	ldrsb	r3, [r0, r3]
     4c6:	009e      	lsls	r6, r3, #2
     4c8:	18f3      	adds	r3, r6, r3
     4ca:	005b      	lsls	r3, r3, #1
     4cc:	469c      	mov	ip, r3
     4ce:	e001      	b.n	4d4 <CombineDigitstoNumber+0x24>
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     4d0:	2300      	movs	r3, #0
     4d2:	469c      	mov	ip, r3
     4d4:	2600      	movs	r6, #0
		BCD1 = Digit[0];
	
	if (NoofDigits>1)
		BCD2 = Digit[1]*10;
		
	if (NoofDigits>2)
     4d6:	2902      	cmp	r1, #2
     4d8:	dd03      	ble.n	4e2 <CombineDigitstoNumber+0x32>
		BCD3 = Digit[2]*100;
     4da:	2302      	movs	r3, #2
     4dc:	56c3      	ldrsb	r3, [r0, r3]
     4de:	2664      	movs	r6, #100	; 0x64
     4e0:	435e      	muls	r6, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     4e2:	2500      	movs	r5, #0
		BCD2 = Digit[1]*10;
		
	if (NoofDigits>2)
		BCD3 = Digit[2]*100;
		
	if (NoofDigits>3)
     4e4:	2903      	cmp	r1, #3
     4e6:	dd04      	ble.n	4f2 <CombineDigitstoNumber+0x42>
		BCD4 = Digit[3]*1000;
     4e8:	2303      	movs	r3, #3
     4ea:	56c3      	ldrsb	r3, [r0, r3]
     4ec:	25fa      	movs	r5, #250	; 0xfa
     4ee:	00ad      	lsls	r5, r5, #2
     4f0:	435d      	muls	r5, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     4f2:	2400      	movs	r4, #0
		BCD3 = Digit[2]*100;
		
	if (NoofDigits>3)
		BCD4 = Digit[3]*1000;

	if (NoofDigits>4)
     4f4:	2904      	cmp	r1, #4
     4f6:	dd03      	ble.n	500 <CombineDigitstoNumber+0x50>
		BCD5 = Digit[4]*10000;
     4f8:	2304      	movs	r3, #4
     4fa:	56c3      	ldrsb	r3, [r0, r3]
     4fc:	4c0b      	ldr	r4, [pc, #44]	; (52c <CombineDigitstoNumber+0x7c>)
     4fe:	435c      	muls	r4, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     500:	2200      	movs	r2, #0
		BCD4 = Digit[3]*1000;

	if (NoofDigits>4)
		BCD5 = Digit[4]*10000;
	
	if (NoofDigits>5)
     502:	2905      	cmp	r1, #5
     504:	dd03      	ble.n	50e <CombineDigitstoNumber+0x5e>
		BCD6 = Digit[5]*100000;
     506:	2305      	movs	r3, #5
     508:	56c3      	ldrsb	r3, [r0, r3]
     50a:	4a09      	ldr	r2, [pc, #36]	; (530 <CombineDigitstoNumber+0x80>)
     50c:	435a      	muls	r2, r3
uin32_t ans = CombineDigitstoNumber(Digit, 5);
ans will contain no 86542*/
/************************************************************************/
uint32_t CombineDigitstoNumber(int8_t Digit[], int8_t NoofDigits){
	
	uint32_t BCD1=0,BCD2=0,BCD3=0,BCD4=0,BCD5=0,BCD6=0, BCD7=0;
     50e:	2300      	movs	r3, #0
		BCD5 = Digit[4]*10000;
	
	if (NoofDigits>5)
		BCD6 = Digit[5]*100000;
		
	if (NoofDigits>6)
     510:	2906      	cmp	r1, #6
     512:	dd03      	ble.n	51c <CombineDigitstoNumber+0x6c>
		BCD7 = Digit[6]*1000000;
     514:	2306      	movs	r3, #6
     516:	56c3      	ldrsb	r3, [r0, r3]
     518:	4906      	ldr	r1, [pc, #24]	; (534 <CombineDigitstoNumber+0x84>)
     51a:	434b      	muls	r3, r1
		

	return (BCD7+BCD6+BCD5+BCD4+BCD3+BCD2+BCD1);
     51c:	4661      	mov	r1, ip
     51e:	19c8      	adds	r0, r1, r7
     520:	1986      	adds	r6, r0, r6
     522:	1975      	adds	r5, r6, r5
     524:	192c      	adds	r4, r5, r4
     526:	18a2      	adds	r2, r4, r2
     528:	18d0      	adds	r0, r2, r3
}
     52a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     52c:	00002710 	.word	0x00002710
     530:	000186a0 	.word	0x000186a0
     534:	000f4240 	.word	0x000f4240

00000538 <GetNumDataFromUser>:
uint32_t ans=GetNumDataFromUser(32768,4,5,2,10);      
Current value of variable will be displayed on LCD with given decimal point 
and user can edit the value and press enter to store new value of variable
5 digit is mostly used and this function can handle maximum of 7 Digits */
/************************************************************************/
uint32_t GetNumDataFromUser(uint32_t CurrentNum, uint8_t DecimalPos, uint8_t NoofDigit,  char Row, char Col){
     538:	b5f0      	push	{r4, r5, r6, r7, lr}
     53a:	465f      	mov	r7, fp
     53c:	4656      	mov	r6, sl
     53e:	464d      	mov	r5, r9
     540:	4644      	mov	r4, r8
     542:	b4f0      	push	{r4, r5, r6, r7}
     544:	b089      	sub	sp, #36	; 0x24
     546:	af02      	add	r7, sp, #8
     548:	6078      	str	r0, [r7, #4]
     54a:	6139      	str	r1, [r7, #16]
     54c:	4692      	mov	sl, r2
     54e:	469b      	mov	fp, r3
     550:	2140      	movs	r1, #64	; 0x40
     552:	5dc9      	ldrb	r1, [r1, r7]
     554:	6179      	str	r1, [r7, #20]
	int8_t Digit[NoofDigit];
     556:	1c13      	adds	r3, r2, #0
     558:	3307      	adds	r3, #7
     55a:	08db      	lsrs	r3, r3, #3
     55c:	00db      	lsls	r3, r3, #3
     55e:	466a      	mov	r2, sp
     560:	1ad2      	subs	r2, r2, r3
     562:	4695      	mov	sp, r2
     564:	ab02      	add	r3, sp, #8
     566:	60bb      	str	r3, [r7, #8]
     568:	4698      	mov	r8, r3
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
     56a:	9100      	str	r1, [sp, #0]
     56c:	6878      	ldr	r0, [r7, #4]
     56e:	6939      	ldr	r1, [r7, #16]
     570:	4652      	mov	r2, sl
     572:	465b      	mov	r3, fp
     574:	4c46      	ldr	r4, [pc, #280]	; (690 <GetNumDataFromUser+0x158>)
     576:	47a0      	blx	r4
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
     578:	4652      	mov	r2, sl
     57a:	b2d2      	uxtb	r2, r2
     57c:	603a      	str	r2, [r7, #0]
     57e:	b252      	sxtb	r2, r2
     580:	6878      	ldr	r0, [r7, #4]
     582:	68b9      	ldr	r1, [r7, #8]
     584:	4b43      	ldr	r3, [pc, #268]	; (694 <GetNumDataFromUser+0x15c>)
     586:	4798      	blx	r3
	LCD_CursorOn();
     588:	4b43      	ldr	r3, [pc, #268]	; (698 <GetNumDataFromUser+0x160>)
     58a:	4798      	blx	r3
	int8_t i=NoofDigit-1;
     58c:	4653      	mov	r3, sl
     58e:	3b01      	subs	r3, #1
     590:	b2db      	uxtb	r3, r3
     592:	60fb      	str	r3, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
     594:	4658      	mov	r0, fp
     596:	6979      	ldr	r1, [r7, #20]
     598:	4b40      	ldr	r3, [pc, #256]	; (69c <GetNumDataFromUser+0x164>)
     59a:	4798      	blx	r3
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
	uint8_t NewCol=Col;
     59c:	697e      	ldr	r6, [r7, #20]
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
     59e:	68fd      	ldr	r5, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
	while(1){
		if (KeyDetected())
     5a0:	4c3f      	ldr	r4, [pc, #252]	; (6a0 <GetNumDataFromUser+0x168>)
     5a2:	47a0      	blx	r4
     5a4:	2800      	cmp	r0, #0
     5a6:	d0fc      	beq.n	5a2 <GetNumDataFromUser+0x6a>
		{
			Keyscan();
     5a8:	4b3e      	ldr	r3, [pc, #248]	; (6a4 <GetNumDataFromUser+0x16c>)
     5aa:	4798      	blx	r3
			if (IncrKey)
     5ac:	493e      	ldr	r1, [pc, #248]	; (6a8 <GetNumDataFromUser+0x170>)
     5ae:	780b      	ldrb	r3, [r1, #0]
     5b0:	2b00      	cmp	r3, #0
     5b2:	d00b      	beq.n	5cc <GetNumDataFromUser+0x94>
			{
				Digit[i]++;
     5b4:	b26a      	sxtb	r2, r5
     5b6:	4691      	mov	r9, r2
     5b8:	4643      	mov	r3, r8
     5ba:	444b      	add	r3, r9
     5bc:	7818      	ldrb	r0, [r3, #0]
     5be:	3001      	adds	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     5c0:	b240      	sxtb	r0, r0
     5c2:	4b3a      	ldr	r3, [pc, #232]	; (6ac <GetNumDataFromUser+0x174>)
     5c4:	4798      	blx	r3
     5c6:	4641      	mov	r1, r8
     5c8:	4449      	add	r1, r9
     5ca:	7008      	strb	r0, [r1, #0]
			}
			
			if (DecrKey)
     5cc:	4b38      	ldr	r3, [pc, #224]	; (6b0 <GetNumDataFromUser+0x178>)
     5ce:	781b      	ldrb	r3, [r3, #0]
     5d0:	2b00      	cmp	r3, #0
     5d2:	d00b      	beq.n	5ec <GetNumDataFromUser+0xb4>
			{
				Digit[i]--;
     5d4:	b26a      	sxtb	r2, r5
     5d6:	4691      	mov	r9, r2
     5d8:	4643      	mov	r3, r8
     5da:	444b      	add	r3, r9
     5dc:	7818      	ldrb	r0, [r3, #0]
     5de:	3801      	subs	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     5e0:	b240      	sxtb	r0, r0
     5e2:	4b32      	ldr	r3, [pc, #200]	; (6ac <GetNumDataFromUser+0x174>)
     5e4:	4798      	blx	r3
     5e6:	4641      	mov	r1, r8
     5e8:	4449      	add	r1, r9
     5ea:	7008      	strb	r0, [r1, #0]
			}
			
			if (NextKey || PrevKey)		//shift cursor to right or left with press of Next or Prev key respectively
     5ec:	4b31      	ldr	r3, [pc, #196]	; (6b4 <GetNumDataFromUser+0x17c>)
     5ee:	781b      	ldrb	r3, [r3, #0]
     5f0:	2b00      	cmp	r3, #0
     5f2:	d103      	bne.n	5fc <GetNumDataFromUser+0xc4>
     5f4:	4b30      	ldr	r3, [pc, #192]	; (6b8 <GetNumDataFromUser+0x180>)
     5f6:	781b      	ldrb	r3, [r3, #0]
     5f8:	2b00      	cmp	r3, #0
     5fa:	d023      	beq.n	644 <GetNumDataFromUser+0x10c>
			{
				if (NextKey)
     5fc:	4b2d      	ldr	r3, [pc, #180]	; (6b4 <GetNumDataFromUser+0x17c>)
     5fe:	781b      	ldrb	r3, [r3, #0]
     600:	2b00      	cmp	r3, #0
     602:	d001      	beq.n	608 <GetNumDataFromUser+0xd0>
				i--;
     604:	3d01      	subs	r5, #1
     606:	b2ed      	uxtb	r5, r5
				if (PrevKey)
     608:	4b2b      	ldr	r3, [pc, #172]	; (6b8 <GetNumDataFromUser+0x180>)
     60a:	781b      	ldrb	r3, [r3, #0]
     60c:	2b00      	cmp	r3, #0
     60e:	d001      	beq.n	614 <GetNumDataFromUser+0xdc>
				i++;
     610:	3501      	adds	r5, #1
     612:	b2ed      	uxtb	r5, r5
				
				if (i>(NoofDigit-1))
     614:	b26b      	sxtb	r3, r5
     616:	4652      	mov	r2, sl
     618:	3a01      	subs	r2, #1
     61a:	4293      	cmp	r3, r2
     61c:	dc02      	bgt.n	624 <GetNumDataFromUser+0xec>
				i=0;
				if (i<0)
     61e:	2b00      	cmp	r3, #0
     620:	db02      	blt.n	628 <GetNumDataFromUser+0xf0>
     622:	e002      	b.n	62a <GetNumDataFromUser+0xf2>
				i--;
				if (PrevKey)
				i++;
				
				if (i>(NoofDigit-1))
				i=0;
     624:	2500      	movs	r5, #0
     626:	e000      	b.n	62a <GetNumDataFromUser+0xf2>
				if (i<0)
				i=NoofDigit-1;
     628:	68fd      	ldr	r5, [r7, #12]
				NewCol=Col+NoofDigit-1-i;
     62a:	697a      	ldr	r2, [r7, #20]
     62c:	1c16      	adds	r6, r2, #0
     62e:	4456      	add	r6, sl
     630:	1b76      	subs	r6, r6, r5
     632:	b2f6      	uxtb	r6, r6
     634:	1e73      	subs	r3, r6, #1
     636:	b2db      	uxtb	r3, r3
				if (NewCol>=(Col+NoofDigit-DecimalPos))
     638:	4452      	add	r2, sl
     63a:	6939      	ldr	r1, [r7, #16]
     63c:	1a52      	subs	r2, r2, r1
     63e:	4293      	cmp	r3, r2
     640:	da00      	bge.n	644 <GetNumDataFromUser+0x10c>
				
				if (i>(NoofDigit-1))
				i=0;
				if (i<0)
				i=NoofDigit-1;
				NewCol=Col+NoofDigit-1-i;
     642:	1c1e      	adds	r6, r3, #0
				if (NewCol>=(Col+NoofDigit-DecimalPos))
				NewCol++;
			}
			
			if (EnterKey)
     644:	4b1d      	ldr	r3, [pc, #116]	; (6bc <GetNumDataFromUser+0x184>)
     646:	781b      	ldrb	r3, [r3, #0]
     648:	2b00      	cmp	r3, #0
     64a:	d005      	beq.n	658 <GetNumDataFromUser+0x120>
			return CombineDigitstoNumber(Digit,NoofDigit);
     64c:	683a      	ldr	r2, [r7, #0]
     64e:	b251      	sxtb	r1, r2
     650:	68b8      	ldr	r0, [r7, #8]
     652:	4b1b      	ldr	r3, [pc, #108]	; (6c0 <GetNumDataFromUser+0x188>)
     654:	4798      	blx	r3
     656:	e012      	b.n	67e <GetNumDataFromUser+0x146>
			
			if (EscKey)
     658:	4b1a      	ldr	r3, [pc, #104]	; (6c4 <GetNumDataFromUser+0x18c>)
     65a:	781b      	ldrb	r3, [r3, #0]
     65c:	2b00      	cmp	r3, #0
     65e:	d10d      	bne.n	67c <GetNumDataFromUser+0x144>
			return CurrentNum;
			
			LCD_Setcursor(Row,NewCol);
     660:	4658      	mov	r0, fp
     662:	1c31      	adds	r1, r6, #0
     664:	4b0d      	ldr	r3, [pc, #52]	; (69c <GetNumDataFromUser+0x164>)
     666:	4699      	mov	r9, r3
     668:	4798      	blx	r3
			LCD_DispAscii(Digit[i]);
     66a:	b26b      	sxtb	r3, r5
     66c:	4641      	mov	r1, r8
     66e:	5cc8      	ldrb	r0, [r1, r3]
     670:	4b15      	ldr	r3, [pc, #84]	; (6c8 <GetNumDataFromUser+0x190>)
     672:	4798      	blx	r3
			LCD_Setcursor(Row,NewCol);
     674:	4658      	mov	r0, fp
     676:	1c31      	adds	r1, r6, #0
     678:	47c8      	blx	r9
     67a:	e792      	b.n	5a2 <GetNumDataFromUser+0x6a>
			
			if (EnterKey)
			return CombineDigitstoNumber(Digit,NoofDigit);
			
			if (EscKey)
			return CurrentNum;
     67c:	6878      	ldr	r0, [r7, #4]
			LCD_Setcursor(Row,NewCol);
			LCD_DispAscii(Digit[i]);
			LCD_Setcursor(Row,NewCol);
		}
	}
}
     67e:	46bd      	mov	sp, r7
     680:	b007      	add	sp, #28
     682:	bc3c      	pop	{r2, r3, r4, r5}
     684:	4690      	mov	r8, r2
     686:	4699      	mov	r9, r3
     688:	46a2      	mov	sl, r4
     68a:	46ab      	mov	fp, r5
     68c:	bdf0      	pop	{r4, r5, r6, r7, pc}
     68e:	46c0      	nop			; (mov r8, r8)
     690:	000003e1 	.word	0x000003e1
     694:	000003a1 	.word	0x000003a1
     698:	00000de5 	.word	0x00000de5
     69c:	00000c79 	.word	0x00000c79
     6a0:	0000132d 	.word	0x0000132d
     6a4:	00001369 	.word	0x00001369
     6a8:	2000008c 	.word	0x2000008c
     6ac:	00000389 	.word	0x00000389
     6b0:	2000008d 	.word	0x2000008d
     6b4:	20000088 	.word	0x20000088
     6b8:	2000008a 	.word	0x2000008a
     6bc:	2000008b 	.word	0x2000008b
     6c0:	000004b1 	.word	0x000004b1
     6c4:	20000089 	.word	0x20000089
     6c8:	00000c39 	.word	0x00000c39

000006cc <GetNumDataFromUserWithESC>:
/***********************************************************************************/
/* Gets Numeric data Input from user with the help of Incr, Decr, Next and Prev Key
When ESC key is pressed it returns -1 instead of current no.
Made this function to serve the purpose of CALIBRATION PASSWORD CHK.	*/
/***********************************************************************************/
int32_t GetNumDataFromUserWithESC(int32_t CurrentNum, uint8_t DecimalPos, uint8_t NoofDigit,  char Row, char Col){
     6cc:	b5f0      	push	{r4, r5, r6, r7, lr}
     6ce:	465f      	mov	r7, fp
     6d0:	4656      	mov	r6, sl
     6d2:	464d      	mov	r5, r9
     6d4:	4644      	mov	r4, r8
     6d6:	b4f0      	push	{r4, r5, r6, r7}
     6d8:	b089      	sub	sp, #36	; 0x24
     6da:	af02      	add	r7, sp, #8
     6dc:	1c04      	adds	r4, r0, #0
     6de:	6139      	str	r1, [r7, #16]
     6e0:	4692      	mov	sl, r2
     6e2:	469b      	mov	fp, r3
     6e4:	2140      	movs	r1, #64	; 0x40
     6e6:	5dc9      	ldrb	r1, [r1, r7]
     6e8:	6179      	str	r1, [r7, #20]
	int8_t Digit[NoofDigit];
     6ea:	1c13      	adds	r3, r2, #0
     6ec:	3307      	adds	r3, #7
     6ee:	08db      	lsrs	r3, r3, #3
     6f0:	00db      	lsls	r3, r3, #3
     6f2:	466a      	mov	r2, sp
     6f4:	1ad2      	subs	r2, r2, r3
     6f6:	4695      	mov	sp, r2
     6f8:	ab02      	add	r3, sp, #8
     6fa:	60bb      	str	r3, [r7, #8]
     6fc:	4698      	mov	r8, r3
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
     6fe:	9100      	str	r1, [sp, #0]
     700:	6939      	ldr	r1, [r7, #16]
     702:	4652      	mov	r2, sl
     704:	465b      	mov	r3, fp
     706:	4d47      	ldr	r5, [pc, #284]	; (824 <GetNumDataFromUserWithESC+0x158>)
     708:	47a8      	blx	r5
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
     70a:	4652      	mov	r2, sl
     70c:	b2d2      	uxtb	r2, r2
     70e:	607a      	str	r2, [r7, #4]
     710:	b252      	sxtb	r2, r2
     712:	1c20      	adds	r0, r4, #0
     714:	68b9      	ldr	r1, [r7, #8]
     716:	4b44      	ldr	r3, [pc, #272]	; (828 <GetNumDataFromUserWithESC+0x15c>)
     718:	4798      	blx	r3
	LCD_CursorOn();
     71a:	4b44      	ldr	r3, [pc, #272]	; (82c <GetNumDataFromUserWithESC+0x160>)
     71c:	4798      	blx	r3
	int8_t i=NoofDigit-1;
     71e:	4653      	mov	r3, sl
     720:	3b01      	subs	r3, #1
     722:	b2db      	uxtb	r3, r3
     724:	60fb      	str	r3, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
     726:	4658      	mov	r0, fp
     728:	6979      	ldr	r1, [r7, #20]
     72a:	4b41      	ldr	r3, [pc, #260]	; (830 <GetNumDataFromUserWithESC+0x164>)
     72c:	4798      	blx	r3
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
	uint8_t NewCol=Col;
     72e:	697e      	ldr	r6, [r7, #20]
	//First Display Current Num on LCD
	LCD_DispVariable(CurrentNum, DecimalPos, NoofDigit, Row, Col);
	//Separate Digits of num and store it in digit array
	SplitNumbertoDigits(CurrentNum, Digit, NoofDigit);
	LCD_CursorOn();
	int8_t i=NoofDigit-1;
     730:	68fd      	ldr	r5, [r7, #12]
	uint8_t NewCol=Col;
	LCD_Setcursor(Row,NewCol);
	while(1){
		if (KeyDetected())
     732:	4c40      	ldr	r4, [pc, #256]	; (834 <GetNumDataFromUserWithESC+0x168>)
     734:	47a0      	blx	r4
     736:	2800      	cmp	r0, #0
     738:	d0fc      	beq.n	734 <GetNumDataFromUserWithESC+0x68>
		{
			Keyscan();
     73a:	4b3f      	ldr	r3, [pc, #252]	; (838 <GetNumDataFromUserWithESC+0x16c>)
     73c:	4798      	blx	r3
			if (IncrKey)
     73e:	493f      	ldr	r1, [pc, #252]	; (83c <GetNumDataFromUserWithESC+0x170>)
     740:	780b      	ldrb	r3, [r1, #0]
     742:	2b00      	cmp	r3, #0
     744:	d00b      	beq.n	75e <GetNumDataFromUserWithESC+0x92>
			{
				Digit[i]++;
     746:	b26a      	sxtb	r2, r5
     748:	4691      	mov	r9, r2
     74a:	4643      	mov	r3, r8
     74c:	444b      	add	r3, r9
     74e:	7818      	ldrb	r0, [r3, #0]
     750:	3001      	adds	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     752:	b240      	sxtb	r0, r0
     754:	4b3a      	ldr	r3, [pc, #232]	; (840 <GetNumDataFromUserWithESC+0x174>)
     756:	4798      	blx	r3
     758:	4641      	mov	r1, r8
     75a:	4449      	add	r1, r9
     75c:	7008      	strb	r0, [r1, #0]
			}
			
			if (DecrKey)
     75e:	4b39      	ldr	r3, [pc, #228]	; (844 <GetNumDataFromUserWithESC+0x178>)
     760:	781b      	ldrb	r3, [r3, #0]
     762:	2b00      	cmp	r3, #0
     764:	d00b      	beq.n	77e <GetNumDataFromUserWithESC+0xb2>
			{
				Digit[i]--;
     766:	b26a      	sxtb	r2, r5
     768:	4691      	mov	r9, r2
     76a:	4643      	mov	r3, r8
     76c:	444b      	add	r3, r9
     76e:	7818      	ldrb	r0, [r3, #0]
     770:	3801      	subs	r0, #1
				Digit[i]=CheckDigitBound(Digit[i]);
     772:	b240      	sxtb	r0, r0
     774:	4b32      	ldr	r3, [pc, #200]	; (840 <GetNumDataFromUserWithESC+0x174>)
     776:	4798      	blx	r3
     778:	4641      	mov	r1, r8
     77a:	4449      	add	r1, r9
     77c:	7008      	strb	r0, [r1, #0]
			}
			
			if (NextKey || PrevKey)		//shift cursor to right or left with press of Next or Prev key respectively
     77e:	4b32      	ldr	r3, [pc, #200]	; (848 <GetNumDataFromUserWithESC+0x17c>)
     780:	781b      	ldrb	r3, [r3, #0]
     782:	2b00      	cmp	r3, #0
     784:	d103      	bne.n	78e <GetNumDataFromUserWithESC+0xc2>
     786:	4b31      	ldr	r3, [pc, #196]	; (84c <GetNumDataFromUserWithESC+0x180>)
     788:	781b      	ldrb	r3, [r3, #0]
     78a:	2b00      	cmp	r3, #0
     78c:	d023      	beq.n	7d6 <GetNumDataFromUserWithESC+0x10a>
			{
				if (NextKey)
     78e:	4b2e      	ldr	r3, [pc, #184]	; (848 <GetNumDataFromUserWithESC+0x17c>)
     790:	781b      	ldrb	r3, [r3, #0]
     792:	2b00      	cmp	r3, #0
     794:	d001      	beq.n	79a <GetNumDataFromUserWithESC+0xce>
				i--;
     796:	3d01      	subs	r5, #1
     798:	b2ed      	uxtb	r5, r5
				if (PrevKey)
     79a:	4b2c      	ldr	r3, [pc, #176]	; (84c <GetNumDataFromUserWithESC+0x180>)
     79c:	781b      	ldrb	r3, [r3, #0]
     79e:	2b00      	cmp	r3, #0
     7a0:	d001      	beq.n	7a6 <GetNumDataFromUserWithESC+0xda>
				i++;
     7a2:	3501      	adds	r5, #1
     7a4:	b2ed      	uxtb	r5, r5
				
				if (i>(NoofDigit-1))
     7a6:	b26b      	sxtb	r3, r5
     7a8:	4652      	mov	r2, sl
     7aa:	3a01      	subs	r2, #1
     7ac:	4293      	cmp	r3, r2
     7ae:	dc02      	bgt.n	7b6 <GetNumDataFromUserWithESC+0xea>
				i=0;
				if (i<0)
     7b0:	2b00      	cmp	r3, #0
     7b2:	db02      	blt.n	7ba <GetNumDataFromUserWithESC+0xee>
     7b4:	e002      	b.n	7bc <GetNumDataFromUserWithESC+0xf0>
				i--;
				if (PrevKey)
				i++;
				
				if (i>(NoofDigit-1))
				i=0;
     7b6:	2500      	movs	r5, #0
     7b8:	e000      	b.n	7bc <GetNumDataFromUserWithESC+0xf0>
				if (i<0)
				i=NoofDigit-1;
     7ba:	68fd      	ldr	r5, [r7, #12]
				NewCol=Col+NoofDigit-1-i;
     7bc:	697a      	ldr	r2, [r7, #20]
     7be:	1c16      	adds	r6, r2, #0
     7c0:	4456      	add	r6, sl
     7c2:	1b76      	subs	r6, r6, r5
     7c4:	b2f6      	uxtb	r6, r6
     7c6:	1e73      	subs	r3, r6, #1
     7c8:	b2db      	uxtb	r3, r3
				if (NewCol>=(Col+NoofDigit-DecimalPos))
     7ca:	4452      	add	r2, sl
     7cc:	6939      	ldr	r1, [r7, #16]
     7ce:	1a52      	subs	r2, r2, r1
     7d0:	4293      	cmp	r3, r2
     7d2:	da00      	bge.n	7d6 <GetNumDataFromUserWithESC+0x10a>
				
				if (i>(NoofDigit-1))
				i=0;
				if (i<0)
				i=NoofDigit-1;
				NewCol=Col+NoofDigit-1-i;
     7d4:	1c1e      	adds	r6, r3, #0
				if (NewCol>=(Col+NoofDigit-DecimalPos))
				NewCol++;
			}
			
			if (EnterKey)
     7d6:	4b1e      	ldr	r3, [pc, #120]	; (850 <GetNumDataFromUserWithESC+0x184>)
     7d8:	781b      	ldrb	r3, [r3, #0]
     7da:	2b00      	cmp	r3, #0
     7dc:	d005      	beq.n	7ea <GetNumDataFromUserWithESC+0x11e>
			return CombineDigitstoNumber(Digit,NoofDigit);
     7de:	687a      	ldr	r2, [r7, #4]
     7e0:	b251      	sxtb	r1, r2
     7e2:	68b8      	ldr	r0, [r7, #8]
     7e4:	4b1b      	ldr	r3, [pc, #108]	; (854 <GetNumDataFromUserWithESC+0x188>)
     7e6:	4798      	blx	r3
     7e8:	e013      	b.n	812 <GetNumDataFromUserWithESC+0x146>
			
			if (EscKey)
     7ea:	4b1b      	ldr	r3, [pc, #108]	; (858 <GetNumDataFromUserWithESC+0x18c>)
     7ec:	781b      	ldrb	r3, [r3, #0]
     7ee:	2b00      	cmp	r3, #0
     7f0:	d10d      	bne.n	80e <GetNumDataFromUserWithESC+0x142>
			return(-1);
			
			LCD_Setcursor(Row,NewCol);
     7f2:	4658      	mov	r0, fp
     7f4:	1c31      	adds	r1, r6, #0
     7f6:	4b0e      	ldr	r3, [pc, #56]	; (830 <GetNumDataFromUserWithESC+0x164>)
     7f8:	4699      	mov	r9, r3
     7fa:	4798      	blx	r3
			LCD_DispAscii(Digit[i]);
     7fc:	b26b      	sxtb	r3, r5
     7fe:	4641      	mov	r1, r8
     800:	5cc8      	ldrb	r0, [r1, r3]
     802:	4b16      	ldr	r3, [pc, #88]	; (85c <GetNumDataFromUserWithESC+0x190>)
     804:	4798      	blx	r3
			LCD_Setcursor(Row,NewCol);
     806:	4658      	mov	r0, fp
     808:	1c31      	adds	r1, r6, #0
     80a:	47c8      	blx	r9
     80c:	e792      	b.n	734 <GetNumDataFromUserWithESC+0x68>
			
			if (EnterKey)
			return CombineDigitstoNumber(Digit,NoofDigit);
			
			if (EscKey)
			return(-1);
     80e:	2001      	movs	r0, #1
     810:	4240      	negs	r0, r0
			LCD_Setcursor(Row,NewCol);
			LCD_DispAscii(Digit[i]);
			LCD_Setcursor(Row,NewCol);
		}
	}
     812:	46bd      	mov	sp, r7
     814:	b007      	add	sp, #28
     816:	bc3c      	pop	{r2, r3, r4, r5}
     818:	4690      	mov	r8, r2
     81a:	4699      	mov	r9, r3
     81c:	46a2      	mov	sl, r4
     81e:	46ab      	mov	fp, r5
     820:	bdf0      	pop	{r4, r5, r6, r7, pc}
     822:	46c0      	nop			; (mov r8, r8)
     824:	000003e1 	.word	0x000003e1
     828:	000003a1 	.word	0x000003a1
     82c:	00000de5 	.word	0x00000de5
     830:	00000c79 	.word	0x00000c79
     834:	0000132d 	.word	0x0000132d
     838:	00001369 	.word	0x00001369
     83c:	2000008c 	.word	0x2000008c
     840:	00000389 	.word	0x00000389
     844:	2000008d 	.word	0x2000008d
     848:	20000088 	.word	0x20000088
     84c:	2000008a 	.word	0x2000008a
     850:	2000008b 	.word	0x2000008b
     854:	000004b1 	.word	0x000004b1
     858:	20000089 	.word	0x20000089
     85c:	00000c39 	.word	0x00000c39

00000860 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
     860:	b510      	push	{r4, lr}
     862:	b082      	sub	sp, #8
     864:	1c04      	adds	r4, r0, #0
	/* Check if valid option. */
	if (!_sercom_config.generator_is_set || force_change) {
     866:	4b0f      	ldr	r3, [pc, #60]	; (8a4 <sercom_set_gclk_generator+0x44>)
     868:	781b      	ldrb	r3, [r3, #0]
     86a:	2b00      	cmp	r3, #0
     86c:	d001      	beq.n	872 <sercom_set_gclk_generator+0x12>
     86e:	2900      	cmp	r1, #0
     870:	d00d      	beq.n	88e <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config. */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
     872:	a901      	add	r1, sp, #4
     874:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
     876:	2013      	movs	r0, #19
     878:	4b0b      	ldr	r3, [pc, #44]	; (8a8 <sercom_set_gclk_generator+0x48>)
     87a:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
     87c:	2013      	movs	r0, #19
     87e:	4b0b      	ldr	r3, [pc, #44]	; (8ac <sercom_set_gclk_generator+0x4c>)
     880:	4798      	blx	r3

		/* Save config. */
		_sercom_config.generator_source = generator_source;
     882:	4b08      	ldr	r3, [pc, #32]	; (8a4 <sercom_set_gclk_generator+0x44>)
     884:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
     886:	2201      	movs	r2, #1
     888:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
     88a:	2000      	movs	r0, #0
     88c:	e007      	b.n	89e <sercom_set_gclk_generator+0x3e>
	} else if (generator_source == _sercom_config.generator_source) {
     88e:	4b05      	ldr	r3, [pc, #20]	; (8a4 <sercom_set_gclk_generator+0x44>)
     890:	785a      	ldrb	r2, [r3, #1]
		/* Return status OK if same config. */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK. */
	return STATUS_ERR_ALREADY_INITIALIZED;
     892:	201d      	movs	r0, #29
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config. */
		return STATUS_OK;
     894:	1b14      	subs	r4, r2, r4
     896:	1e62      	subs	r2, r4, #1
     898:	4194      	sbcs	r4, r2
     89a:	4264      	negs	r4, r4
     89c:	4020      	ands	r0, r4
	}

	/* Return invalid config to already initialized GCLK. */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
     89e:	b002      	add	sp, #8
     8a0:	bd10      	pop	{r4, pc}
     8a2:	46c0      	nop			; (mov r8, r8)
     8a4:	20000038 	.word	0x20000038
     8a8:	00001da9 	.word	0x00001da9
     8ac:	00001d1d 	.word	0x00001d1d

000008b0 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
     8b0:	4b44      	ldr	r3, [pc, #272]	; (9c4 <_sercom_get_default_pad+0x114>)
     8b2:	4298      	cmp	r0, r3
     8b4:	d033      	beq.n	91e <_sercom_get_default_pad+0x6e>
     8b6:	d806      	bhi.n	8c6 <_sercom_get_default_pad+0x16>
     8b8:	4b43      	ldr	r3, [pc, #268]	; (9c8 <_sercom_get_default_pad+0x118>)
     8ba:	4298      	cmp	r0, r3
     8bc:	d00d      	beq.n	8da <_sercom_get_default_pad+0x2a>
     8be:	4b43      	ldr	r3, [pc, #268]	; (9cc <_sercom_get_default_pad+0x11c>)
     8c0:	4298      	cmp	r0, r3
     8c2:	d01b      	beq.n	8fc <_sercom_get_default_pad+0x4c>
     8c4:	e06f      	b.n	9a6 <_sercom_get_default_pad+0xf6>
     8c6:	4b42      	ldr	r3, [pc, #264]	; (9d0 <_sercom_get_default_pad+0x120>)
     8c8:	4298      	cmp	r0, r3
     8ca:	d04a      	beq.n	962 <_sercom_get_default_pad+0xb2>
     8cc:	4b41      	ldr	r3, [pc, #260]	; (9d4 <_sercom_get_default_pad+0x124>)
     8ce:	4298      	cmp	r0, r3
     8d0:	d058      	beq.n	984 <_sercom_get_default_pad+0xd4>
     8d2:	4b41      	ldr	r3, [pc, #260]	; (9d8 <_sercom_get_default_pad+0x128>)
     8d4:	4298      	cmp	r0, r3
     8d6:	d166      	bne.n	9a6 <_sercom_get_default_pad+0xf6>
     8d8:	e032      	b.n	940 <_sercom_get_default_pad+0x90>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     8da:	2901      	cmp	r1, #1
     8dc:	d065      	beq.n	9aa <_sercom_get_default_pad+0xfa>
     8de:	2900      	cmp	r1, #0
     8e0:	d004      	beq.n	8ec <_sercom_get_default_pad+0x3c>
     8e2:	2902      	cmp	r1, #2
     8e4:	d006      	beq.n	8f4 <_sercom_get_default_pad+0x44>
     8e6:	2903      	cmp	r1, #3
     8e8:	d006      	beq.n	8f8 <_sercom_get_default_pad+0x48>
     8ea:	e001      	b.n	8f0 <_sercom_get_default_pad+0x40>
     8ec:	483b      	ldr	r0, [pc, #236]	; (9dc <_sercom_get_default_pad+0x12c>)
     8ee:	e067      	b.n	9c0 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     8f0:	2000      	movs	r0, #0
     8f2:	e065      	b.n	9c0 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     8f4:	483a      	ldr	r0, [pc, #232]	; (9e0 <_sercom_get_default_pad+0x130>)
     8f6:	e063      	b.n	9c0 <_sercom_get_default_pad+0x110>
     8f8:	483a      	ldr	r0, [pc, #232]	; (9e4 <_sercom_get_default_pad+0x134>)
     8fa:	e061      	b.n	9c0 <_sercom_get_default_pad+0x110>
     8fc:	2901      	cmp	r1, #1
     8fe:	d056      	beq.n	9ae <_sercom_get_default_pad+0xfe>
     900:	2900      	cmp	r1, #0
     902:	d004      	beq.n	90e <_sercom_get_default_pad+0x5e>
     904:	2902      	cmp	r1, #2
     906:	d006      	beq.n	916 <_sercom_get_default_pad+0x66>
     908:	2903      	cmp	r1, #3
     90a:	d006      	beq.n	91a <_sercom_get_default_pad+0x6a>
     90c:	e001      	b.n	912 <_sercom_get_default_pad+0x62>
     90e:	2003      	movs	r0, #3
     910:	e056      	b.n	9c0 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     912:	2000      	movs	r0, #0
     914:	e054      	b.n	9c0 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     916:	4834      	ldr	r0, [pc, #208]	; (9e8 <_sercom_get_default_pad+0x138>)
     918:	e052      	b.n	9c0 <_sercom_get_default_pad+0x110>
     91a:	4834      	ldr	r0, [pc, #208]	; (9ec <_sercom_get_default_pad+0x13c>)
     91c:	e050      	b.n	9c0 <_sercom_get_default_pad+0x110>
     91e:	2901      	cmp	r1, #1
     920:	d047      	beq.n	9b2 <_sercom_get_default_pad+0x102>
     922:	2900      	cmp	r1, #0
     924:	d004      	beq.n	930 <_sercom_get_default_pad+0x80>
     926:	2902      	cmp	r1, #2
     928:	d006      	beq.n	938 <_sercom_get_default_pad+0x88>
     92a:	2903      	cmp	r1, #3
     92c:	d006      	beq.n	93c <_sercom_get_default_pad+0x8c>
     92e:	e001      	b.n	934 <_sercom_get_default_pad+0x84>
     930:	482f      	ldr	r0, [pc, #188]	; (9f0 <_sercom_get_default_pad+0x140>)
     932:	e045      	b.n	9c0 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     934:	2000      	movs	r0, #0
     936:	e043      	b.n	9c0 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     938:	482e      	ldr	r0, [pc, #184]	; (9f4 <_sercom_get_default_pad+0x144>)
     93a:	e041      	b.n	9c0 <_sercom_get_default_pad+0x110>
     93c:	482e      	ldr	r0, [pc, #184]	; (9f8 <_sercom_get_default_pad+0x148>)
     93e:	e03f      	b.n	9c0 <_sercom_get_default_pad+0x110>
     940:	2901      	cmp	r1, #1
     942:	d038      	beq.n	9b6 <_sercom_get_default_pad+0x106>
     944:	2900      	cmp	r1, #0
     946:	d004      	beq.n	952 <_sercom_get_default_pad+0xa2>
     948:	2902      	cmp	r1, #2
     94a:	d006      	beq.n	95a <_sercom_get_default_pad+0xaa>
     94c:	2903      	cmp	r1, #3
     94e:	d006      	beq.n	95e <_sercom_get_default_pad+0xae>
     950:	e001      	b.n	956 <_sercom_get_default_pad+0xa6>
     952:	482a      	ldr	r0, [pc, #168]	; (9fc <_sercom_get_default_pad+0x14c>)
     954:	e034      	b.n	9c0 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     956:	2000      	movs	r0, #0
     958:	e032      	b.n	9c0 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     95a:	4829      	ldr	r0, [pc, #164]	; (a00 <_sercom_get_default_pad+0x150>)
     95c:	e030      	b.n	9c0 <_sercom_get_default_pad+0x110>
     95e:	4829      	ldr	r0, [pc, #164]	; (a04 <_sercom_get_default_pad+0x154>)
     960:	e02e      	b.n	9c0 <_sercom_get_default_pad+0x110>
     962:	2901      	cmp	r1, #1
     964:	d029      	beq.n	9ba <_sercom_get_default_pad+0x10a>
     966:	2900      	cmp	r1, #0
     968:	d004      	beq.n	974 <_sercom_get_default_pad+0xc4>
     96a:	2902      	cmp	r1, #2
     96c:	d006      	beq.n	97c <_sercom_get_default_pad+0xcc>
     96e:	2903      	cmp	r1, #3
     970:	d006      	beq.n	980 <_sercom_get_default_pad+0xd0>
     972:	e001      	b.n	978 <_sercom_get_default_pad+0xc8>
     974:	4824      	ldr	r0, [pc, #144]	; (a08 <_sercom_get_default_pad+0x158>)
     976:	e023      	b.n	9c0 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     978:	2000      	movs	r0, #0
     97a:	e021      	b.n	9c0 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     97c:	4823      	ldr	r0, [pc, #140]	; (a0c <_sercom_get_default_pad+0x15c>)
     97e:	e01f      	b.n	9c0 <_sercom_get_default_pad+0x110>
     980:	4823      	ldr	r0, [pc, #140]	; (a10 <_sercom_get_default_pad+0x160>)
     982:	e01d      	b.n	9c0 <_sercom_get_default_pad+0x110>
     984:	2901      	cmp	r1, #1
     986:	d01a      	beq.n	9be <_sercom_get_default_pad+0x10e>
     988:	2900      	cmp	r1, #0
     98a:	d004      	beq.n	996 <_sercom_get_default_pad+0xe6>
     98c:	2902      	cmp	r1, #2
     98e:	d006      	beq.n	99e <_sercom_get_default_pad+0xee>
     990:	2903      	cmp	r1, #3
     992:	d006      	beq.n	9a2 <_sercom_get_default_pad+0xf2>
     994:	e001      	b.n	99a <_sercom_get_default_pad+0xea>
     996:	481f      	ldr	r0, [pc, #124]	; (a14 <_sercom_get_default_pad+0x164>)
     998:	e012      	b.n	9c0 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     99a:	2000      	movs	r0, #0
     99c:	e010      	b.n	9c0 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     99e:	481e      	ldr	r0, [pc, #120]	; (a18 <_sercom_get_default_pad+0x168>)
     9a0:	e00e      	b.n	9c0 <_sercom_get_default_pad+0x110>
     9a2:	481e      	ldr	r0, [pc, #120]	; (a1c <_sercom_get_default_pad+0x16c>)
     9a4:	e00c      	b.n	9c0 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
     9a6:	2000      	movs	r0, #0
     9a8:	e00a      	b.n	9c0 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
     9aa:	481d      	ldr	r0, [pc, #116]	; (a20 <_sercom_get_default_pad+0x170>)
     9ac:	e008      	b.n	9c0 <_sercom_get_default_pad+0x110>
     9ae:	481d      	ldr	r0, [pc, #116]	; (a24 <_sercom_get_default_pad+0x174>)
     9b0:	e006      	b.n	9c0 <_sercom_get_default_pad+0x110>
     9b2:	481d      	ldr	r0, [pc, #116]	; (a28 <_sercom_get_default_pad+0x178>)
     9b4:	e004      	b.n	9c0 <_sercom_get_default_pad+0x110>
     9b6:	481d      	ldr	r0, [pc, #116]	; (a2c <_sercom_get_default_pad+0x17c>)
     9b8:	e002      	b.n	9c0 <_sercom_get_default_pad+0x110>
     9ba:	481d      	ldr	r0, [pc, #116]	; (a30 <_sercom_get_default_pad+0x180>)
     9bc:	e000      	b.n	9c0 <_sercom_get_default_pad+0x110>
     9be:	481d      	ldr	r0, [pc, #116]	; (a34 <_sercom_get_default_pad+0x184>)
	}

	Assert(false);
	return 0;
}
     9c0:	4770      	bx	lr
     9c2:	46c0      	nop			; (mov r8, r8)
     9c4:	42001000 	.word	0x42001000
     9c8:	42000800 	.word	0x42000800
     9cc:	42000c00 	.word	0x42000c00
     9d0:	42001800 	.word	0x42001800
     9d4:	42001c00 	.word	0x42001c00
     9d8:	42001400 	.word	0x42001400
     9dc:	00040003 	.word	0x00040003
     9e0:	00060003 	.word	0x00060003
     9e4:	00070003 	.word	0x00070003
     9e8:	001e0003 	.word	0x001e0003
     9ec:	001f0003 	.word	0x001f0003
     9f0:	00080003 	.word	0x00080003
     9f4:	000a0003 	.word	0x000a0003
     9f8:	000b0003 	.word	0x000b0003
     9fc:	00100003 	.word	0x00100003
     a00:	00120003 	.word	0x00120003
     a04:	00130003 	.word	0x00130003
     a08:	000c0003 	.word	0x000c0003
     a0c:	000e0003 	.word	0x000e0003
     a10:	000f0003 	.word	0x000f0003
     a14:	00160003 	.word	0x00160003
     a18:	00180003 	.word	0x00180003
     a1c:	00190003 	.word	0x00190003
     a20:	00050003 	.word	0x00050003
     a24:	00010003 	.word	0x00010003
     a28:	00090003 	.word	0x00090003
     a2c:	00110003 	.word	0x00110003
     a30:	000d0003 	.word	0x000d0003
     a34:	00170003 	.word	0x00170003

00000a38 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
     a38:	b570      	push	{r4, r5, r6, lr}
     a3a:	b086      	sub	sp, #24
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
     a3c:	4a0c      	ldr	r2, [pc, #48]	; (a70 <_sercom_get_sercom_inst_index+0x38>)
     a3e:	466b      	mov	r3, sp
     a40:	ca70      	ldmia	r2!, {r4, r5, r6}
     a42:	c370      	stmia	r3!, {r4, r5, r6}
     a44:	ca32      	ldmia	r2!, {r1, r4, r5}
     a46:	c332      	stmia	r3!, {r1, r4, r5}

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
     a48:	9e00      	ldr	r6, [sp, #0]
     a4a:	4286      	cmp	r6, r0
     a4c:	d006      	beq.n	a5c <_sercom_get_sercom_inst_index+0x24>
{
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     a4e:	2301      	movs	r3, #1
     a50:	009a      	lsls	r2, r3, #2
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
     a52:	4669      	mov	r1, sp
     a54:	5852      	ldr	r2, [r2, r1]
     a56:	4282      	cmp	r2, r0
     a58:	d103      	bne.n	a62 <_sercom_get_sercom_inst_index+0x2a>
     a5a:	e000      	b.n	a5e <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     a5c:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
     a5e:	b2d8      	uxtb	r0, r3
     a60:	e003      	b.n	a6a <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare. */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     a62:	3301      	adds	r3, #1
     a64:	2b06      	cmp	r3, #6
     a66:	d1f3      	bne.n	a50 <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
     a68:	2000      	movs	r0, #0
}
     a6a:	b006      	add	sp, #24
     a6c:	bd70      	pop	{r4, r5, r6, pc}
     a6e:	46c0      	nop			; (mov r8, r8)
     a70:	000023b0 	.word	0x000023b0

00000a74 <SERCOM0_Handler>:
	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
}

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
     a74:	b508      	push	{r3, lr}
     a76:	4b02      	ldr	r3, [pc, #8]	; (a80 <SERCOM0_Handler+0xc>)
     a78:	681b      	ldr	r3, [r3, #0]
     a7a:	2000      	movs	r0, #0
     a7c:	4798      	blx	r3
     a7e:	bd08      	pop	{r3, pc}
     a80:	2000003c 	.word	0x2000003c

00000a84 <SERCOM1_Handler>:
     a84:	b508      	push	{r3, lr}
     a86:	4b02      	ldr	r3, [pc, #8]	; (a90 <SERCOM1_Handler+0xc>)
     a88:	685b      	ldr	r3, [r3, #4]
     a8a:	2001      	movs	r0, #1
     a8c:	4798      	blx	r3
     a8e:	bd08      	pop	{r3, pc}
     a90:	2000003c 	.word	0x2000003c

00000a94 <SERCOM2_Handler>:
     a94:	b508      	push	{r3, lr}
     a96:	4b02      	ldr	r3, [pc, #8]	; (aa0 <SERCOM2_Handler+0xc>)
     a98:	689b      	ldr	r3, [r3, #8]
     a9a:	2002      	movs	r0, #2
     a9c:	4798      	blx	r3
     a9e:	bd08      	pop	{r3, pc}
     aa0:	2000003c 	.word	0x2000003c

00000aa4 <SERCOM3_Handler>:
     aa4:	b508      	push	{r3, lr}
     aa6:	4b02      	ldr	r3, [pc, #8]	; (ab0 <SERCOM3_Handler+0xc>)
     aa8:	68db      	ldr	r3, [r3, #12]
     aaa:	2003      	movs	r0, #3
     aac:	4798      	blx	r3
     aae:	bd08      	pop	{r3, pc}
     ab0:	2000003c 	.word	0x2000003c

00000ab4 <SERCOM4_Handler>:
     ab4:	b508      	push	{r3, lr}
     ab6:	4b02      	ldr	r3, [pc, #8]	; (ac0 <SERCOM4_Handler+0xc>)
     ab8:	691b      	ldr	r3, [r3, #16]
     aba:	2004      	movs	r0, #4
     abc:	4798      	blx	r3
     abe:	bd08      	pop	{r3, pc}
     ac0:	2000003c 	.word	0x2000003c

00000ac4 <SERCOM5_Handler>:
     ac4:	b508      	push	{r3, lr}
     ac6:	4b02      	ldr	r3, [pc, #8]	; (ad0 <SERCOM5_Handler+0xc>)
     ac8:	695b      	ldr	r3, [r3, #20]
     aca:	2005      	movs	r0, #5
     acc:	4798      	blx	r3
     ace:	bd08      	pop	{r3, pc}
     ad0:	2000003c 	.word	0x2000003c

00000ad4 <PulseLCD_EN>:
	LCD_CmdWrite(0x80);
	checkbusy();  // Move the Cursor to First line First Position
	LCD_PowerOn();
}

void PulseLCD_EN(void){
     ad4:	b510      	push	{r4, lr}
	PinSet(LCD_EN);
     ad6:	2480      	movs	r4, #128	; 0x80
     ad8:	0364      	lsls	r4, r4, #13
     ada:	4b04      	ldr	r3, [pc, #16]	; (aec <PulseLCD_EN+0x18>)
     adc:	601c      	str	r4, [r3, #0]
	delay_us(ENPulse);
     ade:	2002      	movs	r0, #2
     ae0:	4b03      	ldr	r3, [pc, #12]	; (af0 <PulseLCD_EN+0x1c>)
     ae2:	4798      	blx	r3
	PinClr(LCD_EN);
     ae4:	4b03      	ldr	r3, [pc, #12]	; (af4 <PulseLCD_EN+0x20>)
     ae6:	601c      	str	r4, [r3, #0]
}
     ae8:	bd10      	pop	{r4, pc}
     aea:	46c0      	nop			; (mov r8, r8)
     aec:	41004418 	.word	0x41004418
     af0:	00000f39 	.word	0x00000f39
     af4:	41004414 	.word	0x41004414

00000af8 <write4bits>:
			break;
	}
}

void write4bits(uint8_t value)
{
     af8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     afa:	464f      	mov	r7, r9
     afc:	4646      	mov	r6, r8
     afe:	b4c0      	push	{r6, r7}
     b00:	4681      	mov	r9, r0
	for (int i = 0; i < 4; i++)
     b02:	2400      	movs	r4, #0
	{
		pinMode(_data_pins[i], OUTPUT);
     b04:	4b0d      	ldr	r3, [pc, #52]	; (b3c <write4bits+0x44>)
     b06:	4698      	mov	r8, r3
     b08:	4f0d      	ldr	r7, [pc, #52]	; (b40 <write4bits+0x48>)
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
     b0a:	4e0e      	ldr	r6, [pc, #56]	; (b44 <write4bits+0x4c>)

void write4bits(uint8_t value)
{
	for (int i = 0; i < 4; i++)
	{
		pinMode(_data_pins[i], OUTPUT);
     b0c:	4643      	mov	r3, r8
     b0e:	18e5      	adds	r5, r4, r3
     b10:	7828      	ldrb	r0, [r5, #0]
     b12:	2100      	movs	r1, #0
     b14:	47b8      	blx	r7
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
     b16:	7828      	ldrb	r0, [r5, #0]
     b18:	464b      	mov	r3, r9
     b1a:	4123      	asrs	r3, r4
     b1c:	2101      	movs	r1, #1
     b1e:	4019      	ands	r1, r3
     b20:	47b0      	blx	r6
	}
}

void write4bits(uint8_t value)
{
	for (int i = 0; i < 4; i++)
     b22:	3401      	adds	r4, #1
     b24:	2c04      	cmp	r4, #4
     b26:	d1f1      	bne.n	b0c <write4bits+0x14>
	{
		pinMode(_data_pins[i], OUTPUT);
		digitalWrite(_data_pins[i], (value >> i) & 0x01);
	}
	delay_us(5);
     b28:	2005      	movs	r0, #5
     b2a:	4b07      	ldr	r3, [pc, #28]	; (b48 <write4bits+0x50>)
     b2c:	4798      	blx	r3
	PulseLCD_EN();
     b2e:	4b07      	ldr	r3, [pc, #28]	; (b4c <write4bits+0x54>)
     b30:	4798      	blx	r3
}
     b32:	bc0c      	pop	{r2, r3}
     b34:	4690      	mov	r8, r2
     b36:	4699      	mov	r9, r3
     b38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     b3a:	46c0      	nop			; (mov r8, r8)
     b3c:	20000078 	.word	0x20000078
     b40:	00001549 	.word	0x00001549
     b44:	0000164d 	.word	0x0000164d
     b48:	00000f39 	.word	0x00000f39
     b4c:	00000ad5 	.word	0x00000ad5

00000b50 <checkbusy>:
	
}


void checkbusy()		//waits until LCD is busy
{
     b50:	b5f0      	push	{r4, r5, r6, r7, lr}
     b52:	464f      	mov	r7, r9
     b54:	4646      	mov	r6, r8
     b56:	b4c0      	push	{r6, r7}
     b58:	b083      	sub	sp, #12
#ifndef BypassLCD
//delay_ms(2);
	volatile bool p27=1;			// temporary boolean bit var.
     b5a:	466c      	mov	r4, sp
     b5c:	2301      	movs	r3, #1
     b5e:	71e3      	strb	r3, [r4, #7]

//	WritePin(LCD_D7,1);
	pinMode(LCD_D7, INPUT);		//configure lcd_d7 as input
     b60:	2013      	movs	r0, #19
     b62:	2102      	movs	r1, #2
     b64:	4b1b      	ldr	r3, [pc, #108]	; (bd4 <checkbusy+0x84>)
     b66:	4798      	blx	r3
	PinClr(LCD_RS);
     b68:	2280      	movs	r2, #128	; 0x80
     b6a:	00d2      	lsls	r2, r2, #3
     b6c:	4b1a      	ldr	r3, [pc, #104]	; (bd8 <checkbusy+0x88>)
     b6e:	601a      	str	r2, [r3, #0]
	PinSet(LCD_RWb);	//RWb=1 indicates read operation.
     b70:	2280      	movs	r2, #128	; 0x80
     b72:	0392      	lsls	r2, r2, #14
     b74:	4b19      	ldr	r3, [pc, #100]	; (bdc <checkbusy+0x8c>)
     b76:	601a      	str	r2, [r3, #0]
	
	while(p27) 
     b78:	79e3      	ldrb	r3, [r4, #7]
     b7a:	2b00      	cmp	r3, #0
     b7c:	d01a      	beq.n	bb4 <checkbusy+0x64>
	{
	PinClr(LCD_EN);
     b7e:	4a16      	ldr	r2, [pc, #88]	; (bd8 <checkbusy+0x88>)
     b80:	4690      	mov	r8, r2
     b82:	2480      	movs	r4, #128	; 0x80
     b84:	0364      	lsls	r4, r4, #13
     b86:	46a1      	mov	r9, r4
     b88:	464b      	mov	r3, r9
     b8a:	4642      	mov	r2, r8
     b8c:	6013      	str	r3, [r2, #0]
	delay_us(ENPulse);
     b8e:	2002      	movs	r0, #2
     b90:	4f13      	ldr	r7, [pc, #76]	; (be0 <checkbusy+0x90>)
     b92:	47b8      	blx	r7
	PinSet(LCD_EN);
     b94:	4e11      	ldr	r6, [pc, #68]	; (bdc <checkbusy+0x8c>)
     b96:	6034      	str	r4, [r6, #0]

		p27=PinRead(LCD_D7);
     b98:	4b12      	ldr	r3, [pc, #72]	; (be4 <checkbusy+0x94>)
     b9a:	681b      	ldr	r3, [r3, #0]
     b9c:	031b      	lsls	r3, r3, #12
     b9e:	0fdb      	lsrs	r3, r3, #31
     ba0:	466d      	mov	r5, sp
     ba2:	71eb      	strb	r3, [r5, #7]
		
	PinClr(LCD_EN);
     ba4:	4643      	mov	r3, r8
     ba6:	601c      	str	r4, [r3, #0]
	delay_us(ENPulse);
     ba8:	2002      	movs	r0, #2
     baa:	47b8      	blx	r7
	PinSet(LCD_EN);
     bac:	6034      	str	r4, [r6, #0]
//	WritePin(LCD_D7,1);
	pinMode(LCD_D7, INPUT);		//configure lcd_d7 as input
	PinClr(LCD_RS);
	PinSet(LCD_RWb);	//RWb=1 indicates read operation.
	
	while(p27) 
     bae:	79eb      	ldrb	r3, [r5, #7]
     bb0:	2b00      	cmp	r3, #0
     bb2:	d1e9      	bne.n	b88 <checkbusy+0x38>
		
	PinClr(LCD_EN);
	delay_us(ENPulse);
	PinSet(LCD_EN);
	}
	PinClr(LCD_EN);
     bb4:	4b08      	ldr	r3, [pc, #32]	; (bd8 <checkbusy+0x88>)
     bb6:	2280      	movs	r2, #128	; 0x80
     bb8:	0352      	lsls	r2, r2, #13
     bba:	601a      	str	r2, [r3, #0]
	PinClr(LCD_RWb);
     bbc:	2280      	movs	r2, #128	; 0x80
     bbe:	0392      	lsls	r2, r2, #14
     bc0:	601a      	str	r2, [r3, #0]
	pinMode(LCD_D7,OUT);	//reconfigure LCD_D7 as output
     bc2:	2013      	movs	r0, #19
     bc4:	2100      	movs	r1, #0
     bc6:	4b03      	ldr	r3, [pc, #12]	; (bd4 <checkbusy+0x84>)
     bc8:	4798      	blx	r3
#endif
}
     bca:	b003      	add	sp, #12
     bcc:	bc0c      	pop	{r2, r3}
     bce:	4690      	mov	r8, r2
     bd0:	4699      	mov	r9, r3
     bd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     bd4:	00001549 	.word	0x00001549
     bd8:	41004414 	.word	0x41004414
     bdc:	41004418 	.word	0x41004418
     be0:	00000f39 	.word	0x00000f39
     be4:	41004420 	.word	0x41004420

00000be8 <LCD_DataWrite>:
	}
	delay_us(5);
	PulseLCD_EN();
}

void LCD_DataWrite(uint8_t Data){
     be8:	b538      	push	{r3, r4, r5, lr}
     bea:	1c05      	adds	r5, r0, #0
	// Select the Data Register by pulling RS High
	PinSet(LCD_RS);
     bec:	2280      	movs	r2, #128	; 0x80
     bee:	00d2      	lsls	r2, r2, #3
     bf0:	4b06      	ldr	r3, [pc, #24]	; (c0c <LCD_DataWrite+0x24>)
     bf2:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW LOW
	PinClr(LCD_RWb);
     bf4:	2280      	movs	r2, #128	; 0x80
     bf6:	0392      	lsls	r2, r2, #14
     bf8:	4b05      	ldr	r3, [pc, #20]	; (c10 <LCD_DataWrite+0x28>)
     bfa:	601a      	str	r2, [r3, #0]
	  
	  write4bits(Data>>4);
     bfc:	0900      	lsrs	r0, r0, #4
     bfe:	4c05      	ldr	r4, [pc, #20]	; (c14 <LCD_DataWrite+0x2c>)
     c00:	47a0      	blx	r4
	  write4bits(Data);
     c02:	1c28      	adds	r0, r5, #0
     c04:	47a0      	blx	r4
	  checkbusy();
     c06:	4b04      	ldr	r3, [pc, #16]	; (c18 <LCD_DataWrite+0x30>)
     c08:	4798      	blx	r3
}
     c0a:	bd38      	pop	{r3, r4, r5, pc}
     c0c:	41004418 	.word	0x41004418
     c10:	41004414 	.word	0x41004414
     c14:	00000af9 	.word	0x00000af9
     c18:	00000b51 	.word	0x00000b51

00000c1c <LCD_Print>:
	checkbusy();
}


void LCD_Print(const char *str)	//usage: LCD_disp("Hello World");
{
     c1c:	b538      	push	{r3, r4, r5, lr}
     c1e:	1c04      	adds	r4, r0, #0
	while(*str) 			//Till string ends
     c20:	7800      	ldrb	r0, [r0, #0]
     c22:	2800      	cmp	r0, #0
     c24:	d005      	beq.n	c32 <LCD_Print+0x16>
	LCD_DataWrite(*str++); 	//Send characters one by one
     c26:	4d03      	ldr	r5, [pc, #12]	; (c34 <LCD_Print+0x18>)
     c28:	3401      	adds	r4, #1
     c2a:	47a8      	blx	r5
}


void LCD_Print(const char *str)	//usage: LCD_disp("Hello World");
{
	while(*str) 			//Till string ends
     c2c:	7820      	ldrb	r0, [r4, #0]
     c2e:	2800      	cmp	r0, #0
     c30:	d1fa      	bne.n	c28 <LCD_Print+0xc>
	LCD_DataWrite(*str++); 	//Send characters one by one
}
     c32:	bd38      	pop	{r3, r4, r5, pc}
     c34:	00000be9 	.word	0x00000be9

00000c38 <LCD_DispAscii>:
	while(*str) 			//Till string ends
	LCD_DataWrite(*str++); 	//Send characters one by one
}


void LCD_DispAscii(char a){	//adds 48 offset to data before sending to LCD, can be used to print single digit no on LCD
     c38:	b508      	push	{r3, lr}
	LCD_DataWrite(a+48);
     c3a:	3030      	adds	r0, #48	; 0x30
     c3c:	b2c0      	uxtb	r0, r0
     c3e:	4b01      	ldr	r3, [pc, #4]	; (c44 <LCD_DispAscii+0xc>)
     c40:	4798      	blx	r3
}
     c42:	bd08      	pop	{r3, pc}
     c44:	00000be9 	.word	0x00000be9

00000c48 <LCD_CmdWrite>:
	write4bits(Data>>4);
	write4bits(Data);
	checkbusy();
}

void LCD_CmdWrite(uint8_t Command){
     c48:	b538      	push	{r3, r4, r5, lr}
     c4a:	1c05      	adds	r5, r0, #0
	// Select the Command Register by pulling RS pin LOW
	PinClr(LCD_RS);
     c4c:	4b07      	ldr	r3, [pc, #28]	; (c6c <LCD_CmdWrite+0x24>)
     c4e:	2280      	movs	r2, #128	; 0x80
     c50:	00d2      	lsls	r2, r2, #3
     c52:	601a      	str	r2, [r3, #0]
	// Select the Write Operation  by pulling RW pin LOW
	PinClr(LCD_RWb);
     c54:	2280      	movs	r2, #128	; 0x80
     c56:	0392      	lsls	r2, r2, #14
     c58:	601a      	str	r2, [r3, #0]
	
	write4bits(Command>>4);
     c5a:	0900      	lsrs	r0, r0, #4
     c5c:	4c04      	ldr	r4, [pc, #16]	; (c70 <LCD_CmdWrite+0x28>)
     c5e:	47a0      	blx	r4
	write4bits(Command);
     c60:	1c28      	adds	r0, r5, #0
     c62:	47a0      	blx	r4
	checkbusy();
     c64:	4b03      	ldr	r3, [pc, #12]	; (c74 <LCD_CmdWrite+0x2c>)
     c66:	4798      	blx	r3
}
     c68:	bd38      	pop	{r3, r4, r5, pc}
     c6a:	46c0      	nop			; (mov r8, r8)
     c6c:	41004414 	.word	0x41004414
     c70:	00000af9 	.word	0x00000af9
     c74:	00000b51 	.word	0x00000b51

00000c78 <LCD_Setcursor>:
}

void LCD_Setcursor(char Row, char Column)	
//pass row and column no to this function
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
     c78:	b508      	push	{r3, lr}
	switch(Row)		
     c7a:	2802      	cmp	r0, #2
     c7c:	d00d      	beq.n	c9a <LCD_Setcursor+0x22>
     c7e:	d802      	bhi.n	c86 <LCD_Setcursor+0xe>
     c80:	2801      	cmp	r0, #1
     c82:	d005      	beq.n	c90 <LCD_Setcursor+0x18>
     c84:	e017      	b.n	cb6 <LCD_Setcursor+0x3e>
     c86:	2803      	cmp	r0, #3
     c88:	d00c      	beq.n	ca4 <LCD_Setcursor+0x2c>
     c8a:	2804      	cmp	r0, #4
     c8c:	d00f      	beq.n	cae <LCD_Setcursor+0x36>
     c8e:	e012      	b.n	cb6 <LCD_Setcursor+0x3e>
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     c90:	317f      	adds	r1, #127	; 0x7f
     c92:	b2c8      	uxtb	r0, r1
     c94:	4b08      	ldr	r3, [pc, #32]	; (cb8 <LCD_Setcursor+0x40>)
     c96:	4798      	blx	r3
			break;
     c98:	e00d      	b.n	cb6 <LCD_Setcursor+0x3e>
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     c9a:	3941      	subs	r1, #65	; 0x41
     c9c:	b2c8      	uxtb	r0, r1
     c9e:	4b06      	ldr	r3, [pc, #24]	; (cb8 <LCD_Setcursor+0x40>)
     ca0:	4798      	blx	r3
			break;
     ca2:	e008      	b.n	cb6 <LCD_Setcursor+0x3e>
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     ca4:	396d      	subs	r1, #109	; 0x6d
     ca6:	b2c8      	uxtb	r0, r1
     ca8:	4b03      	ldr	r3, [pc, #12]	; (cb8 <LCD_Setcursor+0x40>)
     caa:	4798      	blx	r3
			break;
     cac:	e003      	b.n	cb6 <LCD_Setcursor+0x3e>
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     cae:	392d      	subs	r1, #45	; 0x2d
     cb0:	b2c8      	uxtb	r0, r1
     cb2:	4b01      	ldr	r3, [pc, #4]	; (cb8 <LCD_Setcursor+0x40>)
     cb4:	4798      	blx	r3
			break;
	}
}
     cb6:	bd08      	pop	{r3, pc}
     cb8:	00000c49 	.word	0x00000c49

00000cbc <LCD_FullDisp>:
void LCD_DispAscii(char a){	//adds 48 offset to data before sending to LCD, can be used to print single digit no on LCD
	LCD_DataWrite(a+48);
}

void LCD_FullDisp(const char *str0,const char *str1,const char *str2,const char *str3 )	//pass a string for each row	
{			
     cbc:	b5f0      	push	{r4, r5, r6, r7, lr}
     cbe:	4647      	mov	r7, r8
     cc0:	b480      	push	{r7}
     cc2:	1c04      	adds	r4, r0, #0
     cc4:	4688      	mov	r8, r1
     cc6:	1c17      	adds	r7, r2, #0
     cc8:	1c1e      	adds	r6, r3, #0
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     cca:	2080      	movs	r0, #128	; 0x80
     ccc:	4d09      	ldr	r5, [pc, #36]	; (cf4 <LCD_FullDisp+0x38>)
     cce:	47a8      	blx	r5
void LCD_FullDisp(const char *str0,const char *str1,const char *str2,const char *str3 )	//pass a string for each row	
{			
	
//Fills all four lines of LCD with the passed strings msg.
	LCD_Setcursor(1,1);
	LCD_Print(str0);
     cd0:	1c20      	adds	r0, r4, #0
     cd2:	4c09      	ldr	r4, [pc, #36]	; (cf8 <LCD_FullDisp+0x3c>)
     cd4:	47a0      	blx	r4
			case 1:
			LCD_CmdWrite(0x80+Column-1);
			break;
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     cd6:	20c0      	movs	r0, #192	; 0xc0
     cd8:	47a8      	blx	r5
//Fills all four lines of LCD with the passed strings msg.
	LCD_Setcursor(1,1);
	LCD_Print(str0);

	LCD_Setcursor(2,1);
	LCD_Print(str1);
     cda:	4640      	mov	r0, r8
     cdc:	47a0      	blx	r4
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
			break;
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     cde:	2094      	movs	r0, #148	; 0x94
     ce0:	47a8      	blx	r5

	LCD_Setcursor(2,1);
	LCD_Print(str1);

	LCD_Setcursor(3,1);
	LCD_Print(str2);
     ce2:	1c38      	adds	r0, r7, #0
     ce4:	47a0      	blx	r4
			case 3:
			LCD_CmdWrite(0x94+Column-1);
			break;
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     ce6:	20d4      	movs	r0, #212	; 0xd4
     ce8:	47a8      	blx	r5

	LCD_Setcursor(3,1);
	LCD_Print(str2);

	LCD_Setcursor(4,1);
	LCD_Print(str3);
     cea:	1c30      	adds	r0, r6, #0
     cec:	47a0      	blx	r4
	
	
}
     cee:	bc04      	pop	{r2}
     cf0:	4690      	mov	r8, r2
     cf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     cf4:	00000c49 	.word	0x00000c49
     cf8:	00000c1d 	.word	0x00000c1d

00000cfc <LCD_OneLine>:
	while(*str) 			//Till string ends
	LCD_DataWrite(*str++); 	//Send characters one by one
}

void LCD_OneLine(uint8_t Row, const char *str)	//usage: LCD_disp(2, "Hello World"); to display on 2nd line
{
     cfc:	b538      	push	{r3, r4, r5, lr}
     cfe:	1c0c      	adds	r4, r1, #0

void LCD_Setcursor(char Row, char Column)	
//pass row and column no to this function
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
     d00:	2802      	cmp	r0, #2
     d02:	d00c      	beq.n	d1e <LCD_OneLine+0x22>
     d04:	d802      	bhi.n	d0c <LCD_OneLine+0x10>
     d06:	2801      	cmp	r0, #1
     d08:	d005      	beq.n	d16 <LCD_OneLine+0x1a>
     d0a:	e00b      	b.n	d24 <LCD_OneLine+0x28>
     d0c:	2803      	cmp	r0, #3
     d0e:	d00d      	beq.n	d2c <LCD_OneLine+0x30>
     d10:	2804      	cmp	r0, #4
     d12:	d00f      	beq.n	d34 <LCD_OneLine+0x38>
     d14:	e006      	b.n	d24 <LCD_OneLine+0x28>
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     d16:	2080      	movs	r0, #128	; 0x80
     d18:	4b0c      	ldr	r3, [pc, #48]	; (d4c <LCD_OneLine+0x50>)
     d1a:	4798      	blx	r3
     d1c:	e002      	b.n	d24 <LCD_OneLine+0x28>
			break;
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     d1e:	20c0      	movs	r0, #192	; 0xc0
     d20:	4b0a      	ldr	r3, [pc, #40]	; (d4c <LCD_OneLine+0x50>)
     d22:	4798      	blx	r3
}

void LCD_OneLine(uint8_t Row, const char *str)	//usage: LCD_disp(2, "Hello World"); to display on 2nd line
{
	LCD_Setcursor(Row,1);
	while(*str) 			//Till string ends
     d24:	7820      	ldrb	r0, [r4, #0]
     d26:	2800      	cmp	r0, #0
     d28:	d108      	bne.n	d3c <LCD_OneLine+0x40>
     d2a:	e00d      	b.n	d48 <LCD_OneLine+0x4c>
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
			break;
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     d2c:	2094      	movs	r0, #148	; 0x94
     d2e:	4b07      	ldr	r3, [pc, #28]	; (d4c <LCD_OneLine+0x50>)
     d30:	4798      	blx	r3
     d32:	e7f7      	b.n	d24 <LCD_OneLine+0x28>
			break;
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     d34:	20d4      	movs	r0, #212	; 0xd4
     d36:	4b05      	ldr	r3, [pc, #20]	; (d4c <LCD_OneLine+0x50>)
     d38:	4798      	blx	r3
     d3a:	e7f3      	b.n	d24 <LCD_OneLine+0x28>

void LCD_OneLine(uint8_t Row, const char *str)	//usage: LCD_disp(2, "Hello World"); to display on 2nd line
{
	LCD_Setcursor(Row,1);
	while(*str) 			//Till string ends
	LCD_DataWrite(*str++); 	//Send characters one by one
     d3c:	4d04      	ldr	r5, [pc, #16]	; (d50 <LCD_OneLine+0x54>)
     d3e:	3401      	adds	r4, #1
     d40:	47a8      	blx	r5
}

void LCD_OneLine(uint8_t Row, const char *str)	//usage: LCD_disp(2, "Hello World"); to display on 2nd line
{
	LCD_Setcursor(Row,1);
	while(*str) 			//Till string ends
     d42:	7820      	ldrb	r0, [r4, #0]
     d44:	2800      	cmp	r0, #0
     d46:	d1fa      	bne.n	d3e <LCD_OneLine+0x42>
	LCD_DataWrite(*str++); 	//Send characters one by one
}
     d48:	bd38      	pop	{r3, r4, r5, pc}
     d4a:	46c0      	nop			; (mov r8, r8)
     d4c:	00000c49 	.word	0x00000c49
     d50:	00000be9 	.word	0x00000be9

00000d54 <LCD_build>:
	PinClr(LCD_RWb);
	pinMode(LCD_D7,OUT);	//reconfigure LCD_D7 as output
#endif
}

void LCD_build(uint8_t location, uint8_t *ptr){		//character should be built before writing anything to lcd.
     d54:	b570      	push	{r4, r5, r6, lr}
     d56:	1c0e      	adds	r6, r1, #0
	uint8_t i;
	if(location<8){
     d58:	2807      	cmp	r0, #7
     d5a:	d80c      	bhi.n	d76 <LCD_build+0x22>
		LCD_CmdWrite(0x40+(location*8));	//since each symbol eats up 8 bytes, location is multiplied by 8
     d5c:	3008      	adds	r0, #8
     d5e:	00c0      	lsls	r0, r0, #3
     d60:	b2c0      	uxtb	r0, r0
     d62:	4b05      	ldr	r3, [pc, #20]	; (d78 <LCD_build+0x24>)
     d64:	4798      	blx	r3
     d66:	1c34      	adds	r4, r6, #0
     d68:	3608      	adds	r6, #8
		for(i=0;i<8;i++)
		LCD_DataWrite(ptr[ i ]);
     d6a:	4d04      	ldr	r5, [pc, #16]	; (d7c <LCD_build+0x28>)
     d6c:	7820      	ldrb	r0, [r4, #0]
     d6e:	47a8      	blx	r5
     d70:	3401      	adds	r4, #1

void LCD_build(uint8_t location, uint8_t *ptr){		//character should be built before writing anything to lcd.
	uint8_t i;
	if(location<8){
		LCD_CmdWrite(0x40+(location*8));	//since each symbol eats up 8 bytes, location is multiplied by 8
		for(i=0;i<8;i++)
     d72:	42b4      	cmp	r4, r6
     d74:	d1fa      	bne.n	d6c <LCD_build+0x18>
		LCD_DataWrite(ptr[ i ]);
	}
	
}
     d76:	bd70      	pop	{r4, r5, r6, pc}
     d78:	00000c49 	.word	0x00000c49
     d7c:	00000be9 	.word	0x00000be9

00000d80 <LCD_Frame1>:
	LCD_DataWrite(0x10); //Load row 6 data
	LCD_DataWrite(0x10); //Load row 7 data
	LCD_DataWrite(0x00); //Load row 8 data
}

void LCD_Frame1(){
     d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     d82:	2080      	movs	r0, #128	; 0x80
     d84:	4d13      	ldr	r5, [pc, #76]	; (dd4 <LCD_Frame1+0x54>)
     d86:	47a8      	blx	r5
	LCD_DataWrite(0x00); //Load row 8 data
}

void LCD_Frame1(){
	LCD_Setcursor(1,1);
	LCD_DataWrite(255);
     d88:	20ff      	movs	r0, #255	; 0xff
     d8a:	4c13      	ldr	r4, [pc, #76]	; (dd8 <LCD_Frame1+0x58>)
     d8c:	47a0      	blx	r4
	LCD_Print("==================");
     d8e:	4f13      	ldr	r7, [pc, #76]	; (ddc <LCD_Frame1+0x5c>)
     d90:	1c38      	adds	r0, r7, #0
     d92:	4e13      	ldr	r6, [pc, #76]	; (de0 <LCD_Frame1+0x60>)
     d94:	47b0      	blx	r6
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     d96:	2093      	movs	r0, #147	; 0x93
     d98:	47a8      	blx	r5
void LCD_Frame1(){
	LCD_Setcursor(1,1);
	LCD_DataWrite(255);
	LCD_Print("==================");
	LCD_Setcursor(1,20);
	LCD_DataWrite(255);		//block symbol
     d9a:	20ff      	movs	r0, #255	; 0xff
     d9c:	47a0      	blx	r4
			case 3:
			LCD_CmdWrite(0x94+Column-1);
			break;
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     d9e:	20d4      	movs	r0, #212	; 0xd4
     da0:	47a8      	blx	r5
	LCD_Print("==================");
	LCD_Setcursor(1,20);
	LCD_DataWrite(255);		//block symbol
	
	LCD_Setcursor(4,1);
	LCD_DataWrite(255);
     da2:	20ff      	movs	r0, #255	; 0xff
     da4:	47a0      	blx	r4
	LCD_Print("==================");
     da6:	1c38      	adds	r0, r7, #0
     da8:	47b0      	blx	r6
			case 3:
			LCD_CmdWrite(0x94+Column-1);
			break;
			
			case 4:
			LCD_CmdWrite(0xD4+Column-1);
     daa:	20e7      	movs	r0, #231	; 0xe7
     dac:	47a8      	blx	r5
	
	LCD_Setcursor(4,1);
	LCD_DataWrite(255);
	LCD_Print("==================");
	LCD_Setcursor(4,20);
	LCD_DataWrite(255);
     dae:	20ff      	movs	r0, #255	; 0xff
     db0:	47a0      	blx	r4
			case 1:
			LCD_CmdWrite(0x80+Column-1);
			break;
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     db2:	20c0      	movs	r0, #192	; 0xc0
     db4:	47a8      	blx	r5
	LCD_Print("==================");
	LCD_Setcursor(4,20);
	LCD_DataWrite(255);
	
	LCD_Setcursor(2,1);
	LCD_DataWrite(0);		// '||' symbol
     db6:	2000      	movs	r0, #0
     db8:	47a0      	blx	r4
			case 1:
			LCD_CmdWrite(0x80+Column-1);
			break;
			
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
     dba:	20d3      	movs	r0, #211	; 0xd3
     dbc:	47a8      	blx	r5
	
	LCD_Setcursor(2,1);
	LCD_DataWrite(0);		// '||' symbol
	
	LCD_Setcursor(2,20);
	LCD_DataWrite(0);
     dbe:	2000      	movs	r0, #0
     dc0:	47a0      	blx	r4
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
			break;
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     dc2:	2094      	movs	r0, #148	; 0x94
     dc4:	47a8      	blx	r5
	LCD_DataWrite(0);		// '||' symbol
	
	LCD_Setcursor(2,20);
	LCD_DataWrite(0);
	LCD_Setcursor(3,1);
	LCD_DataWrite(0);
     dc6:	2000      	movs	r0, #0
     dc8:	47a0      	blx	r4
			case 2:
			LCD_CmdWrite(0xC0+Column-1);
			break;
			
			case 3:
			LCD_CmdWrite(0x94+Column-1);
     dca:	20a7      	movs	r0, #167	; 0xa7
     dcc:	47a8      	blx	r5
	LCD_Setcursor(2,20);
	LCD_DataWrite(0);
	LCD_Setcursor(3,1);
	LCD_DataWrite(0);
	LCD_Setcursor(3,20);
	LCD_DataWrite(0);
     dce:	2000      	movs	r0, #0
     dd0:	47a0      	blx	r4
}
     dd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     dd4:	00000c49 	.word	0x00000c49
     dd8:	00000be9 	.word	0x00000be9
     ddc:	000023c8 	.word	0x000023c8
     de0:	00000c1d 	.word	0x00000c1d

00000de4 <LCD_CursorOn>:
	//LCD_DataWrite('|');
	//LCD_Setcursor(3,20);
	//LCD_DataWrite('|');
}

void LCD_CursorOn(){
     de4:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x0E);
     de6:	200e      	movs	r0, #14
     de8:	4b01      	ldr	r3, [pc, #4]	; (df0 <LCD_CursorOn+0xc>)
     dea:	4798      	blx	r3
}
     dec:	bd08      	pop	{r3, pc}
     dee:	46c0      	nop			; (mov r8, r8)
     df0:	00000c49 	.word	0x00000c49

00000df4 <LCD_CursorOff>:

void LCD_CursorOff(){
     df4:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x0C);
     df6:	200c      	movs	r0, #12
     df8:	4b01      	ldr	r3, [pc, #4]	; (e00 <LCD_CursorOff+0xc>)
     dfa:	4798      	blx	r3
}
     dfc:	bd08      	pop	{r3, pc}
     dfe:	46c0      	nop			; (mov r8, r8)
     e00:	00000c49 	.word	0x00000c49

00000e04 <LCD_Clrscr>:

void LCD_CursorBlink(){
	LCD_CmdWrite(0x0F);
}

void LCD_Clrscr(){
     e04:	b510      	push	{r4, lr}
	LCD_CmdWrite(0x01);
     e06:	2001      	movs	r0, #1
     e08:	4c02      	ldr	r4, [pc, #8]	; (e14 <LCD_Clrscr+0x10>)
     e0a:	47a0      	blx	r4
//for eg. LCD_Setcursor(1,15), for row 1st and column 15 on LCD, since numbering here starts from 0.
{
	switch(Row)		
	{
			case 1:
			LCD_CmdWrite(0x80+Column-1);
     e0c:	2080      	movs	r0, #128	; 0x80
     e0e:	47a0      	blx	r4
}

void LCD_Clrscr(){
	LCD_CmdWrite(0x01);
	LCD_Setcursor(1,1);
}
     e10:	bd10      	pop	{r4, pc}
     e12:	46c0      	nop			; (mov r8, r8)
     e14:	00000c49 	.word	0x00000c49

00000e18 <LCD_PowerOff>:
void LCD_PowerOff(){
     e18:	b508      	push	{r3, lr}
//  [7/25/2015 sajid]
	LCD_CmdWrite(0x13);	//sets internal power off
     e1a:	2013      	movs	r0, #19
     e1c:	4b02      	ldr	r3, [pc, #8]	; (e28 <LCD_PowerOff+0x10>)
     e1e:	4798      	blx	r3
	checkbusy();  
     e20:	4b02      	ldr	r3, [pc, #8]	; (e2c <LCD_PowerOff+0x14>)
     e22:	4798      	blx	r3
//---
}
     e24:	bd08      	pop	{r3, pc}
     e26:	46c0      	nop			; (mov r8, r8)
     e28:	00000c49 	.word	0x00000c49
     e2c:	00000b51 	.word	0x00000b51

00000e30 <LCD_PowerOn>:
void LCD_PowerOn(){
     e30:	b508      	push	{r3, lr}
	LCD_CmdWrite(0x17);	//sets internal power ON
     e32:	2017      	movs	r0, #23
     e34:	4b02      	ldr	r3, [pc, #8]	; (e40 <LCD_PowerOn+0x10>)
     e36:	4798      	blx	r3
	checkbusy();
     e38:	4b02      	ldr	r3, [pc, #8]	; (e44 <LCD_PowerOn+0x14>)
     e3a:	4798      	blx	r3
}
     e3c:	bd08      	pop	{r3, pc}
     e3e:	46c0      	nop			; (mov r8, r8)
     e40:	00000c49 	.word	0x00000c49
     e44:	00000b51 	.word	0x00000b51

00000e48 <LCD_Init>:
#include "CharLCD.h"
#include "Delay.h"

	
void LCD_Init(void)
{
     e48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
//First Setup All port pins properly
//Setup port as output and pin LCD_D7 as output with input read enable.
pinMode(LCD_EN, OUTPUT);
     e4a:	2014      	movs	r0, #20
     e4c:	2100      	movs	r1, #0
     e4e:	4c2a      	ldr	r4, [pc, #168]	; (ef8 <LCD_Init+0xb0>)
     e50:	47a0      	blx	r4
PinClr(LCD_EN);
     e52:	4d2a      	ldr	r5, [pc, #168]	; (efc <LCD_Init+0xb4>)
     e54:	2380      	movs	r3, #128	; 0x80
     e56:	035b      	lsls	r3, r3, #13
     e58:	602b      	str	r3, [r5, #0]
pinMode(LCD_D4, OUTPUT);		//D4
     e5a:	2010      	movs	r0, #16
     e5c:	2100      	movs	r1, #0
     e5e:	47a0      	blx	r4
pinMode(LCD_D5, OUTPUT);		//D5
     e60:	2011      	movs	r0, #17
     e62:	2100      	movs	r1, #0
     e64:	47a0      	blx	r4
pinMode(LCD_D6, OUTPUT);		//D6
     e66:	2012      	movs	r0, #18
     e68:	2100      	movs	r1, #0
     e6a:	47a0      	blx	r4
pinMode(LCD_D7, OUTPUT);		//D7, will be changed when we need to read back busy flag
     e6c:	2013      	movs	r0, #19
     e6e:	2100      	movs	r1, #0
     e70:	47a0      	blx	r4

pinMode(LCD_RS, OUTPUT);
     e72:	200a      	movs	r0, #10
     e74:	2100      	movs	r1, #0
     e76:	47a0      	blx	r4
pinMode(LCD_RWb, OUTPUT);
     e78:	2015      	movs	r0, #21
     e7a:	2100      	movs	r1, #0
     e7c:	47a0      	blx	r4

//------------------------------------------------------------------------

 _data_pins[0] = LCD_D4;
     e7e:	4b20      	ldr	r3, [pc, #128]	; (f00 <LCD_Init+0xb8>)
     e80:	2210      	movs	r2, #16
     e82:	701a      	strb	r2, [r3, #0]
 _data_pins[1] = LCD_D5;
     e84:	2211      	movs	r2, #17
     e86:	705a      	strb	r2, [r3, #1]
 _data_pins[2] = LCD_D6;
     e88:	2212      	movs	r2, #18
     e8a:	709a      	strb	r2, [r3, #2]
 _data_pins[3] = LCD_D7;
     e8c:	2213      	movs	r2, #19
     e8e:	70da      	strb	r2, [r3, #3]
 
	
	// Select the Command Register by pulling RS pin LOW
	PinClr(LCD_RS);
     e90:	2380      	movs	r3, #128	; 0x80
     e92:	00db      	lsls	r3, r3, #3
     e94:	602b      	str	r3, [r5, #0]
	// Select the Write Operation  by pulling RW pin LOW
	PinClr(LCD_RWb);
     e96:	2380      	movs	r3, #128	; 0x80
     e98:	039b      	lsls	r3, r3, #14
     e9a:	602b      	str	r3, [r5, #0]
	

//LCD commands start here

	delay_ms(100);		//w8 for power rail to stabilize
     e9c:	2064      	movs	r0, #100	; 0x64
     e9e:	4e19      	ldr	r6, [pc, #100]	; (f04 <LCD_Init+0xbc>)
     ea0:	47b0      	blx	r6
	
		LCD_CmdWrite(0x08);		//Turn off display, very important for OLED
     ea2:	2008      	movs	r0, #8
     ea4:	4d18      	ldr	r5, [pc, #96]	; (f08 <LCD_Init+0xc0>)
     ea6:	47a8      	blx	r5
		checkbusy();
     ea8:	4c18      	ldr	r4, [pc, #96]	; (f0c <LCD_Init+0xc4>)
     eaa:	47a0      	blx	r4
		
	write4bits(0x03);	//put LCD in 8 bit mode
     eac:	2003      	movs	r0, #3
     eae:	4f18      	ldr	r7, [pc, #96]	; (f10 <LCD_Init+0xc8>)
     eb0:	47b8      	blx	r7
	delay_ms(100);
     eb2:	2064      	movs	r0, #100	; 0x64
     eb4:	47b0      	blx	r6
	
	write4bits(0x03);	//again
     eb6:	2003      	movs	r0, #3
     eb8:	47b8      	blx	r7
	delay_ms(100);
     eba:	2064      	movs	r0, #100	; 0x64
     ebc:	47b0      	blx	r6
	
	write4bits(0x03);	//again
     ebe:	2003      	movs	r0, #3
     ec0:	47b8      	blx	r7
	delay_ms(100);
     ec2:	2064      	movs	r0, #100	; 0x64
     ec4:	47b0      	blx	r6
	
	write4bits(0x02);  //Initialize the LCD in 4bit Mode
     ec6:	2002      	movs	r0, #2
     ec8:	47b8      	blx	r7
	delay_ms(100);
     eca:	2064      	movs	r0, #100	; 0x64
     ecc:	47b0      	blx	r6
			
	LCD_CmdWrite(0x28);	//LCD in 4 bit, 2 lines, 5x8 dots 
     ece:	2028      	movs	r0, #40	; 0x28
     ed0:	47a8      	blx	r5
	checkbusy();
     ed2:	47a0      	blx	r4

	//  [7/25/2015 sajid]
	LCD_CmdWrite(0x08);		//Turn off display, very important for OLED
     ed4:	2008      	movs	r0, #8
     ed6:	47a8      	blx	r5
	checkbusy();	
     ed8:	47a0      	blx	r4
	//  [7/25/2015 sajid]
	//LCD_PowerOff();
	
	LCD_CmdWrite(0x06);		//Entry mode:Increment, No display shift
     eda:	2006      	movs	r0, #6
     edc:	47a8      	blx	r5
	checkbusy();
     ede:	47a0      	blx	r4
	
	LCD_CmdWrite(0x0E);		// Display ON, cursor ON, Blink Off
     ee0:	200e      	movs	r0, #14
     ee2:	47a8      	blx	r5
	checkbusy();  
     ee4:	47a0      	blx	r4
	
	LCD_CmdWrite(0x01);
     ee6:	2001      	movs	r0, #1
     ee8:	47a8      	blx	r5
	checkbusy();  // Clear the LCD
     eea:	47a0      	blx	r4
	
	LCD_CmdWrite(0x80);
     eec:	2080      	movs	r0, #128	; 0x80
     eee:	47a8      	blx	r5
	checkbusy();  // Move the Cursor to First line First Position
     ef0:	47a0      	blx	r4
	LCD_PowerOn();
     ef2:	4b08      	ldr	r3, [pc, #32]	; (f14 <LCD_Init+0xcc>)
     ef4:	4798      	blx	r3
}
     ef6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     ef8:	00001549 	.word	0x00001549
     efc:	41004414 	.word	0x41004414
     f00:	20000078 	.word	0x20000078
     f04:	00000f71 	.word	0x00000f71
     f08:	00000c49 	.word	0x00000c49
     f0c:	00000b51 	.word	0x00000b51
     f10:	00000af9 	.word	0x00000af9
     f14:	00000e31 	.word	0x00000e31

00000f18 <delay_1us>:
#include "compiler.h"

#include "Delay.h"


 void delay_1us() {			//gives 1 us delay
     f18:	b082      	sub	sp, #8
	 for (volatile int iter=0; iter<2;iter++)
     f1a:	2300      	movs	r3, #0
     f1c:	9301      	str	r3, [sp, #4]
     f1e:	9b01      	ldr	r3, [sp, #4]
     f20:	2b01      	cmp	r3, #1
     f22:	dc07      	bgt.n	f34 <delay_1us+0x1c>
	 {
		 asm("NOP");		 
     f24:	46c0      	nop			; (mov r8, r8)
		 asm("NOP");		 
     f26:	46c0      	nop			; (mov r8, r8)

#include "Delay.h"


 void delay_1us() {			//gives 1 us delay
	 for (volatile int iter=0; iter<2;iter++)
     f28:	9b01      	ldr	r3, [sp, #4]
     f2a:	3301      	adds	r3, #1
     f2c:	9301      	str	r3, [sp, #4]
     f2e:	9b01      	ldr	r3, [sp, #4]
     f30:	2b01      	cmp	r3, #1
     f32:	ddf7      	ble.n	f24 <delay_1us+0xc>
	 {
		 asm("NOP");		 
		 asm("NOP");		 
	 }
 }
     f34:	b002      	add	sp, #8
     f36:	4770      	bx	lr

00000f38 <delay_us>:

void delay_us(volatile uint32_t iter_us){	//gives us delay
     f38:	b510      	push	{r4, lr}
     f3a:	b082      	sub	sp, #8
     f3c:	9001      	str	r0, [sp, #4]
	while(iter_us!=0){
     f3e:	9b01      	ldr	r3, [sp, #4]
     f40:	2b00      	cmp	r3, #0
     f42:	d007      	beq.n	f54 <delay_us+0x1c>
		delay_1us();
     f44:	4c04      	ldr	r4, [pc, #16]	; (f58 <delay_us+0x20>)
     f46:	47a0      	blx	r4
		iter_us--;
     f48:	9b01      	ldr	r3, [sp, #4]
     f4a:	3b01      	subs	r3, #1
     f4c:	9301      	str	r3, [sp, #4]
		 asm("NOP");		 
	 }
 }

void delay_us(volatile uint32_t iter_us){	//gives us delay
	while(iter_us!=0){
     f4e:	9b01      	ldr	r3, [sp, #4]
     f50:	2b00      	cmp	r3, #0
     f52:	d1f8      	bne.n	f46 <delay_us+0xe>
		delay_1us();
		iter_us--;
	}
}
     f54:	b002      	add	sp, #8
     f56:	bd10      	pop	{r4, pc}
     f58:	00000f19 	.word	0x00000f19

00000f5c <delay_1ms>:

void delay_1ms() {
     f5c:	b508      	push	{r3, lr}
		delay_us(1050);	//value adjusted to give 1ms delay
     f5e:	4802      	ldr	r0, [pc, #8]	; (f68 <delay_1ms+0xc>)
     f60:	4b02      	ldr	r3, [pc, #8]	; (f6c <delay_1ms+0x10>)
     f62:	4798      	blx	r3

}
     f64:	bd08      	pop	{r3, pc}
     f66:	46c0      	nop			; (mov r8, r8)
     f68:	0000041a 	.word	0x0000041a
     f6c:	00000f39 	.word	0x00000f39

00000f70 <delay_ms>:

void delay_ms(volatile uint32_t iter_ms){
     f70:	b510      	push	{r4, lr}
     f72:	b082      	sub	sp, #8
     f74:	9001      	str	r0, [sp, #4]
	while (iter_ms)
     f76:	9b01      	ldr	r3, [sp, #4]
     f78:	2b00      	cmp	r3, #0
     f7a:	d007      	beq.n	f8c <delay_ms+0x1c>
	{
		delay_1ms();
     f7c:	4c04      	ldr	r4, [pc, #16]	; (f90 <delay_ms+0x20>)
     f7e:	47a0      	blx	r4
		iter_ms--;
     f80:	9b01      	ldr	r3, [sp, #4]
     f82:	3b01      	subs	r3, #1
     f84:	9301      	str	r3, [sp, #4]
		delay_us(1050);	//value adjusted to give 1ms delay

}

void delay_ms(volatile uint32_t iter_ms){
	while (iter_ms)
     f86:	9b01      	ldr	r3, [sp, #4]
     f88:	2b00      	cmp	r3, #0
     f8a:	d1f8      	bne.n	f7e <delay_ms+0xe>
	{
		delay_1ms();
		iter_ms--;
	}
}
     f8c:	b002      	add	sp, #8
     f8e:	bd10      	pop	{r4, pc}
     f90:	00000f5d 	.word	0x00000f5d

00000f94 <delay_sec>:

void delay_sec(volatile uint16_t iter_s){
     f94:	b570      	push	{r4, r5, r6, lr}
     f96:	b082      	sub	sp, #8
     f98:	466b      	mov	r3, sp
     f9a:	80d8      	strh	r0, [r3, #6]
     f9c:	3306      	adds	r3, #6
	while(iter_s!=0){
     f9e:	881b      	ldrh	r3, [r3, #0]
     fa0:	b29b      	uxth	r3, r3
     fa2:	2b00      	cmp	r3, #0
     fa4:	d00e      	beq.n	fc4 <delay_sec+0x30>
		delay_ms(1000);
     fa6:	26fa      	movs	r6, #250	; 0xfa
     fa8:	00b6      	lsls	r6, r6, #2
     faa:	4d07      	ldr	r5, [pc, #28]	; (fc8 <delay_sec+0x34>)
		iter_s--;
     fac:	466c      	mov	r4, sp
     fae:	3406      	adds	r4, #6
	}
}

void delay_sec(volatile uint16_t iter_s){
	while(iter_s!=0){
		delay_ms(1000);
     fb0:	1c30      	adds	r0, r6, #0
     fb2:	47a8      	blx	r5
		iter_s--;
     fb4:	8823      	ldrh	r3, [r4, #0]
     fb6:	3b01      	subs	r3, #1
     fb8:	b29b      	uxth	r3, r3
     fba:	8023      	strh	r3, [r4, #0]
		iter_ms--;
	}
}

void delay_sec(volatile uint16_t iter_s){
	while(iter_s!=0){
     fbc:	8823      	ldrh	r3, [r4, #0]
     fbe:	b29b      	uxth	r3, r3
     fc0:	2b00      	cmp	r3, #0
     fc2:	d1f5      	bne.n	fb0 <delay_sec+0x1c>
		delay_ms(1000);
		iter_s--;
	}
	
     fc4:	b002      	add	sp, #8
     fc6:	bd70      	pop	{r4, r5, r6, pc}
     fc8:	00000f71 	.word	0x00000f71

00000fcc <LCD_DispFourOptionsIncrementingFrom>:

/************************************************************************/
/* Has all high level function of LCD to Handle Menu based UI			*/
/************************************************************************/

void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
     fcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     fce:	0085      	lsls	r5, r0, #2
     fd0:	1828      	adds	r0, r5, r0
     fd2:	0080      	lsls	r0, r0, #2
     fd4:	180d      	adds	r5, r1, r0
	for (char i=0; i<=3; i++)
     fd6:	2400      	movs	r4, #0
	{
		LCD_Setcursor(i+1,1);
     fd8:	4f06      	ldr	r7, [pc, #24]	; (ff4 <LCD_DispFourOptionsIncrementingFrom+0x28>)
		LCD_Print(MenuOptions[StartLine+i]);
     fda:	4e07      	ldr	r6, [pc, #28]	; (ff8 <LCD_DispFourOptionsIncrementingFrom+0x2c>)
/************************************************************************/

void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
	for (char i=0; i<=3; i++)
	{
		LCD_Setcursor(i+1,1);
     fdc:	3401      	adds	r4, #1
     fde:	b2e4      	uxtb	r4, r4
     fe0:	1c20      	adds	r0, r4, #0
     fe2:	2101      	movs	r1, #1
     fe4:	47b8      	blx	r7
		LCD_Print(MenuOptions[StartLine+i]);
     fe6:	1c28      	adds	r0, r5, #0
     fe8:	47b0      	blx	r6
     fea:	3514      	adds	r5, #20
/************************************************************************/
/* Has all high level function of LCD to Handle Menu based UI			*/
/************************************************************************/

void LCD_DispFourOptionsIncrementingFrom(uint8_t StartLine, const char MenuOptions[][LCDCOLS]){
	for (char i=0; i<=3; i++)
     fec:	2c04      	cmp	r4, #4
     fee:	d1f5      	bne.n	fdc <LCD_DispFourOptionsIncrementingFrom+0x10>
	{
		LCD_Setcursor(i+1,1);
		LCD_Print(MenuOptions[StartLine+i]);
	}
	
}
     ff0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     ff2:	46c0      	nop			; (mov r8, r8)
     ff4:	00000c79 	.word	0x00000c79
     ff8:	00000c1d 	.word	0x00000c1d

00000ffc <LCD_DispMenuArrow>:

void LCD_DispMenuArrow(uint8_t Row){
     ffc:	b570      	push	{r4, r5, r6, lr}
     ffe:	1c06      	adds	r6, r0, #0
	//arrow symbol pointing menu option is shown at extreme right on LCD
	//Clear other Rows
	LCD_Setcursor(1,20);
    1000:	2001      	movs	r0, #1
    1002:	2114      	movs	r1, #20
    1004:	4d0c      	ldr	r5, [pc, #48]	; (1038 <LCD_DispMenuArrow+0x3c>)
    1006:	47a8      	blx	r5
	LCD_DataWrite(' ');
    1008:	2020      	movs	r0, #32
    100a:	4c0c      	ldr	r4, [pc, #48]	; (103c <LCD_DispMenuArrow+0x40>)
    100c:	47a0      	blx	r4
	LCD_Setcursor(2,20);
    100e:	2002      	movs	r0, #2
    1010:	2114      	movs	r1, #20
    1012:	47a8      	blx	r5
	LCD_DataWrite(' ');
    1014:	2020      	movs	r0, #32
    1016:	47a0      	blx	r4
	LCD_Setcursor(3,20);
    1018:	2003      	movs	r0, #3
    101a:	2114      	movs	r1, #20
    101c:	47a8      	blx	r5
	LCD_DataWrite(' ');
    101e:	2020      	movs	r0, #32
    1020:	47a0      	blx	r4
	LCD_Setcursor(4,20);
    1022:	2004      	movs	r0, #4
    1024:	2114      	movs	r1, #20
    1026:	47a8      	blx	r5
	LCD_DataWrite(' ');
    1028:	2020      	movs	r0, #32
    102a:	47a0      	blx	r4
	
	LCD_Setcursor(Row,20);
    102c:	1c30      	adds	r0, r6, #0
    102e:	2114      	movs	r1, #20
    1030:	47a8      	blx	r5
	LCD_DataWrite(ARROW);
    1032:	207f      	movs	r0, #127	; 0x7f
    1034:	47a0      	blx	r4
}
    1036:	bd70      	pop	{r4, r5, r6, pc}
    1038:	00000c79 	.word	0x00000c79
    103c:	00000be9 	.word	0x00000be9

00001040 <LCD_MenuHandle>:
	MenuIndex=1;
	return MenuIndex;
}

uint8_t LCD_MenuHandle(uint8_t TotalOptions, const char MenuOptions[][LCDCOLS])
{
    1040:	b5f0      	push	{r4, r5, r6, r7, lr}
    1042:	465f      	mov	r7, fp
    1044:	4656      	mov	r6, sl
    1046:	464d      	mov	r5, r9
    1048:	4644      	mov	r4, r8
    104a:	b4f0      	push	{r4, r5, r6, r7}
    104c:	b083      	sub	sp, #12
    104e:	4680      	mov	r8, r0
    1050:	4689      	mov	r9, r1
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
	//In LCD_DispOptionsIncrementingFrom(optionNo, OptionStringArray) DispOptionno is used to keep track of displayed MSG group
	int8_t DispOptionNo=0;
	LCD_DispFourOptionsIncrementingFrom(0, MenuOptions);	//displays Strings from 0 to 3 of the given string 2D array
    1052:	2000      	movs	r0, #0
    1054:	4b3c      	ldr	r3, [pc, #240]	; (1148 <LCD_MenuHandle+0x108>)
    1056:	4798      	blx	r3
	//displays arrow symbol according to location on LCD at 20th Column and Row given by ArrowLoc
	LCD_DispMenuArrow(ArrowLoc);
    1058:	2001      	movs	r0, #1
    105a:	4b3c      	ldr	r3, [pc, #240]	; (114c <LCD_MenuHandle+0x10c>)
    105c:	4798      	blx	r3
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
	//In LCD_DispOptionsIncrementingFrom(optionNo, OptionStringArray) DispOptionno is used to keep track of displayed MSG group
	int8_t DispOptionNo=0;
    105e:	2700      	movs	r7, #0
{
	//TotalOptions is nothing but no. of items in menu
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
	//keeps row no where arrow symbol is displayed (1-4, since 4 line LCD).
	int8_t ArrowLoc=1;		//kept it signed to facilitate bounds checking
    1060:	2501      	movs	r5, #1

uint8_t LCD_MenuHandle(uint8_t TotalOptions, const char MenuOptions[][LCDCOLS])
{
	//TotalOptions is nothing but no. of items in menu
	//Keeps actual option no. from 1 to TotalOptions
	int8_t MenuIndex=1;		//keep it signed to facilitate bounds checking
    1062:	2601      	movs	r6, #1
				MenuIndex++;
				ArrowLoc++;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
				{
					if (DispOptionNo==(TotalOptions-4))
    1064:	2204      	movs	r2, #4
    1066:	4252      	negs	r2, r2
    1068:	4692      	mov	sl, r2
    106a:	44c2      	add	sl, r8
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
				if (ArrowLoc<1)
				{
					if (DispOptionNo==0)
					{
						DispOptionNo=TotalOptions-4;
    106c:	4653      	mov	r3, sl
    106e:	b2db      	uxtb	r3, r3
    1070:	469b      	mov	fp, r3
    1072:	b2da      	uxtb	r2, r3
    1074:	9201      	str	r2, [sp, #4]
	LCD_DispFourOptionsIncrementingFrom(0, MenuOptions);	//displays Strings from 0 to 3 of the given string 2D array
	//displays arrow symbol according to location on LCD at 20th Column and Row given by ArrowLoc
	LCD_DispMenuArrow(ArrowLoc);
	
	while(1){	//loop forever, this function will be exited by press EnterKey or ParaKey
		if(KeyDetected())
    1076:	4c36      	ldr	r4, [pc, #216]	; (1150 <LCD_MenuHandle+0x110>)
    1078:	47a0      	blx	r4
    107a:	2800      	cmp	r0, #0
    107c:	d0fc      	beq.n	1078 <LCD_MenuHandle+0x38>
		{//comes here when key is pressed
			Keyscan();		//check which key is pressed
    107e:	4b35      	ldr	r3, [pc, #212]	; (1154 <LCD_MenuHandle+0x114>)
    1080:	4798      	blx	r3
			if(IncrKey)		//increment key pressed
    1082:	4b35      	ldr	r3, [pc, #212]	; (1158 <LCD_MenuHandle+0x118>)
    1084:	781b      	ldrb	r3, [r3, #0]
    1086:	2b00      	cmp	r3, #0
    1088:	d021      	beq.n	10ce <LCD_MenuHandle+0x8e>
			{
				MenuIndex--;
    108a:	3e01      	subs	r6, #1
    108c:	b2f3      	uxtb	r3, r6
				ArrowLoc--;
    108e:	3d01      	subs	r5, #1
    1090:	b2ed      	uxtb	r5, r5
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
    1092:	4642      	mov	r2, r8
    1094:	b2d6      	uxtb	r6, r2
	LCD_Setcursor(Row,20);
	LCD_DataWrite(ARROW);
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
    1096:	b25a      	sxtb	r2, r3
    1098:	2a00      	cmp	r2, #0
    109a:	dd04      	ble.n	10a6 <LCD_MenuHandle+0x66>
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
    109c:	b271      	sxtb	r1, r6
	MenuIndex=1;
    109e:	2601      	movs	r6, #1
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
    10a0:	428a      	cmp	r2, r1
    10a2:	dc00      	bgt.n	10a6 <LCD_MenuHandle+0x66>
    10a4:	1c1e      	adds	r6, r3, #0
			if(IncrKey)		//increment key pressed
			{
				MenuIndex--;
				ArrowLoc--;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);	//Adjust MenuIndex if it is below zero or above Totaloptions
				if (ArrowLoc<1)
    10a6:	b26b      	sxtb	r3, r5
    10a8:	2b00      	cmp	r3, #0
    10aa:	dc41      	bgt.n	1130 <LCD_MenuHandle+0xf0>
				{
					if (DispOptionNo==0)
    10ac:	2f00      	cmp	r7, #0
    10ae:	d106      	bne.n	10be <LCD_MenuHandle+0x7e>
					{
						DispOptionNo=TotalOptions-4;
    10b0:	9f01      	ldr	r7, [sp, #4]
						ArrowLoc=4;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
    10b2:	4658      	mov	r0, fp
    10b4:	4649      	mov	r1, r9
    10b6:	4b24      	ldr	r3, [pc, #144]	; (1148 <LCD_MenuHandle+0x108>)
    10b8:	4798      	blx	r3
				if (ArrowLoc<1)
				{
					if (DispOptionNo==0)
					{
						DispOptionNo=TotalOptions-4;
						ArrowLoc=4;
    10ba:	2504      	movs	r5, #4
    10bc:	e038      	b.n	1130 <LCD_MenuHandle+0xf0>
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
					}
					else
					{
						DispOptionNo--;
    10be:	3f01      	subs	r7, #1
    10c0:	b2ff      	uxtb	r7, r7
						ArrowLoc=1;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
    10c2:	b2f8      	uxtb	r0, r7
    10c4:	4649      	mov	r1, r9
    10c6:	4b20      	ldr	r3, [pc, #128]	; (1148 <LCD_MenuHandle+0x108>)
    10c8:	4798      	blx	r3
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);						
					}
					else
					{
						DispOptionNo--;
						ArrowLoc=1;
    10ca:	2501      	movs	r5, #1
    10cc:	e030      	b.n	1130 <LCD_MenuHandle+0xf0>
					}
					
				}
			}

			else if(DecrKey)
    10ce:	4b23      	ldr	r3, [pc, #140]	; (115c <LCD_MenuHandle+0x11c>)
    10d0:	781b      	ldrb	r3, [r3, #0]
    10d2:	2b00      	cmp	r3, #0
    10d4:	d022      	beq.n	111c <LCD_MenuHandle+0xdc>
			{
				MenuIndex++;
    10d6:	1c73      	adds	r3, r6, #1
    10d8:	b2db      	uxtb	r3, r3
				ArrowLoc++;
    10da:	3501      	adds	r5, #1
    10dc:	b2ed      	uxtb	r5, r5
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
    10de:	4642      	mov	r2, r8
    10e0:	b2d6      	uxtb	r6, r2
	LCD_Setcursor(Row,20);
	LCD_DataWrite(ARROW);
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
    10e2:	b25a      	sxtb	r2, r3
    10e4:	2a00      	cmp	r2, #0
    10e6:	dd04      	ble.n	10f2 <LCD_MenuHandle+0xb2>
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
    10e8:	b271      	sxtb	r1, r6
	MenuIndex=1;
    10ea:	2601      	movs	r6, #1
}

int8_t CheckMenuIndexBounds(int8_t MenuIndex, int8_t TotalOptions){
	if (MenuIndex<1)
	MenuIndex=TotalOptions;
	else if (MenuIndex>TotalOptions)
    10ec:	428a      	cmp	r2, r1
    10ee:	dc00      	bgt.n	10f2 <LCD_MenuHandle+0xb2>
    10f0:	1c1e      	adds	r6, r3, #0
			else if(DecrKey)
			{
				MenuIndex++;
				ArrowLoc++;
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
    10f2:	b26b      	sxtb	r3, r5
    10f4:	2b04      	cmp	r3, #4
    10f6:	dd1b      	ble.n	1130 <LCD_MenuHandle+0xf0>
				{
					if (DispOptionNo==(TotalOptions-4))
    10f8:	b27b      	sxtb	r3, r7
    10fa:	4553      	cmp	r3, sl
    10fc:	d106      	bne.n	110c <LCD_MenuHandle+0xcc>
					{
						DispOptionNo=0;
						ArrowLoc=1;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
    10fe:	2000      	movs	r0, #0
    1100:	4649      	mov	r1, r9
    1102:	4b11      	ldr	r3, [pc, #68]	; (1148 <LCD_MenuHandle+0x108>)
    1104:	4798      	blx	r3
				MenuIndex=CheckMenuIndexBounds(MenuIndex, TotalOptions);
				if (ArrowLoc>4)
				{
					if (DispOptionNo==(TotalOptions-4))
					{
						DispOptionNo=0;
    1106:	2700      	movs	r7, #0
						ArrowLoc=1;
    1108:	2501      	movs	r5, #1
    110a:	e011      	b.n	1130 <LCD_MenuHandle+0xf0>
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
						
					}
					else
					{
						DispOptionNo++;
    110c:	3701      	adds	r7, #1
    110e:	b2ff      	uxtb	r7, r7
						ArrowLoc=4;
						LCD_DispFourOptionsIncrementingFrom(DispOptionNo, MenuOptions);
    1110:	b2f8      	uxtb	r0, r7
    1112:	4649      	mov	r1, r9
    1114:	4b0c      	ldr	r3, [pc, #48]	; (1148 <LCD_MenuHandle+0x108>)
    1116:	4798      	blx	r3
						
					}
					else
					{
						DispOptionNo++;
						ArrowLoc=4;
    1118:	2504      	movs	r5, #4
    111a:	e009      	b.n	1130 <LCD_MenuHandle+0xf0>
					}
					
				}
			}
			
			else if(EnterKey)
    111c:	4b10      	ldr	r3, [pc, #64]	; (1160 <LCD_MenuHandle+0x120>)
    111e:	781b      	ldrb	r3, [r3, #0]
    1120:	2b00      	cmp	r3, #0
    1122:	d001      	beq.n	1128 <LCD_MenuHandle+0xe8>
			{
				return MenuIndex;
    1124:	b2f0      	uxtb	r0, r6
    1126:	e008      	b.n	113a <LCD_MenuHandle+0xfa>
			}
			else if (ParaKey)
    1128:	4b0e      	ldr	r3, [pc, #56]	; (1164 <LCD_MenuHandle+0x124>)
    112a:	781b      	ldrb	r3, [r3, #0]
    112c:	2b00      	cmp	r3, #0
    112e:	d103      	bne.n	1138 <LCD_MenuHandle+0xf8>
			{
				return 0;
			}
			LCD_DispMenuArrow(ArrowLoc);
    1130:	b2e8      	uxtb	r0, r5
    1132:	4b06      	ldr	r3, [pc, #24]	; (114c <LCD_MenuHandle+0x10c>)
    1134:	4798      	blx	r3
    1136:	e79e      	b.n	1076 <LCD_MenuHandle+0x36>
			{
				return MenuIndex;
			}
			else if (ParaKey)
			{
				return 0;
    1138:	2000      	movs	r0, #0
			}
			LCD_DispMenuArrow(ArrowLoc);
		}
	}
}
    113a:	b003      	add	sp, #12
    113c:	bc3c      	pop	{r2, r3, r4, r5}
    113e:	4690      	mov	r8, r2
    1140:	4699      	mov	r9, r3
    1142:	46a2      	mov	sl, r4
    1144:	46ab      	mov	fp, r5
    1146:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1148:	00000fcd 	.word	0x00000fcd
    114c:	00000ffd 	.word	0x00000ffd
    1150:	0000132d 	.word	0x0000132d
    1154:	00001369 	.word	0x00001369
    1158:	2000008c 	.word	0x2000008c
    115c:	2000008d 	.word	0x2000008d
    1160:	2000008b 	.word	0x2000008b
    1164:	20000089 	.word	0x20000089

00001168 <LCD_HorizCurPos>:
	}
}



void LCD_HorizCurPos(char CursorPos, char row1, char col1, char row2, char col2, char row3, char col3){
    1168:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    116a:	465f      	mov	r7, fp
    116c:	4656      	mov	r6, sl
    116e:	464d      	mov	r5, r9
    1170:	4644      	mov	r4, r8
    1172:	b4f0      	push	{r4, r5, r6, r7}
    1174:	1c04      	adds	r4, r0, #0
    1176:	4688      	mov	r8, r1
    1178:	1c17      	adds	r7, r2, #0
    117a:	1c1e      	adds	r6, r3, #0
    117c:	ad0a      	add	r5, sp, #40	; 0x28
    117e:	782d      	ldrb	r5, [r5, #0]
    1180:	46a9      	mov	r9, r5
    1182:	ad0b      	add	r5, sp, #44	; 0x2c
    1184:	782d      	ldrb	r5, [r5, #0]
    1186:	46aa      	mov	sl, r5
    1188:	ad0c      	add	r5, sp, #48	; 0x30
    118a:	782d      	ldrb	r5, [r5, #0]
    118c:	46ab      	mov	fp, r5
	LCD_CursorOn();
    118e:	4d10      	ldr	r5, [pc, #64]	; (11d0 <LCD_HorizCurPos+0x68>)
    1190:	47a8      	blx	r5
	switch(CursorPos){
    1192:	2c02      	cmp	r4, #2
    1194:	d008      	beq.n	11a8 <LCD_HorizCurPos+0x40>
    1196:	2c03      	cmp	r4, #3
    1198:	d00b      	beq.n	11b2 <LCD_HorizCurPos+0x4a>
    119a:	2c01      	cmp	r4, #1
    119c:	d10e      	bne.n	11bc <LCD_HorizCurPos+0x54>
		case 1:
		LCD_Setcursor(row1,col1);
    119e:	4640      	mov	r0, r8
    11a0:	1c39      	adds	r1, r7, #0
    11a2:	4b0c      	ldr	r3, [pc, #48]	; (11d4 <LCD_HorizCurPos+0x6c>)
    11a4:	4798      	blx	r3
		break;
    11a6:	e00d      	b.n	11c4 <LCD_HorizCurPos+0x5c>
		
		case 2:
		LCD_Setcursor(row2,col2);
    11a8:	1c30      	adds	r0, r6, #0
    11aa:	4649      	mov	r1, r9
    11ac:	4b09      	ldr	r3, [pc, #36]	; (11d4 <LCD_HorizCurPos+0x6c>)
    11ae:	4798      	blx	r3
		break;
    11b0:	e008      	b.n	11c4 <LCD_HorizCurPos+0x5c>
		
		case 3:
		LCD_Setcursor(row3,col3);
    11b2:	4650      	mov	r0, sl
    11b4:	4659      	mov	r1, fp
    11b6:	4b07      	ldr	r3, [pc, #28]	; (11d4 <LCD_HorizCurPos+0x6c>)
    11b8:	4798      	blx	r3
		break;
    11ba:	e003      	b.n	11c4 <LCD_HorizCurPos+0x5c>
		
		default: //any other value will show error on LCD
		LCD_OneLine(2, "Bug: LCD_HorizCur");
    11bc:	2002      	movs	r0, #2
    11be:	4906      	ldr	r1, [pc, #24]	; (11d8 <LCD_HorizCurPos+0x70>)
    11c0:	4b06      	ldr	r3, [pc, #24]	; (11dc <LCD_HorizCurPos+0x74>)
    11c2:	4798      	blx	r3
	}
}
    11c4:	bc3c      	pop	{r2, r3, r4, r5}
    11c6:	4690      	mov	r8, r2
    11c8:	4699      	mov	r9, r3
    11ca:	46a2      	mov	sl, r4
    11cc:	46ab      	mov	fp, r5
    11ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    11d0:	00000de5 	.word	0x00000de5
    11d4:	00000c79 	.word	0x00000c79
    11d8:	0000240c 	.word	0x0000240c
    11dc:	00000cfd 	.word	0x00000cfd

000011e0 <LCD_HorizontalScroll>:
/*	This function takes 2 or 3 options LCD positions and Scrolls 
	between them and returns selected value (1 or 2 or 3)
	row1, col1 corresponds to option1 and so on.
	If only 2 options are there then keep row3 and col3 zero*/
/*******************************************************************/
uint8_t LCD_HorizontalScroll(uint8_t DefaultPosition, char row1, char col1, char row2, char col2, char row3, char col3){
    11e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    11e2:	465f      	mov	r7, fp
    11e4:	4656      	mov	r6, sl
    11e6:	464d      	mov	r5, r9
    11e8:	4644      	mov	r4, r8
    11ea:	b4f0      	push	{r4, r5, r6, r7}
    11ec:	b087      	sub	sp, #28
    11ee:	4689      	mov	r9, r1
    11f0:	4690      	mov	r8, r2
    11f2:	1c1f      	adds	r7, r3, #0
    11f4:	ab10      	add	r3, sp, #64	; 0x40
    11f6:	781b      	ldrb	r3, [r3, #0]
    11f8:	469b      	mov	fp, r3
    11fa:	ab11      	add	r3, sp, #68	; 0x44
    11fc:	781e      	ldrb	r6, [r3, #0]
    11fe:	ab12      	add	r3, sp, #72	; 0x48
    1200:	781b      	ldrb	r3, [r3, #0]
    1202:	469a      	mov	sl, r3
		
	int8_t NoOfOpt=3;	//by default 3 option are to be scrolled
    1204:	4273      	negs	r3, r6
    1206:	4173      	adcs	r3, r6
    1208:	2203      	movs	r2, #3
    120a:	1ad2      	subs	r2, r2, r3
    120c:	9205      	str	r2, [sp, #20]
	//If row3 is 0 means only 2 options are to be scrolled
	if (row3==0)			
	NoOfOpt=2;	// modify no of options
	
	int8_t CurPoint=DefaultPosition;	
    120e:	b2c5      	uxtb	r5, r0
	//Put cursor on default option position
	LCD_HorizCurPos(DefaultPosition, row1, col1, row2, col2, row3, col3);
    1210:	4659      	mov	r1, fp
    1212:	9100      	str	r1, [sp, #0]
    1214:	9601      	str	r6, [sp, #4]
    1216:	4652      	mov	r2, sl
    1218:	9202      	str	r2, [sp, #8]
    121a:	4649      	mov	r1, r9
    121c:	4642      	mov	r2, r8
    121e:	1c3b      	adds	r3, r7, #0
    1220:	4c24      	ldr	r4, [pc, #144]	; (12b4 <LCD_HorizontalScroll+0xd4>)
    1222:	47a0      	blx	r4
	
	while(1){	//loop forever, this function will be exited by press EnterKey or ParaKey
		if(KeyDetected())
    1224:	4c24      	ldr	r4, [pc, #144]	; (12b8 <LCD_HorizontalScroll+0xd8>)
		{//comes here when key is pressed
			Keyscan();		//check which key is pressed
			if(NextKey)		//increment key pressed
    1226:	1c3b      	adds	r3, r7, #0
    1228:	4647      	mov	r7, r8
    122a:	1c32      	adds	r2, r6, #0
    122c:	4648      	mov	r0, r9
    122e:	9004      	str	r0, [sp, #16]
    1230:	4691      	mov	r9, r2
    1232:	4698      	mov	r8, r3
    1234:	9e04      	ldr	r6, [sp, #16]
	int8_t CurPoint=DefaultPosition;	
	//Put cursor on default option position
	LCD_HorizCurPos(DefaultPosition, row1, col1, row2, col2, row3, col3);
	
	while(1){	//loop forever, this function will be exited by press EnterKey or ParaKey
		if(KeyDetected())
    1236:	47a0      	blx	r4
    1238:	2800      	cmp	r0, #0
    123a:	d0fc      	beq.n	1236 <LCD_HorizontalScroll+0x56>
    123c:	9604      	str	r6, [sp, #16]
		{//comes here when key is pressed
			Keyscan();		//check which key is pressed
    123e:	4e1f      	ldr	r6, [pc, #124]	; (12bc <LCD_HorizontalScroll+0xdc>)
    1240:	47b0      	blx	r6
			if(NextKey)		//increment key pressed
    1242:	4e1f      	ldr	r6, [pc, #124]	; (12c0 <LCD_HorizontalScroll+0xe0>)
    1244:	7833      	ldrb	r3, [r6, #0]
    1246:	2b00      	cmp	r3, #0
    1248:	d007      	beq.n	125a <LCD_HorizontalScroll+0x7a>
			{
				CurPoint++;
    124a:	3501      	adds	r5, #1
    124c:	b2ed      	uxtb	r5, r5
				if (CurPoint>NoOfOpt)
    124e:	9e05      	ldr	r6, [sp, #20]
    1250:	b273      	sxtb	r3, r6
    1252:	b26a      	sxtb	r2, r5
    1254:	4293      	cmp	r3, r2
    1256:	db15      	blt.n	1284 <LCD_HorizontalScroll+0xa4>
    1258:	e017      	b.n	128a <LCD_HorizontalScroll+0xaa>
					CurPoint=1; //if overflows			
			}

			else if(PrevKey)
    125a:	4b1a      	ldr	r3, [pc, #104]	; (12c4 <LCD_HorizontalScroll+0xe4>)
    125c:	781b      	ldrb	r3, [r3, #0]
    125e:	2b00      	cmp	r3, #0
    1260:	d005      	beq.n	126e <LCD_HorizontalScroll+0x8e>
			{
				CurPoint--;
    1262:	3d01      	subs	r5, #1
    1264:	b2ed      	uxtb	r5, r5
				if (CurPoint<1)
    1266:	b26b      	sxtb	r3, r5
    1268:	2b00      	cmp	r3, #0
    126a:	dc0e      	bgt.n	128a <LCD_HorizontalScroll+0xaa>
    126c:	e00c      	b.n	1288 <LCD_HorizontalScroll+0xa8>
				CurPoint=NoOfOpt; //if overflows
			}
			
			else if(EnterKey)
    126e:	4b16      	ldr	r3, [pc, #88]	; (12c8 <LCD_HorizontalScroll+0xe8>)
    1270:	781b      	ldrb	r3, [r3, #0]
    1272:	2b00      	cmp	r3, #0
    1274:	d001      	beq.n	127a <LCD_HorizontalScroll+0x9a>
			{
				return (CurPoint);
    1276:	b2e8      	uxtb	r0, r5
    1278:	e015      	b.n	12a6 <LCD_HorizontalScroll+0xc6>
			}
			else if (ParaKey)
    127a:	4b14      	ldr	r3, [pc, #80]	; (12cc <LCD_HorizontalScroll+0xec>)
    127c:	781b      	ldrb	r3, [r3, #0]
    127e:	2b00      	cmp	r3, #0
    1280:	d003      	beq.n	128a <LCD_HorizontalScroll+0xaa>
    1282:	e00f      	b.n	12a4 <LCD_HorizontalScroll+0xc4>
			Keyscan();		//check which key is pressed
			if(NextKey)		//increment key pressed
			{
				CurPoint++;
				if (CurPoint>NoOfOpt)
					CurPoint=1; //if overflows			
    1284:	2501      	movs	r5, #1
    1286:	e000      	b.n	128a <LCD_HorizontalScroll+0xaa>

			else if(PrevKey)
			{
				CurPoint--;
				if (CurPoint<1)
				CurPoint=NoOfOpt; //if overflows
    1288:	9d05      	ldr	r5, [sp, #20]
			else if (ParaKey)
			{
				return 0;
			}
			
			LCD_HorizCurPos(CurPoint, row1, col1, row2, col2, row3, col3);
    128a:	b2e8      	uxtb	r0, r5
    128c:	4659      	mov	r1, fp
    128e:	9100      	str	r1, [sp, #0]
    1290:	464a      	mov	r2, r9
    1292:	9201      	str	r2, [sp, #4]
    1294:	4653      	mov	r3, sl
    1296:	9302      	str	r3, [sp, #8]
    1298:	9904      	ldr	r1, [sp, #16]
    129a:	1c3a      	adds	r2, r7, #0
    129c:	4643      	mov	r3, r8
    129e:	4e05      	ldr	r6, [pc, #20]	; (12b4 <LCD_HorizontalScroll+0xd4>)
    12a0:	47b0      	blx	r6
    12a2:	e7c7      	b.n	1234 <LCD_HorizontalScroll+0x54>
			{
				return (CurPoint);
			}
			else if (ParaKey)
			{
				return 0;
    12a4:	2000      	movs	r0, #0
			
			LCD_HorizCurPos(CurPoint, row1, col1, row2, col2, row3, col3);

		}
	}
}
    12a6:	b007      	add	sp, #28
    12a8:	bc3c      	pop	{r2, r3, r4, r5}
    12aa:	4690      	mov	r8, r2
    12ac:	4699      	mov	r9, r3
    12ae:	46a2      	mov	sl, r4
    12b0:	46ab      	mov	fp, r5
    12b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    12b4:	00001169 	.word	0x00001169
    12b8:	0000132d 	.word	0x0000132d
    12bc:	00001369 	.word	0x00001369
    12c0:	20000088 	.word	0x20000088
    12c4:	2000008a 	.word	0x2000008a
    12c8:	2000008b 	.word	0x2000008b
    12cc:	20000089 	.word	0x20000089

000012d0 <Config_MatrixKeypad>:
2 COL configured as Input with Pull up resistor, and 3 rows as Totem-pole OUTPUT
	1. We will first roughly chk for any key press by making all Rows LOW and Checking Both COL for LOW
	2. If any key detected we will wait for debounce period      
	3. And then clear each ROW and check each col to determine which key is pressed   */
/**********************************************************************************************************/
void Config_MatrixKeypad(){	//call this once in your program
    12d0:	b510      	push	{r4, lr}
	pinMode(COL1, INPUP);		//Make Columns Input with pull up.
    12d2:	202d      	movs	r0, #45	; 0x2d
    12d4:	2103      	movs	r1, #3
    12d6:	4c07      	ldr	r4, [pc, #28]	; (12f4 <Config_MatrixKeypad+0x24>)
    12d8:	47a0      	blx	r4
	pinMode(COL2, INPUP);		//INPUP stands for input with pull up.
    12da:	202e      	movs	r0, #46	; 0x2e
    12dc:	2103      	movs	r1, #3
    12de:	47a0      	blx	r4
	pinMode(ROW1, OUTPUT);		//Make ROWs as Output
    12e0:	202a      	movs	r0, #42	; 0x2a
    12e2:	2100      	movs	r1, #0
    12e4:	47a0      	blx	r4
	pinMode(ROW2, OUTPUT);
    12e6:	202b      	movs	r0, #43	; 0x2b
    12e8:	2100      	movs	r1, #0
    12ea:	47a0      	blx	r4
	pinMode(ROW3, OUTPUT);
    12ec:	202c      	movs	r0, #44	; 0x2c
    12ee:	2100      	movs	r1, #0
    12f0:	47a0      	blx	r4
}
    12f2:	bd10      	pop	{r4, pc}
    12f4:	00001549 	.word	0x00001549

000012f8 <ClearKeys>:

void ClearKeys(){
	ParaKey	=0;
    12f8:	2300      	movs	r3, #0
    12fa:	4a06      	ldr	r2, [pc, #24]	; (1314 <ClearKeys+0x1c>)
    12fc:	7013      	strb	r3, [r2, #0]
	RunKey	=0;
    12fe:	4a06      	ldr	r2, [pc, #24]	; (1318 <ClearKeys+0x20>)
    1300:	7013      	strb	r3, [r2, #0]
	StartKey=0;
    1302:	4a06      	ldr	r2, [pc, #24]	; (131c <ClearKeys+0x24>)
    1304:	7013      	strb	r3, [r2, #0]
	StopKey	=0;
    1306:	4a06      	ldr	r2, [pc, #24]	; (1320 <ClearKeys+0x28>)
    1308:	7013      	strb	r3, [r2, #0]
	UpdateKey=0;
    130a:	4a06      	ldr	r2, [pc, #24]	; (1324 <ClearKeys+0x2c>)
    130c:	7013      	strb	r3, [r2, #0]
	EnterKey =0;
    130e:	4a06      	ldr	r2, [pc, #24]	; (1328 <ClearKeys+0x30>)
    1310:	7013      	strb	r3, [r2, #0]
}
    1312:	4770      	bx	lr
    1314:	20000089 	.word	0x20000089
    1318:	2000008a 	.word	0x2000008a
    131c:	2000008c 	.word	0x2000008c
    1320:	2000008d 	.word	0x2000008d
    1324:	20000088 	.word	0x20000088
    1328:	2000008b 	.word	0x2000008b

0000132c <KeyDetected>:

bool KeyDetected(){
    132c:	b508      	push	{r3, lr}
	PinClr(ROW1);
    132e:	4b0c      	ldr	r3, [pc, #48]	; (1360 <KeyDetected+0x34>)
    1330:	2280      	movs	r2, #128	; 0x80
    1332:	00d2      	lsls	r2, r2, #3
    1334:	601a      	str	r2, [r3, #0]
	PinClr(ROW2);
    1336:	2280      	movs	r2, #128	; 0x80
    1338:	0112      	lsls	r2, r2, #4
    133a:	601a      	str	r2, [r3, #0]
	PinClr(ROW3);
    133c:	2280      	movs	r2, #128	; 0x80
    133e:	0152      	lsls	r2, r2, #5
    1340:	601a      	str	r2, [r3, #0]
	if ((digitalRead(COL1)==0) || (digitalRead(COL2)==0))
    1342:	202d      	movs	r0, #45	; 0x2d
    1344:	4b07      	ldr	r3, [pc, #28]	; (1364 <KeyDetected+0x38>)
    1346:	4798      	blx	r3
    1348:	1c03      	adds	r3, r0, #0
	{
		return(true);
    134a:	2001      	movs	r0, #1

bool KeyDetected(){
	PinClr(ROW1);
	PinClr(ROW2);
	PinClr(ROW3);
	if ((digitalRead(COL1)==0) || (digitalRead(COL2)==0))
    134c:	2b00      	cmp	r3, #0
    134e:	d005      	beq.n	135c <KeyDetected+0x30>
    1350:	202e      	movs	r0, #46	; 0x2e
    1352:	4b04      	ldr	r3, [pc, #16]	; (1364 <KeyDetected+0x38>)
    1354:	4798      	blx	r3
    1356:	2301      	movs	r3, #1
    1358:	4058      	eors	r0, r3
    135a:	b2c0      	uxtb	r0, r0
	{
		return(true);
	}
	else
		return(false);
}
    135c:	bd08      	pop	{r3, pc}
    135e:	46c0      	nop			; (mov r8, r8)
    1360:	41004494 	.word	0x41004494
    1364:	00001681 	.word	0x00001681

00001368 <Keyscan>:


void Keyscan(){			//call this whenever key status required
    1368:	b5f0      	push	{r4, r5, r6, r7, lr}
    136a:	4657      	mov	r7, sl
    136c:	464e      	mov	r6, r9
    136e:	4645      	mov	r5, r8
    1370:	b4e0      	push	{r5, r6, r7}

	if (KeyDetected())	//if both columns are high, then no key is pressed
    1372:	4b2f      	ldr	r3, [pc, #188]	; (1430 <Keyscan+0xc8>)
    1374:	4798      	blx	r3
    1376:	2800      	cmp	r0, #0
    1378:	d052      	beq.n	1420 <Keyscan+0xb8>
	{	//program will enter when any key is pressed
		delay_ms(debounce_ms);	//debounce delay
    137a:	2014      	movs	r0, #20
    137c:	4b2d      	ldr	r3, [pc, #180]	; (1434 <Keyscan+0xcc>)
    137e:	4798      	blx	r3
		if (KeyDetected())	//check again
    1380:	4b2b      	ldr	r3, [pc, #172]	; (1430 <Keyscan+0xc8>)
    1382:	4798      	blx	r3
    1384:	2800      	cmp	r0, #0
    1386:	d048      	beq.n	141a <Keyscan+0xb2>
		{						 
			//ROW1
			PinClr(ROW1);		//activate ROW 1 and check both columns
    1388:	4f2b      	ldr	r7, [pc, #172]	; (1438 <Keyscan+0xd0>)
    138a:	2380      	movs	r3, #128	; 0x80
    138c:	00db      	lsls	r3, r3, #3
    138e:	469a      	mov	sl, r3
    1390:	603b      	str	r3, [r7, #0]
			PinSet(ROW2);
    1392:	4e2a      	ldr	r6, [pc, #168]	; (143c <Keyscan+0xd4>)
    1394:	2380      	movs	r3, #128	; 0x80
    1396:	011b      	lsls	r3, r3, #4
    1398:	4699      	mov	r9, r3
    139a:	6033      	str	r3, [r6, #0]
			PinSet(ROW3);
    139c:	2380      	movs	r3, #128	; 0x80
    139e:	015b      	lsls	r3, r3, #5
    13a0:	4698      	mov	r8, r3
    13a2:	6033      	str	r3, [r6, #0]
			 ParaKey	= !(digitalRead(COL1));
    13a4:	202d      	movs	r0, #45	; 0x2d
    13a6:	4d26      	ldr	r5, [pc, #152]	; (1440 <Keyscan+0xd8>)
    13a8:	47a8      	blx	r5
    13aa:	2401      	movs	r4, #1
    13ac:	4060      	eors	r0, r4
    13ae:	b2c0      	uxtb	r0, r0
    13b0:	4b24      	ldr	r3, [pc, #144]	; (1444 <Keyscan+0xdc>)
    13b2:	7018      	strb	r0, [r3, #0]
			 RunKey	= !(digitalRead(COL2));
    13b4:	202e      	movs	r0, #46	; 0x2e
    13b6:	47a8      	blx	r5
    13b8:	4060      	eors	r0, r4
    13ba:	b2c0      	uxtb	r0, r0
    13bc:	4b22      	ldr	r3, [pc, #136]	; (1448 <Keyscan+0xe0>)
    13be:	7018      	strb	r0, [r3, #0]
			
			//ROW2
			PinSet(ROW1);
    13c0:	4653      	mov	r3, sl
    13c2:	6033      	str	r3, [r6, #0]
			PinClr(ROW2);		//activate ROW 2 and check both columns
    13c4:	464b      	mov	r3, r9
    13c6:	603b      	str	r3, [r7, #0]
			PinSet(ROW3);
    13c8:	4643      	mov	r3, r8
    13ca:	6033      	str	r3, [r6, #0]
			 StartKey	= !(digitalRead(COL1));
    13cc:	202d      	movs	r0, #45	; 0x2d
    13ce:	47a8      	blx	r5
    13d0:	4060      	eors	r0, r4
    13d2:	b2c0      	uxtb	r0, r0
    13d4:	4b1d      	ldr	r3, [pc, #116]	; (144c <Keyscan+0xe4>)
    13d6:	7018      	strb	r0, [r3, #0]
			 StopKey	= !(digitalRead(COL2));
    13d8:	202e      	movs	r0, #46	; 0x2e
    13da:	47a8      	blx	r5
    13dc:	4060      	eors	r0, r4
    13de:	b2c0      	uxtb	r0, r0
    13e0:	4b1b      	ldr	r3, [pc, #108]	; (1450 <Keyscan+0xe8>)
    13e2:	7018      	strb	r0, [r3, #0]
			
			//ROW3
			PinSet(ROW1);		//activate ROW 3 and check both columns
    13e4:	4653      	mov	r3, sl
    13e6:	6033      	str	r3, [r6, #0]
			PinSet(ROW2);
    13e8:	464b      	mov	r3, r9
    13ea:	6033      	str	r3, [r6, #0]
			PinClr(ROW3);
    13ec:	4643      	mov	r3, r8
    13ee:	603b      	str	r3, [r7, #0]
			 UpdateKey= !(digitalRead(COL1));
    13f0:	202d      	movs	r0, #45	; 0x2d
    13f2:	47a8      	blx	r5
    13f4:	4060      	eors	r0, r4
    13f6:	b2c0      	uxtb	r0, r0
    13f8:	4b16      	ldr	r3, [pc, #88]	; (1454 <Keyscan+0xec>)
    13fa:	7018      	strb	r0, [r3, #0]
			 EnterKey = !(digitalRead(COL2));
    13fc:	202e      	movs	r0, #46	; 0x2e
    13fe:	47a8      	blx	r5
    1400:	4044      	eors	r4, r0
    1402:	b2e0      	uxtb	r0, r4
    1404:	4b14      	ldr	r3, [pc, #80]	; (1458 <Keyscan+0xf0>)
    1406:	7018      	strb	r0, [r3, #0]
			while (KeyDetected())
    1408:	4c09      	ldr	r4, [pc, #36]	; (1430 <Keyscan+0xc8>)
			{
				delay_ms(1);	//w8 until all keys are released
    140a:	4d0a      	ldr	r5, [pc, #40]	; (1434 <Keyscan+0xcc>)
			PinSet(ROW1);		//activate ROW 3 and check both columns
			PinSet(ROW2);
			PinClr(ROW3);
			 UpdateKey= !(digitalRead(COL1));
			 EnterKey = !(digitalRead(COL2));
			while (KeyDetected())
    140c:	e001      	b.n	1412 <Keyscan+0xaa>
			{
				delay_ms(1);	//w8 until all keys are released
    140e:	2001      	movs	r0, #1
    1410:	47a8      	blx	r5
			PinSet(ROW1);		//activate ROW 3 and check both columns
			PinSet(ROW2);
			PinClr(ROW3);
			 UpdateKey= !(digitalRead(COL1));
			 EnterKey = !(digitalRead(COL2));
			while (KeyDetected())
    1412:	47a0      	blx	r4
    1414:	2800      	cmp	r0, #0
    1416:	d1fa      	bne.n	140e <Keyscan+0xa6>
    1418:	e004      	b.n	1424 <Keyscan+0xbc>
			{
				delay_ms(1);	//w8 until all keys are released
			}
		}
		else
			ClearKeys();	
    141a:	4b10      	ldr	r3, [pc, #64]	; (145c <Keyscan+0xf4>)
    141c:	4798      	blx	r3
    141e:	e001      	b.n	1424 <Keyscan+0xbc>
	}
	else
		ClearKeys();
    1420:	4b0e      	ldr	r3, [pc, #56]	; (145c <Keyscan+0xf4>)
    1422:	4798      	blx	r3
}
    1424:	bc1c      	pop	{r2, r3, r4}
    1426:	4690      	mov	r8, r2
    1428:	4699      	mov	r9, r3
    142a:	46a2      	mov	sl, r4
    142c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    142e:	46c0      	nop			; (mov r8, r8)
    1430:	0000132d 	.word	0x0000132d
    1434:	00000f71 	.word	0x00000f71
    1438:	41004494 	.word	0x41004494
    143c:	41004498 	.word	0x41004498
    1440:	00001681 	.word	0x00001681
    1444:	20000089 	.word	0x20000089
    1448:	2000008a 	.word	0x2000008a
    144c:	2000008c 	.word	0x2000008c
    1450:	2000008d 	.word	0x2000008d
    1454:	20000088 	.word	0x20000088
    1458:	2000008b 	.word	0x2000008b
    145c:	000012f9 	.word	0x000012f9

00001460 <KeyscanWORelese>:



void KeyscanWORelese(){			//call this whenever key status required
    1460:	b5f0      	push	{r4, r5, r6, r7, lr}
    1462:	4657      	mov	r7, sl
    1464:	464e      	mov	r6, r9
    1466:	4645      	mov	r5, r8
    1468:	b4e0      	push	{r5, r6, r7}

	if (KeyDetected())	//if both columns are high, then no key is pressed
    146a:	4b2b      	ldr	r3, [pc, #172]	; (1518 <KeyscanWORelese+0xb8>)
    146c:	4798      	blx	r3
    146e:	2800      	cmp	r0, #0
    1470:	d04a      	beq.n	1508 <KeyscanWORelese+0xa8>
	{	//program will enter when any key is pressed
		delay_ms(debounce_ms);	//debounce delay
    1472:	2014      	movs	r0, #20
    1474:	4b29      	ldr	r3, [pc, #164]	; (151c <KeyscanWORelese+0xbc>)
    1476:	4798      	blx	r3
		if (KeyDetected())	//check again
    1478:	4b27      	ldr	r3, [pc, #156]	; (1518 <KeyscanWORelese+0xb8>)
    147a:	4798      	blx	r3
    147c:	2800      	cmp	r0, #0
    147e:	d040      	beq.n	1502 <KeyscanWORelese+0xa2>
		{
			//ROW1
			PinClr(ROW1);		//activate ROW 1 and check both columns
    1480:	4f27      	ldr	r7, [pc, #156]	; (1520 <KeyscanWORelese+0xc0>)
    1482:	2380      	movs	r3, #128	; 0x80
    1484:	00db      	lsls	r3, r3, #3
    1486:	469a      	mov	sl, r3
    1488:	603b      	str	r3, [r7, #0]
			PinSet(ROW2);
    148a:	4e26      	ldr	r6, [pc, #152]	; (1524 <KeyscanWORelese+0xc4>)
    148c:	2380      	movs	r3, #128	; 0x80
    148e:	011b      	lsls	r3, r3, #4
    1490:	4699      	mov	r9, r3
    1492:	6033      	str	r3, [r6, #0]
			PinSet(ROW3);
    1494:	2380      	movs	r3, #128	; 0x80
    1496:	015b      	lsls	r3, r3, #5
    1498:	4698      	mov	r8, r3
    149a:	6033      	str	r3, [r6, #0]
			ParaKey	= !(digitalRead(COL1));
    149c:	202d      	movs	r0, #45	; 0x2d
    149e:	4d22      	ldr	r5, [pc, #136]	; (1528 <KeyscanWORelese+0xc8>)
    14a0:	47a8      	blx	r5
    14a2:	2401      	movs	r4, #1
    14a4:	4060      	eors	r0, r4
    14a6:	b2c0      	uxtb	r0, r0
    14a8:	4b20      	ldr	r3, [pc, #128]	; (152c <KeyscanWORelese+0xcc>)
    14aa:	7018      	strb	r0, [r3, #0]
			RunKey	= !(digitalRead(COL2));
    14ac:	202e      	movs	r0, #46	; 0x2e
    14ae:	47a8      	blx	r5
    14b0:	4060      	eors	r0, r4
    14b2:	b2c0      	uxtb	r0, r0
    14b4:	4b1e      	ldr	r3, [pc, #120]	; (1530 <KeyscanWORelese+0xd0>)
    14b6:	7018      	strb	r0, [r3, #0]
			
			//ROW2
			PinSet(ROW1);
    14b8:	4653      	mov	r3, sl
    14ba:	6033      	str	r3, [r6, #0]
			PinClr(ROW2);		//activate ROW 2 and check both columns
    14bc:	464b      	mov	r3, r9
    14be:	603b      	str	r3, [r7, #0]
			PinSet(ROW3);
    14c0:	4643      	mov	r3, r8
    14c2:	6033      	str	r3, [r6, #0]
			StartKey	= !(digitalRead(COL1));
    14c4:	202d      	movs	r0, #45	; 0x2d
    14c6:	47a8      	blx	r5
    14c8:	4060      	eors	r0, r4
    14ca:	b2c0      	uxtb	r0, r0
    14cc:	4b19      	ldr	r3, [pc, #100]	; (1534 <KeyscanWORelese+0xd4>)
    14ce:	7018      	strb	r0, [r3, #0]
			StopKey	= !(digitalRead(COL2));
    14d0:	202e      	movs	r0, #46	; 0x2e
    14d2:	47a8      	blx	r5
    14d4:	4060      	eors	r0, r4
    14d6:	b2c0      	uxtb	r0, r0
    14d8:	4b17      	ldr	r3, [pc, #92]	; (1538 <KeyscanWORelese+0xd8>)
    14da:	7018      	strb	r0, [r3, #0]
			
			//ROW3
			PinSet(ROW1);		//activate ROW 3 and check both columns
    14dc:	4653      	mov	r3, sl
    14de:	6033      	str	r3, [r6, #0]
			PinSet(ROW2);
    14e0:	464b      	mov	r3, r9
    14e2:	6033      	str	r3, [r6, #0]
			PinClr(ROW3);
    14e4:	4643      	mov	r3, r8
    14e6:	603b      	str	r3, [r7, #0]
			UpdateKey= !(digitalRead(COL1));
    14e8:	202d      	movs	r0, #45	; 0x2d
    14ea:	47a8      	blx	r5
    14ec:	4060      	eors	r0, r4
    14ee:	b2c0      	uxtb	r0, r0
    14f0:	4b12      	ldr	r3, [pc, #72]	; (153c <KeyscanWORelese+0xdc>)
    14f2:	7018      	strb	r0, [r3, #0]
			EnterKey = !(digitalRead(COL2));
    14f4:	202e      	movs	r0, #46	; 0x2e
    14f6:	47a8      	blx	r5
    14f8:	4044      	eors	r4, r0
    14fa:	b2e0      	uxtb	r0, r4
    14fc:	4b10      	ldr	r3, [pc, #64]	; (1540 <KeyscanWORelese+0xe0>)
    14fe:	7018      	strb	r0, [r3, #0]
    1500:	e004      	b.n	150c <KeyscanWORelese+0xac>
			//{
				//delay_ms(1);	//w8 until all keys are released
			//}
		}
		else
		ClearKeys();
    1502:	4b10      	ldr	r3, [pc, #64]	; (1544 <KeyscanWORelese+0xe4>)
    1504:	4798      	blx	r3
    1506:	e001      	b.n	150c <KeyscanWORelese+0xac>
	}
	else
	ClearKeys();
    1508:	4b0e      	ldr	r3, [pc, #56]	; (1544 <KeyscanWORelese+0xe4>)
    150a:	4798      	blx	r3
}
    150c:	bc1c      	pop	{r2, r3, r4}
    150e:	4690      	mov	r8, r2
    1510:	4699      	mov	r9, r3
    1512:	46a2      	mov	sl, r4
    1514:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1516:	46c0      	nop			; (mov r8, r8)
    1518:	0000132d 	.word	0x0000132d
    151c:	00000f71 	.word	0x00000f71
    1520:	41004494 	.word	0x41004494
    1524:	41004498 	.word	0x41004498
    1528:	00001681 	.word	0x00001681
    152c:	20000089 	.word	0x20000089
    1530:	2000008a 	.word	0x2000008a
    1534:	2000008c 	.word	0x2000008c
    1538:	2000008d 	.word	0x2000008d
    153c:	20000088 	.word	0x20000088
    1540:	2000008b 	.word	0x2000008b
    1544:	000012f9 	.word	0x000012f9

00001548 <pinMode>:

 OLD approach*/

//usage pinMode(PA15, OUTPUT)
void pinMode(uint8_t Pin, uint8_t mode)
{
    1548:	b510      	push	{r4, lr}
	if (mode==OUTPUT) {			//strong Totem Pole output
    154a:	2900      	cmp	r1, #0
    154c:	d10e      	bne.n	156c <pinMode+0x24>
		DIRSET(Pin);			//enable pin as output
    154e:	0943      	lsrs	r3, r0, #5
    1550:	01db      	lsls	r3, r3, #7
    1552:	4939      	ldr	r1, [pc, #228]	; (1638 <pinMode+0xf0>)
    1554:	185a      	adds	r2, r3, r1
    1556:	211f      	movs	r1, #31
    1558:	4008      	ands	r0, r1
    155a:	2101      	movs	r1, #1
    155c:	4081      	lsls	r1, r0
    155e:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)=0;			//disable pull up, input, low drive strength
    1560:	4a36      	ldr	r2, [pc, #216]	; (163c <pinMode+0xf4>)
    1562:	1880      	adds	r0, r0, r2
    1564:	18c3      	adds	r3, r0, r3
    1566:	2200      	movs	r2, #0
    1568:	701a      	strb	r2, [r3, #0]
    156a:	e063      	b.n	1634 <pinMode+0xec>
	}
		
	else if (mode==WEAKOUT){	//pin configured as output with weak pull
    156c:	2901      	cmp	r1, #1
    156e:	d110      	bne.n	1592 <pinMode+0x4a>
		DIRCLR(Pin);			//enable pin as output
    1570:	0943      	lsrs	r3, r0, #5
    1572:	01db      	lsls	r3, r3, #7
    1574:	4932      	ldr	r1, [pc, #200]	; (1640 <pinMode+0xf8>)
    1576:	185a      	adds	r2, r3, r1
    1578:	211f      	movs	r1, #31
    157a:	4008      	ands	r0, r1
    157c:	2101      	movs	r1, #1
    157e:	4081      	lsls	r1, r0
    1580:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b100;		//enable pull RESISTOR
    1582:	4a2e      	ldr	r2, [pc, #184]	; (163c <pinMode+0xf4>)
    1584:	1880      	adds	r0, r0, r2
    1586:	18c0      	adds	r0, r0, r3
    1588:	7802      	ldrb	r2, [r0, #0]
    158a:	2304      	movs	r3, #4
    158c:	4313      	orrs	r3, r2
    158e:	7003      	strb	r3, [r0, #0]
    1590:	e050      	b.n	1634 <pinMode+0xec>
	//Pull value will be decided by OUT register value
	//when OUT bit is 1 for a particular pin it will be pulled high and for out bit =0 pin will be pulled low
	}
	
	else if(mode==INPUT) {		//high impedance input
    1592:	2902      	cmp	r1, #2
    1594:	d110      	bne.n	15b8 <pinMode+0x70>
		DIRCLR(Pin);			//make pin input
    1596:	0943      	lsrs	r3, r0, #5
    1598:	01db      	lsls	r3, r3, #7
    159a:	4929      	ldr	r1, [pc, #164]	; (1640 <pinMode+0xf8>)
    159c:	185a      	adds	r2, r3, r1
    159e:	211f      	movs	r1, #31
    15a0:	4008      	ands	r0, r1
    15a2:	2101      	movs	r1, #1
    15a4:	4081      	lsls	r1, r0
    15a6:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b10;		//enable input pin sampling, pull disabled		
    15a8:	4a24      	ldr	r2, [pc, #144]	; (163c <pinMode+0xf4>)
    15aa:	1880      	adds	r0, r0, r2
    15ac:	18c0      	adds	r0, r0, r3
    15ae:	7802      	ldrb	r2, [r0, #0]
    15b0:	2302      	movs	r3, #2
    15b2:	4313      	orrs	r3, r2
    15b4:	7003      	strb	r3, [r0, #0]
    15b6:	e03d      	b.n	1634 <pinMode+0xec>
	}
	
	else if (mode==INOUT){		//pin configured as input and output
    15b8:	2905      	cmp	r1, #5
    15ba:	d110      	bne.n	15de <pinMode+0x96>
		DIRSET(Pin);			//enable pin as output
    15bc:	0943      	lsrs	r3, r0, #5
    15be:	01db      	lsls	r3, r3, #7
    15c0:	491d      	ldr	r1, [pc, #116]	; (1638 <pinMode+0xf0>)
    15c2:	185a      	adds	r2, r3, r1
    15c4:	211f      	movs	r1, #31
    15c6:	4008      	ands	r0, r1
    15c8:	2101      	movs	r1, #1
    15ca:	4081      	lsls	r1, r0
    15cc:	6011      	str	r1, [r2, #0]
		PINCFG(Pin)|=0b10;		//enable input pin sampling
    15ce:	4a1b      	ldr	r2, [pc, #108]	; (163c <pinMode+0xf4>)
    15d0:	1880      	adds	r0, r0, r2
    15d2:	18c0      	adds	r0, r0, r3
    15d4:	7802      	ldrb	r2, [r0, #0]
    15d6:	2302      	movs	r3, #2
    15d8:	4313      	orrs	r3, r2
    15da:	7003      	strb	r3, [r0, #0]
    15dc:	e02a      	b.n	1634 <pinMode+0xec>
	}
	
	else if (mode==INPUP){		//pin configured as input with pull up resistor
    15de:	2903      	cmp	r1, #3
    15e0:	d113      	bne.n	160a <pinMode+0xc2>
		DIRCLR(Pin);			//enable pin as input
    15e2:	0943      	lsrs	r3, r0, #5
    15e4:	01db      	lsls	r3, r3, #7
    15e6:	4a16      	ldr	r2, [pc, #88]	; (1640 <pinMode+0xf8>)
    15e8:	1899      	adds	r1, r3, r2
    15ea:	221f      	movs	r2, #31
    15ec:	4010      	ands	r0, r2
    15ee:	2201      	movs	r2, #1
    15f0:	4082      	lsls	r2, r0
    15f2:	600a      	str	r2, [r1, #0]
		PINCFG(Pin)|=0b110;		//enable pull and input pin sampling
    15f4:	4911      	ldr	r1, [pc, #68]	; (163c <pinMode+0xf4>)
    15f6:	1840      	adds	r0, r0, r1
    15f8:	18c0      	adds	r0, r0, r3
    15fa:	7804      	ldrb	r4, [r0, #0]
    15fc:	2106      	movs	r1, #6
    15fe:	4321      	orrs	r1, r4
    1600:	7001      	strb	r1, [r0, #0]
	//pull value(1 or 0) depends on OUT register value, since we want pull up so we will set 'OUT' register bit
		PinSet(Pin);											
    1602:	4910      	ldr	r1, [pc, #64]	; (1644 <pinMode+0xfc>)
    1604:	185b      	adds	r3, r3, r1
    1606:	601a      	str	r2, [r3, #0]
    1608:	e014      	b.n	1634 <pinMode+0xec>
	}
	
	else if (mode==INPDN){		//pin configured as input with pull down resistor
    160a:	2904      	cmp	r1, #4
    160c:	d112      	bne.n	1634 <pinMode+0xec>
		DIRCLR(Pin);			//enable pin as input
    160e:	0943      	lsrs	r3, r0, #5
    1610:	01db      	lsls	r3, r3, #7
    1612:	4a0b      	ldr	r2, [pc, #44]	; (1640 <pinMode+0xf8>)
    1614:	1899      	adds	r1, r3, r2
    1616:	221f      	movs	r2, #31
    1618:	4010      	ands	r0, r2
    161a:	2201      	movs	r2, #1
    161c:	4082      	lsls	r2, r0
    161e:	600a      	str	r2, [r1, #0]
		PINCFG(Pin)|=0b110;		//enable pull and input pin sampling
    1620:	4906      	ldr	r1, [pc, #24]	; (163c <pinMode+0xf4>)
    1622:	1840      	adds	r0, r0, r1
    1624:	18c0      	adds	r0, r0, r3
    1626:	7804      	ldrb	r4, [r0, #0]
    1628:	2106      	movs	r1, #6
    162a:	4321      	orrs	r1, r4
    162c:	7001      	strb	r1, [r0, #0]
	//pull value(1 or 0) depends on OUT register value, since we want pull dwn so we will clear 'OUT' register bit
		PinClr(Pin);
    162e:	4906      	ldr	r1, [pc, #24]	; (1648 <pinMode+0x100>)
    1630:	185b      	adds	r3, r3, r1
    1632:	601a      	str	r2, [r3, #0]
	}
		
}
    1634:	bd10      	pop	{r4, pc}
    1636:	46c0      	nop			; (mov r8, r8)
    1638:	41004408 	.word	0x41004408
    163c:	41004440 	.word	0x41004440
    1640:	41004404 	.word	0x41004404
    1644:	41004418 	.word	0x41004418
    1648:	41004414 	.word	0x41004414

0000164c <digitalWrite>:

//usage digitalWrite(PA20, HIGH); to set pin PA20
//Alternatively you can use PinSet(PA20) and PinClr(pin_no) macros
void digitalWrite(uint8_t pin_no, bool val){
	if (val==1)
    164c:	2900      	cmp	r1, #0
    164e:	d009      	beq.n	1664 <digitalWrite+0x18>
	{
		PinSet(pin_no);
    1650:	0943      	lsrs	r3, r0, #5
    1652:	01db      	lsls	r3, r3, #7
    1654:	4a08      	ldr	r2, [pc, #32]	; (1678 <digitalWrite+0x2c>)
    1656:	189b      	adds	r3, r3, r2
    1658:	221f      	movs	r2, #31
    165a:	4010      	ands	r0, r2
    165c:	2201      	movs	r2, #1
    165e:	4082      	lsls	r2, r0
    1660:	601a      	str	r2, [r3, #0]
    1662:	e008      	b.n	1676 <digitalWrite+0x2a>
	}
	else
	{
		
		PinClr(pin_no);
    1664:	0943      	lsrs	r3, r0, #5
    1666:	01db      	lsls	r3, r3, #7
    1668:	4a04      	ldr	r2, [pc, #16]	; (167c <digitalWrite+0x30>)
    166a:	189b      	adds	r3, r3, r2
    166c:	221f      	movs	r2, #31
    166e:	4010      	ands	r0, r2
    1670:	2201      	movs	r2, #1
    1672:	4082      	lsls	r2, r0
    1674:	601a      	str	r2, [r3, #0]
	}
}
    1676:	4770      	bx	lr
    1678:	41004418 	.word	0x41004418
    167c:	41004414 	.word	0x41004414

00001680 <digitalRead>:

//usage bool a= digitalRead(PB20); a will contain status of pin PB20
//Alternatively You can use macro function eg:PinRead(PA04), since this function also does the same.
bool digitalRead(uint8_t Pin){
	return(PinRead(Pin));
    1680:	0943      	lsrs	r3, r0, #5
    1682:	01db      	lsls	r3, r3, #7
    1684:	4a06      	ldr	r2, [pc, #24]	; (16a0 <digitalRead+0x20>)
    1686:	189b      	adds	r3, r3, r2
    1688:	681b      	ldr	r3, [r3, #0]
    168a:	221f      	movs	r2, #31
    168c:	4010      	ands	r0, r2
    168e:	2201      	movs	r2, #1
    1690:	4082      	lsls	r2, r0
    1692:	1c10      	adds	r0, r2, #0
    1694:	4018      	ands	r0, r3
    1696:	1e43      	subs	r3, r0, #1
    1698:	4198      	sbcs	r0, r3
    169a:	b2c0      	uxtb	r0, r0
}
    169c:	4770      	bx	lr
    169e:	46c0      	nop			; (mov r8, r8)
    16a0:	41004420 	.word	0x41004420

000016a4 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    16a4:	4b0c      	ldr	r3, [pc, #48]	; (16d8 <cpu_irq_enter_critical+0x34>)
    16a6:	681b      	ldr	r3, [r3, #0]
    16a8:	2b00      	cmp	r3, #0
    16aa:	d110      	bne.n	16ce <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    16ac:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    16b0:	2b00      	cmp	r3, #0
    16b2:	d109      	bne.n	16c8 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
    16b4:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    16b6:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    16ba:	2200      	movs	r2, #0
    16bc:	4b07      	ldr	r3, [pc, #28]	; (16dc <cpu_irq_enter_critical+0x38>)
    16be:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    16c0:	2201      	movs	r2, #1
    16c2:	4b07      	ldr	r3, [pc, #28]	; (16e0 <cpu_irq_enter_critical+0x3c>)
    16c4:	701a      	strb	r2, [r3, #0]
    16c6:	e002      	b.n	16ce <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    16c8:	2200      	movs	r2, #0
    16ca:	4b05      	ldr	r3, [pc, #20]	; (16e0 <cpu_irq_enter_critical+0x3c>)
    16cc:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    16ce:	4b02      	ldr	r3, [pc, #8]	; (16d8 <cpu_irq_enter_critical+0x34>)
    16d0:	681a      	ldr	r2, [r3, #0]
    16d2:	3201      	adds	r2, #1
    16d4:	601a      	str	r2, [r3, #0]
}
    16d6:	4770      	bx	lr
    16d8:	20000054 	.word	0x20000054
    16dc:	20000000 	.word	0x20000000
    16e0:	20000058 	.word	0x20000058

000016e4 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    16e4:	4b08      	ldr	r3, [pc, #32]	; (1708 <cpu_irq_leave_critical+0x24>)
    16e6:	681a      	ldr	r2, [r3, #0]
    16e8:	3a01      	subs	r2, #1
    16ea:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    16ec:	681b      	ldr	r3, [r3, #0]
    16ee:	2b00      	cmp	r3, #0
    16f0:	d109      	bne.n	1706 <cpu_irq_leave_critical+0x22>
    16f2:	4b06      	ldr	r3, [pc, #24]	; (170c <cpu_irq_leave_critical+0x28>)
    16f4:	781b      	ldrb	r3, [r3, #0]
    16f6:	2b00      	cmp	r3, #0
    16f8:	d005      	beq.n	1706 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    16fa:	2201      	movs	r2, #1
    16fc:	4b04      	ldr	r3, [pc, #16]	; (1710 <cpu_irq_leave_critical+0x2c>)
    16fe:	701a      	strb	r2, [r3, #0]
    1700:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
    1704:	b662      	cpsie	i
	}
}
    1706:	4770      	bx	lr
    1708:	20000054 	.word	0x20000054
    170c:	20000058 	.word	0x20000058
    1710:	20000000 	.word	0x20000000

00001714 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    1714:	b5f0      	push	{r4, r5, r6, r7, lr}
    1716:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    1718:	ac01      	add	r4, sp, #4
    171a:	2501      	movs	r5, #1
    171c:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    171e:	2700      	movs	r7, #0
    1720:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    1722:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
    1724:	203e      	movs	r0, #62	; 0x3e
    1726:	1c21      	adds	r1, r4, #0
    1728:	4e06      	ldr	r6, [pc, #24]	; (1744 <system_board_init+0x30>)
    172a:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    172c:	2280      	movs	r2, #128	; 0x80
    172e:	05d2      	lsls	r2, r2, #23
    1730:	4b05      	ldr	r3, [pc, #20]	; (1748 <system_board_init+0x34>)
    1732:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    1734:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    1736:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    1738:	200f      	movs	r0, #15
    173a:	1c21      	adds	r1, r4, #0
    173c:	47b0      	blx	r6
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
    173e:	b003      	add	sp, #12
    1740:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1742:	46c0      	nop			; (mov r8, r8)
    1744:	0000174d 	.word	0x0000174d
    1748:	41004480 	.word	0x41004480

0000174c <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    174c:	b500      	push	{lr}
    174e:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    1750:	ab01      	add	r3, sp, #4
    1752:	2280      	movs	r2, #128	; 0x80
    1754:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    1756:	780a      	ldrb	r2, [r1, #0]
    1758:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    175a:	784a      	ldrb	r2, [r1, #1]
    175c:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    175e:	788a      	ldrb	r2, [r1, #2]
    1760:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    1762:	1c19      	adds	r1, r3, #0
    1764:	4b01      	ldr	r3, [pc, #4]	; (176c <port_pin_set_config+0x20>)
    1766:	4798      	blx	r3
}
    1768:	b003      	add	sp, #12
    176a:	bd00      	pop	{pc}
    176c:	00001e85 	.word	0x00001e85

00001770 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    1770:	b508      	push	{r3, lr}
	switch (clock_source) {
    1772:	2808      	cmp	r0, #8
    1774:	d834      	bhi.n	17e0 <system_clock_source_get_hz+0x70>
    1776:	0080      	lsls	r0, r0, #2
    1778:	4b1b      	ldr	r3, [pc, #108]	; (17e8 <system_clock_source_get_hz+0x78>)
    177a:	581b      	ldr	r3, [r3, r0]
    177c:	469f      	mov	pc, r3

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    177e:	2080      	movs	r0, #128	; 0x80
    1780:	0200      	lsls	r0, r0, #8
    1782:	e030      	b.n	17e6 <system_clock_source_get_hz+0x76>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    1784:	4b19      	ldr	r3, [pc, #100]	; (17ec <system_clock_source_get_hz+0x7c>)
    1786:	6918      	ldr	r0, [r3, #16]
    1788:	e02d      	b.n	17e6 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    178a:	4b19      	ldr	r3, [pc, #100]	; (17f0 <system_clock_source_get_hz+0x80>)
    178c:	6a18      	ldr	r0, [r3, #32]
    178e:	0580      	lsls	r0, r0, #22
    1790:	0f80      	lsrs	r0, r0, #30
    1792:	4b18      	ldr	r3, [pc, #96]	; (17f4 <system_clock_source_get_hz+0x84>)
    1794:	40c3      	lsrs	r3, r0
    1796:	1c18      	adds	r0, r3, #0
    1798:	e025      	b.n	17e6 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    179a:	4b14      	ldr	r3, [pc, #80]	; (17ec <system_clock_source_get_hz+0x7c>)
    179c:	6958      	ldr	r0, [r3, #20]
    179e:	e022      	b.n	17e6 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    17a0:	4b12      	ldr	r3, [pc, #72]	; (17ec <system_clock_source_get_hz+0x7c>)
    17a2:	681b      	ldr	r3, [r3, #0]
    17a4:	2002      	movs	r0, #2
    17a6:	4018      	ands	r0, r3
    17a8:	d01d      	beq.n	17e6 <system_clock_source_get_hz+0x76>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    17aa:	4911      	ldr	r1, [pc, #68]	; (17f0 <system_clock_source_get_hz+0x80>)
    17ac:	2210      	movs	r2, #16
    17ae:	68cb      	ldr	r3, [r1, #12]
    17b0:	421a      	tst	r2, r3
    17b2:	d0fc      	beq.n	17ae <system_clock_source_get_hz+0x3e>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    17b4:	4b0d      	ldr	r3, [pc, #52]	; (17ec <system_clock_source_get_hz+0x7c>)
    17b6:	681b      	ldr	r3, [r3, #0]
    17b8:	075a      	lsls	r2, r3, #29
    17ba:	d513      	bpl.n	17e4 <system_clock_source_get_hz+0x74>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    17bc:	2000      	movs	r0, #0
    17be:	4b0e      	ldr	r3, [pc, #56]	; (17f8 <system_clock_source_get_hz+0x88>)
    17c0:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    17c2:	4b0a      	ldr	r3, [pc, #40]	; (17ec <system_clock_source_get_hz+0x7c>)
    17c4:	689b      	ldr	r3, [r3, #8]
    17c6:	041b      	lsls	r3, r3, #16
    17c8:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    17ca:	4358      	muls	r0, r3
    17cc:	e00b      	b.n	17e6 <system_clock_source_get_hz+0x76>

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    17ce:	2350      	movs	r3, #80	; 0x50
    17d0:	4a07      	ldr	r2, [pc, #28]	; (17f0 <system_clock_source_get_hz+0x80>)
    17d2:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    17d4:	2000      	movs	r0, #0

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    17d6:	075a      	lsls	r2, r3, #29
    17d8:	d505      	bpl.n	17e6 <system_clock_source_get_hz+0x76>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
    17da:	4b04      	ldr	r3, [pc, #16]	; (17ec <system_clock_source_get_hz+0x7c>)
    17dc:	68d8      	ldr	r0, [r3, #12]
    17de:	e002      	b.n	17e6 <system_clock_source_get_hz+0x76>
#endif

	default:
		return 0;
    17e0:	2000      	movs	r0, #0
    17e2:	e000      	b.n	17e6 <system_clock_source_get_hz+0x76>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    17e4:	4805      	ldr	r0, [pc, #20]	; (17fc <system_clock_source_get_hz+0x8c>)
#endif

	default:
		return 0;
	}
}
    17e6:	bd08      	pop	{r3, pc}
    17e8:	00002420 	.word	0x00002420
    17ec:	2000005c 	.word	0x2000005c
    17f0:	40000800 	.word	0x40000800
    17f4:	007a1200 	.word	0x007a1200
    17f8:	00001dc5 	.word	0x00001dc5
    17fc:	02dc6c00 	.word	0x02dc6c00

00001800 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    1800:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    1802:	4b0c      	ldr	r3, [pc, #48]	; (1834 <system_clock_source_osc8m_set_config+0x34>)
    1804:	6a1c      	ldr	r4, [r3, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    1806:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    1808:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    180a:	7840      	ldrb	r0, [r0, #1]
    180c:	2201      	movs	r2, #1
    180e:	4010      	ands	r0, r2
    1810:	0180      	lsls	r0, r0, #6
    1812:	2640      	movs	r6, #64	; 0x40
    1814:	43b4      	bics	r4, r6
    1816:	4304      	orrs	r4, r0
    1818:	402a      	ands	r2, r5
    181a:	01d0      	lsls	r0, r2, #7
    181c:	2280      	movs	r2, #128	; 0x80
    181e:	4394      	bics	r4, r2
    1820:	1c22      	adds	r2, r4, #0
    1822:	4302      	orrs	r2, r0
    1824:	2003      	movs	r0, #3
    1826:	4001      	ands	r1, r0
    1828:	0209      	lsls	r1, r1, #8
    182a:	4803      	ldr	r0, [pc, #12]	; (1838 <system_clock_source_osc8m_set_config+0x38>)
    182c:	4002      	ands	r2, r0
    182e:	430a      	orrs	r2, r1
    1830:	621a      	str	r2, [r3, #32]
}
    1832:	bd70      	pop	{r4, r5, r6, pc}
    1834:	40000800 	.word	0x40000800
    1838:	fffffcff 	.word	0xfffffcff

0000183c <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    183c:	b5f0      	push	{r4, r5, r6, r7, lr}
    183e:	465f      	mov	r7, fp
    1840:	4656      	mov	r6, sl
    1842:	464d      	mov	r5, r9
    1844:	4644      	mov	r4, r8
    1846:	b4f0      	push	{r4, r5, r6, r7}
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    1848:	4a25      	ldr	r2, [pc, #148]	; (18e0 <system_clock_source_xosc32k_set_config+0xa4>)
    184a:	8a94      	ldrh	r4, [r2, #20]

	temp.bit.STARTUP = config->startup_time;
    184c:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    184e:	7803      	ldrb	r3, [r0, #0]
    1850:	4259      	negs	r1, r3
    1852:	4159      	adcs	r1, r3
    1854:	468a      	mov	sl, r1
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    1856:	7883      	ldrb	r3, [r0, #2]
    1858:	469c      	mov	ip, r3
	temp.bit.EN1K = config->enable_1khz_output;
    185a:	78c1      	ldrb	r1, [r0, #3]
    185c:	4688      	mov	r8, r1
	temp.bit.EN32K = config->enable_32khz_output;
    185e:	7903      	ldrb	r3, [r0, #4]
    1860:	4699      	mov	r9, r3

	temp.bit.ONDEMAND = config->on_demand;
    1862:	7b46      	ldrb	r6, [r0, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
    1864:	7b07      	ldrb	r7, [r0, #12]
	temp.bit.WRTLOCK  = config->write_once;
    1866:	7b81      	ldrb	r1, [r0, #14]
    1868:	468b      	mov	fp, r1

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    186a:	6880      	ldr	r0, [r0, #8]
    186c:	4b1d      	ldr	r3, [pc, #116]	; (18e4 <system_clock_source_xosc32k_set_config+0xa8>)
    186e:	6158      	str	r0, [r3, #20]

	SYSCTRL->XOSC32K = temp;
    1870:	2301      	movs	r3, #1
    1872:	4651      	mov	r1, sl
    1874:	0088      	lsls	r0, r1, #2
    1876:	2104      	movs	r1, #4
    1878:	438c      	bics	r4, r1
    187a:	4304      	orrs	r4, r0
    187c:	4648      	mov	r0, r9
    187e:	4018      	ands	r0, r3
    1880:	00c0      	lsls	r0, r0, #3
    1882:	2108      	movs	r1, #8
    1884:	438c      	bics	r4, r1
    1886:	4304      	orrs	r4, r0
    1888:	4640      	mov	r0, r8
    188a:	4018      	ands	r0, r3
    188c:	0100      	lsls	r0, r0, #4
    188e:	2110      	movs	r1, #16
    1890:	438c      	bics	r4, r1
    1892:	4304      	orrs	r4, r0
    1894:	4660      	mov	r0, ip
    1896:	4018      	ands	r0, r3
    1898:	0140      	lsls	r0, r0, #5
    189a:	2120      	movs	r1, #32
    189c:	438c      	bics	r4, r1
    189e:	4304      	orrs	r4, r0
    18a0:	1c18      	adds	r0, r3, #0
    18a2:	4038      	ands	r0, r7
    18a4:	0180      	lsls	r0, r0, #6
    18a6:	2740      	movs	r7, #64	; 0x40
    18a8:	43bc      	bics	r4, r7
    18aa:	4304      	orrs	r4, r0
    18ac:	1c18      	adds	r0, r3, #0
    18ae:	4030      	ands	r0, r6
    18b0:	01c0      	lsls	r0, r0, #7
    18b2:	2680      	movs	r6, #128	; 0x80
    18b4:	43b4      	bics	r4, r6
    18b6:	4304      	orrs	r4, r0
    18b8:	2007      	movs	r0, #7
    18ba:	4028      	ands	r0, r5
    18bc:	0200      	lsls	r0, r0, #8
    18be:	4d0a      	ldr	r5, [pc, #40]	; (18e8 <system_clock_source_xosc32k_set_config+0xac>)
    18c0:	402c      	ands	r4, r5
    18c2:	4304      	orrs	r4, r0
    18c4:	4659      	mov	r1, fp
    18c6:	400b      	ands	r3, r1
    18c8:	0319      	lsls	r1, r3, #12
    18ca:	4808      	ldr	r0, [pc, #32]	; (18ec <system_clock_source_xosc32k_set_config+0xb0>)
    18cc:	1c23      	adds	r3, r4, #0
    18ce:	4003      	ands	r3, r0
    18d0:	430b      	orrs	r3, r1
    18d2:	8293      	strh	r3, [r2, #20]
}
    18d4:	bc3c      	pop	{r2, r3, r4, r5}
    18d6:	4690      	mov	r8, r2
    18d8:	4699      	mov	r9, r3
    18da:	46a2      	mov	sl, r4
    18dc:	46ab      	mov	fp, r5
    18de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    18e0:	40000800 	.word	0x40000800
    18e4:	2000005c 	.word	0x2000005c
    18e8:	fffff8ff 	.word	0xfffff8ff
    18ec:	ffffefff 	.word	0xffffefff

000018f0 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    18f0:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    18f2:	7a02      	ldrb	r2, [r0, #8]
    18f4:	0692      	lsls	r2, r2, #26
    18f6:	0c12      	lsrs	r2, r2, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
    18f8:	8943      	ldrh	r3, [r0, #10]
    18fa:	059b      	lsls	r3, r3, #22
    18fc:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    18fe:	431a      	orrs	r2, r3
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
    1900:	4b15      	ldr	r3, [pc, #84]	; (1958 <system_clock_source_dfll_set_config+0x68>)
    1902:	605a      	str	r2, [r3, #4]
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
    1904:	8881      	ldrh	r1, [r0, #4]
    1906:	8842      	ldrh	r2, [r0, #2]
    1908:	4311      	orrs	r1, r2
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    190a:	79c4      	ldrb	r4, [r0, #7]
    190c:	7982      	ldrb	r2, [r0, #6]
    190e:	4322      	orrs	r2, r4
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    1910:	430a      	orrs	r2, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    1912:	7841      	ldrb	r1, [r0, #1]
    1914:	01c9      	lsls	r1, r1, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
    1916:	430a      	orrs	r2, r1
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
    1918:	601a      	str	r2, [r3, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    191a:	7803      	ldrb	r3, [r0, #0]
    191c:	2b04      	cmp	r3, #4
    191e:	d10f      	bne.n	1940 <system_clock_source_dfll_set_config+0x50>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    1920:	7b02      	ldrb	r2, [r0, #12]
    1922:	0692      	lsls	r2, r2, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    1924:	8a03      	ldrh	r3, [r0, #16]
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    1926:	431a      	orrs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    1928:	89c3      	ldrh	r3, [r0, #14]
    192a:	041b      	lsls	r3, r3, #16
    192c:	490b      	ldr	r1, [pc, #44]	; (195c <system_clock_source_dfll_set_config+0x6c>)
    192e:	400b      	ands	r3, r1
    1930:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
    1932:	4b09      	ldr	r3, [pc, #36]	; (1958 <system_clock_source_dfll_set_config+0x68>)
    1934:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    1936:	6819      	ldr	r1, [r3, #0]
    1938:	2204      	movs	r2, #4
    193a:	430a      	orrs	r2, r1
    193c:	601a      	str	r2, [r3, #0]
    193e:	e009      	b.n	1954 <system_clock_source_dfll_set_config+0x64>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    1940:	2b20      	cmp	r3, #32
    1942:	d107      	bne.n	1954 <system_clock_source_dfll_set_config+0x64>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    1944:	8a02      	ldrh	r2, [r0, #16]
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
    1946:	4b04      	ldr	r3, [pc, #16]	; (1958 <system_clock_source_dfll_set_config+0x68>)
    1948:	609a      	str	r2, [r3, #8]
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    194a:	6819      	ldr	r1, [r3, #0]
    194c:	2284      	movs	r2, #132	; 0x84
    194e:	00d2      	lsls	r2, r2, #3
    1950:	430a      	orrs	r2, r1
    1952:	601a      	str	r2, [r3, #0]
				SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
    1954:	bd10      	pop	{r4, pc}
    1956:	46c0      	nop			; (mov r8, r8)
    1958:	2000005c 	.word	0x2000005c
    195c:	03ff0000 	.word	0x03ff0000

00001960 <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    1960:	2808      	cmp	r0, #8
    1962:	d843      	bhi.n	19ec <system_clock_source_enable+0x8c>
    1964:	0080      	lsls	r0, r0, #2
    1966:	4b22      	ldr	r3, [pc, #136]	; (19f0 <system_clock_source_enable+0x90>)
    1968:	581b      	ldr	r3, [r3, r0]
    196a:	469f      	mov	pc, r3
		break;
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    196c:	2000      	movs	r0, #0
    196e:	e03e      	b.n	19ee <system_clock_source_enable+0x8e>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    1970:	4b20      	ldr	r3, [pc, #128]	; (19f4 <system_clock_source_enable+0x94>)
    1972:	6a19      	ldr	r1, [r3, #32]
    1974:	2202      	movs	r2, #2
    1976:	430a      	orrs	r2, r1
    1978:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
    197a:	2000      	movs	r0, #0
    197c:	e037      	b.n	19ee <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    197e:	4b1d      	ldr	r3, [pc, #116]	; (19f4 <system_clock_source_enable+0x94>)
    1980:	6999      	ldr	r1, [r3, #24]
    1982:	2202      	movs	r2, #2
    1984:	430a      	orrs	r2, r1
    1986:	619a      	str	r2, [r3, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1988:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
    198a:	e030      	b.n	19ee <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    198c:	4b19      	ldr	r3, [pc, #100]	; (19f4 <system_clock_source_enable+0x94>)
    198e:	8a19      	ldrh	r1, [r3, #16]
    1990:	2202      	movs	r2, #2
    1992:	430a      	orrs	r2, r1
    1994:	821a      	strh	r2, [r3, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    1996:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
    1998:	e029      	b.n	19ee <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    199a:	4b16      	ldr	r3, [pc, #88]	; (19f4 <system_clock_source_enable+0x94>)
    199c:	8a99      	ldrh	r1, [r3, #20]
    199e:	2202      	movs	r2, #2
    19a0:	430a      	orrs	r2, r1
    19a2:	829a      	strh	r2, [r3, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    19a4:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
    19a6:	e022      	b.n	19ee <system_clock_source_enable+0x8e>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    19a8:	4b13      	ldr	r3, [pc, #76]	; (19f8 <system_clock_source_enable+0x98>)
    19aa:	6819      	ldr	r1, [r3, #0]
    19ac:	2202      	movs	r2, #2
    19ae:	430a      	orrs	r2, r1
    19b0:	601a      	str	r2, [r3, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
    19b2:	681a      	ldr	r2, [r3, #0]
    19b4:	4b11      	ldr	r3, [pc, #68]	; (19fc <system_clock_source_enable+0x9c>)
    19b6:	401a      	ands	r2, r3
    19b8:	4b0e      	ldr	r3, [pc, #56]	; (19f4 <system_clock_source_enable+0x94>)
    19ba:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    19bc:	1c19      	adds	r1, r3, #0
    19be:	2210      	movs	r2, #16
    19c0:	68cb      	ldr	r3, [r1, #12]
    19c2:	421a      	tst	r2, r3
    19c4:	d0fc      	beq.n	19c0 <system_clock_source_enable+0x60>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    19c6:	4a0c      	ldr	r2, [pc, #48]	; (19f8 <system_clock_source_enable+0x98>)
    19c8:	6891      	ldr	r1, [r2, #8]
    19ca:	4b0a      	ldr	r3, [pc, #40]	; (19f4 <system_clock_source_enable+0x94>)
    19cc:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    19ce:	6851      	ldr	r1, [r2, #4]
    19d0:	6299      	str	r1, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    19d2:	6812      	ldr	r2, [r2, #0]
    19d4:	b292      	uxth	r2, r2
    19d6:	849a      	strh	r2, [r3, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    19d8:	2000      	movs	r0, #0
    19da:	e008      	b.n	19ee <system_clock_source_enable+0x8e>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    19dc:	4a05      	ldr	r2, [pc, #20]	; (19f4 <system_clock_source_enable+0x94>)
    19de:	2344      	movs	r3, #68	; 0x44
    19e0:	5cd0      	ldrb	r0, [r2, r3]
    19e2:	2102      	movs	r1, #2
    19e4:	4301      	orrs	r1, r0
    19e6:	54d1      	strb	r1, [r2, r3]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    19e8:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
    19ea:	e000      	b.n	19ee <system_clock_source_enable+0x8e>
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    19ec:	2017      	movs	r0, #23
	}

	return STATUS_OK;
}
    19ee:	4770      	bx	lr
    19f0:	00002444 	.word	0x00002444
    19f4:	40000800 	.word	0x40000800
    19f8:	2000005c 	.word	0x2000005c
    19fc:	0000ff7f 	.word	0x0000ff7f

00001a00 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    1a00:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a02:	b08f      	sub	sp, #60	; 0x3c
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    1a04:	22c2      	movs	r2, #194	; 0xc2
    1a06:	00d2      	lsls	r2, r2, #3
    1a08:	4b4b      	ldr	r3, [pc, #300]	; (1b38 <system_clock_init+0x138>)
    1a0a:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    1a0c:	4b4b      	ldr	r3, [pc, #300]	; (1b3c <system_clock_init+0x13c>)
    1a0e:	685a      	ldr	r2, [r3, #4]
    1a10:	211e      	movs	r1, #30
    1a12:	438a      	bics	r2, r1
    1a14:	2104      	movs	r1, #4
    1a16:	430a      	orrs	r2, r1
    1a18:	605a      	str	r2, [r3, #4]
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
    1a1a:	2202      	movs	r2, #2
    1a1c:	ab01      	add	r3, sp, #4
    1a1e:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    1a20:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    1a22:	4d47      	ldr	r5, [pc, #284]	; (1b40 <system_clock_init+0x140>)
    1a24:	b2e0      	uxtb	r0, r4
    1a26:	a901      	add	r1, sp, #4
    1a28:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    1a2a:	3401      	adds	r4, #1
    1a2c:	2c25      	cmp	r4, #37	; 0x25
    1a2e:	d1f9      	bne.n	1a24 <system_clock_init+0x24>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    1a30:	a80a      	add	r0, sp, #40	; 0x28
    1a32:	2300      	movs	r3, #0
    1a34:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
    1a36:	2204      	movs	r2, #4
    1a38:	7042      	strb	r2, [r0, #1]
	config->auto_gain_control   = false;
    1a3a:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
    1a3c:	2280      	movs	r2, #128	; 0x80
    1a3e:	0212      	lsls	r2, r2, #8
    1a40:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
    1a42:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
    1a44:	2201      	movs	r2, #1
    1a46:	7102      	strb	r2, [r0, #4]
	config->run_in_standby      = false;
    1a48:	7303      	strb	r3, [r0, #12]
	config->on_demand           = true;
	config->write_once          = false;
    1a4a:	7383      	strb	r3, [r0, #14]
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    1a4c:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
    1a4e:	466a      	mov	r2, sp
    1a50:	84d3      	strh	r3, [r2, #38]	; 0x26
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    1a52:	4b3c      	ldr	r3, [pc, #240]	; (1b44 <system_clock_init+0x144>)
    1a54:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    1a56:	2005      	movs	r0, #5
    1a58:	4b3b      	ldr	r3, [pc, #236]	; (1b48 <system_clock_init+0x148>)
    1a5a:	4798      	blx	r3

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    1a5c:	4836      	ldr	r0, [pc, #216]	; (1b38 <system_clock_init+0x138>)
    1a5e:	2102      	movs	r1, #2
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
		XOSC32RDYCount++;
    1a60:	466b      	mov	r3, sp
    1a62:	3326      	adds	r3, #38	; 0x26
		if(XOSC32RDYCount>60000){
    1a64:	4c39      	ldr	r4, [pc, #228]	; (1b4c <system_clock_init+0x14c>)
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
    1a66:	e00b      	b.n	1a80 <system_clock_init+0x80>
		XOSC32RDYCount++;
    1a68:	881a      	ldrh	r2, [r3, #0]
    1a6a:	3201      	adds	r2, #1
    1a6c:	b292      	uxth	r2, r2
    1a6e:	801a      	strh	r2, [r3, #0]
		if(XOSC32RDYCount>60000){
    1a70:	881a      	ldrh	r2, [r3, #0]
    1a72:	b292      	uxth	r2, r2
    1a74:	42a2      	cmp	r2, r4
    1a76:	d903      	bls.n	1a80 <system_clock_init+0x80>
			XOSC32Fail=1;
    1a78:	2201      	movs	r2, #1
    1a7a:	4b35      	ldr	r3, [pc, #212]	; (1b50 <system_clock_init+0x150>)
    1a7c:	701a      	strb	r2, [r3, #0]
			break;
    1a7e:	e002      	b.n	1a86 <system_clock_init+0x86>

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    1a80:	68c2      	ldr	r2, [r0, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
volatile uint16_t XOSC32RDYCount=0;
	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K)){
    1a82:	4211      	tst	r1, r2
    1a84:	d0f0      	beq.n	1a68 <system_clock_init+0x68>
			XOSC32Fail=1;
			break;
		}
		}			//sajid here it waits for XOSC32
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
    1a86:	4b2c      	ldr	r3, [pc, #176]	; (1b38 <system_clock_init+0x138>)
    1a88:	8a99      	ldrh	r1, [r3, #20]
    1a8a:	2280      	movs	r2, #128	; 0x80
    1a8c:	430a      	orrs	r2, r1
    1a8e:	829a      	strh	r2, [r3, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    1a90:	a805      	add	r0, sp, #20
    1a92:	2300      	movs	r3, #0
    1a94:	2500      	movs	r5, #0
    1a96:	8043      	strh	r3, [r0, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    1a98:	8083      	strh	r3, [r0, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    1a9a:	7185      	strb	r5, [r0, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    1a9c:	71c5      	strb	r5, [r0, #7]
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
    1a9e:	2207      	movs	r2, #7
    1aa0:	7202      	strb	r2, [r0, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
    1aa2:	233f      	movs	r3, #63	; 0x3f
    1aa4:	8143      	strh	r3, [r0, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    1aa6:	2104      	movs	r1, #4
    1aa8:	7001      	strb	r1, [r0, #0]
	dfll_conf.on_demand      = false;
    1aaa:	7045      	strb	r5, [r0, #1]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    1aac:	4929      	ldr	r1, [pc, #164]	; (1b54 <system_clock_init+0x154>)
    1aae:	8201      	strh	r1, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    1ab0:	7302      	strb	r2, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    1ab2:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    1ab4:	4b28      	ldr	r3, [pc, #160]	; (1b58 <system_clock_init+0x158>)
    1ab6:	4798      	blx	r3
		struct system_clock_source_osc8m_config *const config)
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
    1ab8:	a804      	add	r0, sp, #16
    1aba:	7045      	strb	r5, [r0, #1]
	config->on_demand       = true;
    1abc:	2601      	movs	r6, #1
    1abe:	7086      	strb	r6, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    1ac0:	7005      	strb	r5, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
    1ac2:	4b26      	ldr	r3, [pc, #152]	; (1b5c <system_clock_init+0x15c>)
    1ac4:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    1ac6:	2006      	movs	r0, #6
    1ac8:	4f1f      	ldr	r7, [pc, #124]	; (1b48 <system_clock_init+0x148>)
    1aca:	47b8      	blx	r7


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    1acc:	4b24      	ldr	r3, [pc, #144]	; (1b60 <system_clock_init+0x160>)
    1ace:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    1ad0:	ac01      	add	r4, sp, #4
    1ad2:	9602      	str	r6, [sp, #8]
	config->high_when_disabled = false;
    1ad4:	7065      	strb	r5, [r4, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    1ad6:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
    1ad8:	7265      	strb	r5, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(8, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    1ada:	2305      	movs	r3, #5
    1adc:	7023      	strb	r3, [r4, #0]
    1ade:	2001      	movs	r0, #1
    1ae0:	1c21      	adds	r1, r4, #0
    1ae2:	4b20      	ldr	r3, [pc, #128]	; (1b64 <system_clock_init+0x164>)
    1ae4:	4798      	blx	r3
    1ae6:	2001      	movs	r0, #1
    1ae8:	4b1f      	ldr	r3, [pc, #124]	; (1b68 <system_clock_init+0x168>)
    1aea:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    1aec:	7026      	strb	r6, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    1aee:	2000      	movs	r0, #0
    1af0:	1c21      	adds	r1, r4, #0
    1af2:	4b13      	ldr	r3, [pc, #76]	; (1b40 <system_clock_init+0x140>)
    1af4:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    1af6:	2000      	movs	r0, #0
    1af8:	4b1c      	ldr	r3, [pc, #112]	; (1b6c <system_clock_init+0x16c>)
    1afa:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    1afc:	2007      	movs	r0, #7
    1afe:	47b8      	blx	r7

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    1b00:	490d      	ldr	r1, [pc, #52]	; (1b38 <system_clock_init+0x138>)
    1b02:	22d0      	movs	r2, #208	; 0xd0
    1b04:	68cb      	ldr	r3, [r1, #12]
    1b06:	4013      	ands	r3, r2


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    1b08:	2bd0      	cmp	r3, #208	; 0xd0
    1b0a:	d1fb      	bne.n	1b04 <system_clock_init+0x104>
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    1b0c:	4a18      	ldr	r2, [pc, #96]	; (1b70 <system_clock_init+0x170>)
    1b0e:	2300      	movs	r3, #0
    1b10:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    1b12:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    1b14:	7293      	strb	r3, [r2, #10]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    1b16:	a901      	add	r1, sp, #4
    1b18:	2201      	movs	r2, #1
    1b1a:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
    1b1c:	704b      	strb	r3, [r1, #1]
#if SAML21
	config->source_clock       = GCLK_SOURCE_OSC16M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    1b1e:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    1b20:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    1b22:	2307      	movs	r3, #7
    1b24:	700b      	strb	r3, [r1, #0]
    1b26:	2000      	movs	r0, #0
    1b28:	4b0e      	ldr	r3, [pc, #56]	; (1b64 <system_clock_init+0x164>)
    1b2a:	4798      	blx	r3
    1b2c:	2000      	movs	r0, #0
    1b2e:	4b0e      	ldr	r3, [pc, #56]	; (1b68 <system_clock_init+0x168>)
    1b30:	4798      	blx	r3
#endif
}
    1b32:	b00f      	add	sp, #60	; 0x3c
    1b34:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1b36:	46c0      	nop			; (mov r8, r8)
    1b38:	40000800 	.word	0x40000800
    1b3c:	41004000 	.word	0x41004000
    1b40:	00001da9 	.word	0x00001da9
    1b44:	0000183d 	.word	0x0000183d
    1b48:	00001961 	.word	0x00001961
    1b4c:	0000ea60 	.word	0x0000ea60
    1b50:	20000074 	.word	0x20000074
    1b54:	000005b9 	.word	0x000005b9
    1b58:	000018f1 	.word	0x000018f1
    1b5c:	00001801 	.word	0x00001801
    1b60:	00001b75 	.word	0x00001b75
    1b64:	00001b99 	.word	0x00001b99
    1b68:	00001c4d 	.word	0x00001c4d
    1b6c:	00001d1d 	.word	0x00001d1d
    1b70:	40000400 	.word	0x40000400

00001b74 <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    1b74:	4b06      	ldr	r3, [pc, #24]	; (1b90 <system_gclk_init+0x1c>)
    1b76:	6999      	ldr	r1, [r3, #24]
    1b78:	2208      	movs	r2, #8
    1b7a:	430a      	orrs	r2, r1
    1b7c:	619a      	str	r2, [r3, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    1b7e:	2201      	movs	r2, #1
    1b80:	4b04      	ldr	r3, [pc, #16]	; (1b94 <system_gclk_init+0x20>)
    1b82:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    1b84:	1c19      	adds	r1, r3, #0
    1b86:	780b      	ldrb	r3, [r1, #0]
    1b88:	4213      	tst	r3, r2
    1b8a:	d1fc      	bne.n	1b86 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    1b8c:	4770      	bx	lr
    1b8e:	46c0      	nop			; (mov r8, r8)
    1b90:	40000400 	.word	0x40000400
    1b94:	40000c00 	.word	0x40000c00

00001b98 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    1b98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1b9a:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    1b9c:	1c07      	adds	r7, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    1b9e:	780d      	ldrb	r5, [r1, #0]
    1ba0:	022d      	lsls	r5, r5, #8
    1ba2:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    1ba4:	784b      	ldrb	r3, [r1, #1]
    1ba6:	2b00      	cmp	r3, #0
    1ba8:	d002      	beq.n	1bb0 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    1baa:	2380      	movs	r3, #128	; 0x80
    1bac:	02db      	lsls	r3, r3, #11
    1bae:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    1bb0:	7a4b      	ldrb	r3, [r1, #9]
    1bb2:	2b00      	cmp	r3, #0
    1bb4:	d002      	beq.n	1bbc <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    1bb6:	2380      	movs	r3, #128	; 0x80
    1bb8:	031b      	lsls	r3, r3, #12
    1bba:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    1bbc:	684c      	ldr	r4, [r1, #4]
    1bbe:	2c01      	cmp	r4, #1
    1bc0:	d917      	bls.n	1bf2 <system_gclk_gen_set_config+0x5a>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    1bc2:	1e63      	subs	r3, r4, #1
    1bc4:	421c      	tst	r4, r3
    1bc6:	d10f      	bne.n	1be8 <system_gclk_gen_set_config+0x50>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    1bc8:	2c02      	cmp	r4, #2
    1bca:	d906      	bls.n	1bda <system_gclk_gen_set_config+0x42>
    1bcc:	2302      	movs	r3, #2
    1bce:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    1bd0:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    1bd2:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    1bd4:	429c      	cmp	r4, r3
    1bd6:	d8fb      	bhi.n	1bd0 <system_gclk_gen_set_config+0x38>
    1bd8:	e000      	b.n	1bdc <system_gclk_gen_set_config+0x44>
    1bda:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    1bdc:	0217      	lsls	r7, r2, #8
    1bde:	4337      	orrs	r7, r6
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    1be0:	2380      	movs	r3, #128	; 0x80
    1be2:	035b      	lsls	r3, r3, #13
    1be4:	431d      	orrs	r5, r3
    1be6:	e004      	b.n	1bf2 <system_gclk_gen_set_config+0x5a>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    1be8:	0227      	lsls	r7, r4, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    1bea:	4337      	orrs	r7, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    1bec:	2380      	movs	r3, #128	; 0x80
    1bee:	029b      	lsls	r3, r3, #10
    1bf0:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    1bf2:	7a0b      	ldrb	r3, [r1, #8]
    1bf4:	2b00      	cmp	r3, #0
    1bf6:	d002      	beq.n	1bfe <system_gclk_gen_set_config+0x66>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    1bf8:	2380      	movs	r3, #128	; 0x80
    1bfa:	039b      	lsls	r3, r3, #14
    1bfc:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1bfe:	4a0f      	ldr	r2, [pc, #60]	; (1c3c <system_gclk_gen_set_config+0xa4>)
    1c00:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
    1c02:	b25b      	sxtb	r3, r3
    1c04:	2b00      	cmp	r3, #0
    1c06:	dbfb      	blt.n	1c00 <system_gclk_gen_set_config+0x68>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1c08:	4b0d      	ldr	r3, [pc, #52]	; (1c40 <system_gclk_gen_set_config+0xa8>)
    1c0a:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1c0c:	4b0d      	ldr	r3, [pc, #52]	; (1c44 <system_gclk_gen_set_config+0xac>)
    1c0e:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1c10:	4a0a      	ldr	r2, [pc, #40]	; (1c3c <system_gclk_gen_set_config+0xa4>)
    1c12:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    1c14:	b25b      	sxtb	r3, r3
    1c16:	2b00      	cmp	r3, #0
    1c18:	dbfb      	blt.n	1c12 <system_gclk_gen_set_config+0x7a>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    1c1a:	4b08      	ldr	r3, [pc, #32]	; (1c3c <system_gclk_gen_set_config+0xa4>)
    1c1c:	609f      	str	r7, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1c1e:	1c1a      	adds	r2, r3, #0
    1c20:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
    1c22:	b25b      	sxtb	r3, r3
    1c24:	2b00      	cmp	r3, #0
    1c26:	dbfb      	blt.n	1c20 <system_gclk_gen_set_config+0x88>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    1c28:	4b04      	ldr	r3, [pc, #16]	; (1c3c <system_gclk_gen_set_config+0xa4>)
    1c2a:	6859      	ldr	r1, [r3, #4]
    1c2c:	2280      	movs	r2, #128	; 0x80
    1c2e:	0252      	lsls	r2, r2, #9
    1c30:	400a      	ands	r2, r1
    1c32:	4315      	orrs	r5, r2
    1c34:	605d      	str	r5, [r3, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1c36:	4b04      	ldr	r3, [pc, #16]	; (1c48 <system_gclk_gen_set_config+0xb0>)
    1c38:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1c3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1c3c:	40000c00 	.word	0x40000c00
    1c40:	000016a5 	.word	0x000016a5
    1c44:	40000c08 	.word	0x40000c08
    1c48:	000016e5 	.word	0x000016e5

00001c4c <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    1c4c:	b510      	push	{r4, lr}
    1c4e:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1c50:	4a0b      	ldr	r2, [pc, #44]	; (1c80 <system_gclk_gen_enable+0x34>)
    1c52:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    1c54:	b25b      	sxtb	r3, r3
    1c56:	2b00      	cmp	r3, #0
    1c58:	dbfb      	blt.n	1c52 <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1c5a:	4b0a      	ldr	r3, [pc, #40]	; (1c84 <system_gclk_gen_enable+0x38>)
    1c5c:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1c5e:	4b0a      	ldr	r3, [pc, #40]	; (1c88 <system_gclk_gen_enable+0x3c>)
    1c60:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1c62:	4a07      	ldr	r2, [pc, #28]	; (1c80 <system_gclk_gen_enable+0x34>)
    1c64:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    1c66:	b25b      	sxtb	r3, r3
    1c68:	2b00      	cmp	r3, #0
    1c6a:	dbfb      	blt.n	1c64 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    1c6c:	4b04      	ldr	r3, [pc, #16]	; (1c80 <system_gclk_gen_enable+0x34>)
    1c6e:	6859      	ldr	r1, [r3, #4]
    1c70:	2280      	movs	r2, #128	; 0x80
    1c72:	0252      	lsls	r2, r2, #9
    1c74:	430a      	orrs	r2, r1
    1c76:	605a      	str	r2, [r3, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1c78:	4b04      	ldr	r3, [pc, #16]	; (1c8c <system_gclk_gen_enable+0x40>)
    1c7a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1c7c:	bd10      	pop	{r4, pc}
    1c7e:	46c0      	nop			; (mov r8, r8)
    1c80:	40000c00 	.word	0x40000c00
    1c84:	000016a5 	.word	0x000016a5
    1c88:	40000c04 	.word	0x40000c04
    1c8c:	000016e5 	.word	0x000016e5

00001c90 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    1c90:	b570      	push	{r4, r5, r6, lr}
    1c92:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1c94:	4a1a      	ldr	r2, [pc, #104]	; (1d00 <system_gclk_gen_get_hz+0x70>)
    1c96:	7853      	ldrb	r3, [r2, #1]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    1c98:	b25b      	sxtb	r3, r3
    1c9a:	2b00      	cmp	r3, #0
    1c9c:	dbfb      	blt.n	1c96 <system_gclk_gen_get_hz+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1c9e:	4b19      	ldr	r3, [pc, #100]	; (1d04 <system_gclk_gen_get_hz+0x74>)
    1ca0:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1ca2:	4b19      	ldr	r3, [pc, #100]	; (1d08 <system_gclk_gen_get_hz+0x78>)
    1ca4:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1ca6:	4a16      	ldr	r2, [pc, #88]	; (1d00 <system_gclk_gen_get_hz+0x70>)
    1ca8:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    1caa:	b25b      	sxtb	r3, r3
    1cac:	2b00      	cmp	r3, #0
    1cae:	dbfb      	blt.n	1ca8 <system_gclk_gen_get_hz+0x18>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    1cb0:	4e13      	ldr	r6, [pc, #76]	; (1d00 <system_gclk_gen_get_hz+0x70>)
    1cb2:	6870      	ldr	r0, [r6, #4]
    1cb4:	04c0      	lsls	r0, r0, #19
    1cb6:	0ec0      	lsrs	r0, r0, #27
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    1cb8:	4b14      	ldr	r3, [pc, #80]	; (1d0c <system_gclk_gen_get_hz+0x7c>)
    1cba:	4798      	blx	r3
    1cbc:	1c05      	adds	r5, r0, #0
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    1cbe:	4b12      	ldr	r3, [pc, #72]	; (1d08 <system_gclk_gen_get_hz+0x78>)
    1cc0:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    1cc2:	6876      	ldr	r6, [r6, #4]
    1cc4:	02f6      	lsls	r6, r6, #11
    1cc6:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    1cc8:	4b11      	ldr	r3, [pc, #68]	; (1d10 <system_gclk_gen_get_hz+0x80>)
    1cca:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    1ccc:	4a0c      	ldr	r2, [pc, #48]	; (1d00 <system_gclk_gen_get_hz+0x70>)
    1cce:	7853      	ldrb	r3, [r2, #1]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
	while (system_gclk_is_syncing()) {
    1cd0:	b25b      	sxtb	r3, r3
    1cd2:	2b00      	cmp	r3, #0
    1cd4:	dbfb      	blt.n	1cce <system_gclk_gen_get_hz+0x3e>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    1cd6:	4b0a      	ldr	r3, [pc, #40]	; (1d00 <system_gclk_gen_get_hz+0x70>)
    1cd8:	689c      	ldr	r4, [r3, #8]
    1cda:	0a24      	lsrs	r4, r4, #8
    1cdc:	b2a4      	uxth	r4, r4
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1cde:	4b0d      	ldr	r3, [pc, #52]	; (1d14 <system_gclk_gen_get_hz+0x84>)
    1ce0:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    1ce2:	2e00      	cmp	r6, #0
    1ce4:	d107      	bne.n	1cf6 <system_gclk_gen_get_hz+0x66>
    1ce6:	2c01      	cmp	r4, #1
    1ce8:	d907      	bls.n	1cfa <system_gclk_gen_get_hz+0x6a>
		gen_input_hz /= divider;
    1cea:	1c28      	adds	r0, r5, #0
    1cec:	1c21      	adds	r1, r4, #0
    1cee:	4b0a      	ldr	r3, [pc, #40]	; (1d18 <system_gclk_gen_get_hz+0x88>)
    1cf0:	4798      	blx	r3
    1cf2:	1c05      	adds	r5, r0, #0
    1cf4:	e001      	b.n	1cfa <system_gclk_gen_get_hz+0x6a>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    1cf6:	3401      	adds	r4, #1
    1cf8:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
    1cfa:	1c28      	adds	r0, r5, #0
    1cfc:	bd70      	pop	{r4, r5, r6, pc}
    1cfe:	46c0      	nop			; (mov r8, r8)
    1d00:	40000c00 	.word	0x40000c00
    1d04:	000016a5 	.word	0x000016a5
    1d08:	40000c04 	.word	0x40000c04
    1d0c:	00001771 	.word	0x00001771
    1d10:	40000c08 	.word	0x40000c08
    1d14:	000016e5 	.word	0x000016e5
    1d18:	000022c5 	.word	0x000022c5

00001d1c <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    1d1c:	b510      	push	{r4, lr}
    1d1e:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1d20:	4b06      	ldr	r3, [pc, #24]	; (1d3c <system_gclk_chan_enable+0x20>)
    1d22:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1d24:	4b06      	ldr	r3, [pc, #24]	; (1d40 <system_gclk_chan_enable+0x24>)
    1d26:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    1d28:	4b06      	ldr	r3, [pc, #24]	; (1d44 <system_gclk_chan_enable+0x28>)
    1d2a:	8859      	ldrh	r1, [r3, #2]
    1d2c:	2280      	movs	r2, #128	; 0x80
    1d2e:	01d2      	lsls	r2, r2, #7
    1d30:	430a      	orrs	r2, r1
    1d32:	805a      	strh	r2, [r3, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1d34:	4b04      	ldr	r3, [pc, #16]	; (1d48 <system_gclk_chan_enable+0x2c>)
    1d36:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1d38:	bd10      	pop	{r4, pc}
    1d3a:	46c0      	nop			; (mov r8, r8)
    1d3c:	000016a5 	.word	0x000016a5
    1d40:	40000c02 	.word	0x40000c02
    1d44:	40000c00 	.word	0x40000c00
    1d48:	000016e5 	.word	0x000016e5

00001d4c <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    1d4c:	b510      	push	{r4, lr}
    1d4e:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1d50:	4b0f      	ldr	r3, [pc, #60]	; (1d90 <system_gclk_chan_disable+0x44>)
    1d52:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1d54:	4b0f      	ldr	r3, [pc, #60]	; (1d94 <system_gclk_chan_disable+0x48>)
    1d56:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    1d58:	4b0f      	ldr	r3, [pc, #60]	; (1d98 <system_gclk_chan_disable+0x4c>)
    1d5a:	8858      	ldrh	r0, [r3, #2]
    1d5c:	0500      	lsls	r0, r0, #20
    1d5e:	0f00      	lsrs	r0, r0, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    1d60:	8859      	ldrh	r1, [r3, #2]
    1d62:	4a0e      	ldr	r2, [pc, #56]	; (1d9c <system_gclk_chan_disable+0x50>)
    1d64:	400a      	ands	r2, r1
    1d66:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    1d68:	8859      	ldrh	r1, [r3, #2]
    1d6a:	4a0d      	ldr	r2, [pc, #52]	; (1da0 <system_gclk_chan_disable+0x54>)
    1d6c:	400a      	ands	r2, r1
    1d6e:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    1d70:	1c19      	adds	r1, r3, #0
    1d72:	2280      	movs	r2, #128	; 0x80
    1d74:	01d2      	lsls	r2, r2, #7
    1d76:	884b      	ldrh	r3, [r1, #2]
    1d78:	4213      	tst	r3, r2
    1d7a:	d1fc      	bne.n	1d76 <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    1d7c:	4b06      	ldr	r3, [pc, #24]	; (1d98 <system_gclk_chan_disable+0x4c>)
    1d7e:	0201      	lsls	r1, r0, #8
    1d80:	8858      	ldrh	r0, [r3, #2]
    1d82:	4a06      	ldr	r2, [pc, #24]	; (1d9c <system_gclk_chan_disable+0x50>)
    1d84:	4002      	ands	r2, r0
    1d86:	430a      	orrs	r2, r1
    1d88:	805a      	strh	r2, [r3, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1d8a:	4b06      	ldr	r3, [pc, #24]	; (1da4 <system_gclk_chan_disable+0x58>)
    1d8c:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    1d8e:	bd10      	pop	{r4, pc}
    1d90:	000016a5 	.word	0x000016a5
    1d94:	40000c02 	.word	0x40000c02
    1d98:	40000c00 	.word	0x40000c00
    1d9c:	fffff0ff 	.word	0xfffff0ff
    1da0:	ffffbfff 	.word	0xffffbfff
    1da4:	000016e5 	.word	0x000016e5

00001da8 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    1da8:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    1daa:	780c      	ldrb	r4, [r1, #0]
    1dac:	0224      	lsls	r4, r4, #8
    1dae:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    1db0:	4b02      	ldr	r3, [pc, #8]	; (1dbc <system_gclk_chan_set_config+0x14>)
    1db2:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    1db4:	b2a4      	uxth	r4, r4
    1db6:	4b02      	ldr	r3, [pc, #8]	; (1dc0 <system_gclk_chan_set_config+0x18>)
    1db8:	805c      	strh	r4, [r3, #2]
}
    1dba:	bd10      	pop	{r4, pc}
    1dbc:	00001d4d 	.word	0x00001d4d
    1dc0:	40000c00 	.word	0x40000c00

00001dc4 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    1dc4:	b510      	push	{r4, lr}
    1dc6:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1dc8:	4b06      	ldr	r3, [pc, #24]	; (1de4 <system_gclk_chan_get_hz+0x20>)
    1dca:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    1dcc:	4b06      	ldr	r3, [pc, #24]	; (1de8 <system_gclk_chan_get_hz+0x24>)
    1dce:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    1dd0:	4b06      	ldr	r3, [pc, #24]	; (1dec <system_gclk_chan_get_hz+0x28>)
    1dd2:	885c      	ldrh	r4, [r3, #2]
    1dd4:	0524      	lsls	r4, r4, #20
    1dd6:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1dd8:	4b05      	ldr	r3, [pc, #20]	; (1df0 <system_gclk_chan_get_hz+0x2c>)
    1dda:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    1ddc:	1c20      	adds	r0, r4, #0
    1dde:	4b05      	ldr	r3, [pc, #20]	; (1df4 <system_gclk_chan_get_hz+0x30>)
    1de0:	4798      	blx	r3
}
    1de2:	bd10      	pop	{r4, pc}
    1de4:	000016a5 	.word	0x000016a5
    1de8:	40000c02 	.word	0x40000c02
    1dec:	40000c00 	.word	0x40000c00
    1df0:	000016e5 	.word	0x000016e5
    1df4:	00001c91 	.word	0x00001c91

00001df8 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    1df8:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    1dfa:	78d3      	ldrb	r3, [r2, #3]
    1dfc:	2b00      	cmp	r3, #0
    1dfe:	d11e      	bne.n	1e3e <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    1e00:	7813      	ldrb	r3, [r2, #0]
    1e02:	2b80      	cmp	r3, #128	; 0x80
    1e04:	d004      	beq.n	1e10 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    1e06:	061b      	lsls	r3, r3, #24
    1e08:	2480      	movs	r4, #128	; 0x80
    1e0a:	0264      	lsls	r4, r4, #9
    1e0c:	4323      	orrs	r3, r4
    1e0e:	e000      	b.n	1e12 <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    1e10:	2300      	movs	r3, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    1e12:	7854      	ldrb	r4, [r2, #1]
    1e14:	2502      	movs	r5, #2
    1e16:	43ac      	bics	r4, r5
    1e18:	d10a      	bne.n	1e30 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    1e1a:	7894      	ldrb	r4, [r2, #2]
    1e1c:	2c00      	cmp	r4, #0
    1e1e:	d103      	bne.n	1e28 <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    1e20:	2480      	movs	r4, #128	; 0x80
    1e22:	02a4      	lsls	r4, r4, #10
    1e24:	4323      	orrs	r3, r4
    1e26:	e002      	b.n	1e2e <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    1e28:	24c0      	movs	r4, #192	; 0xc0
    1e2a:	02e4      	lsls	r4, r4, #11
    1e2c:	4323      	orrs	r3, r4
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    1e2e:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    1e30:	7854      	ldrb	r4, [r2, #1]
    1e32:	3c01      	subs	r4, #1
    1e34:	2c01      	cmp	r4, #1
    1e36:	d804      	bhi.n	1e42 <_system_pinmux_config+0x4a>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pullup if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    1e38:	4c11      	ldr	r4, [pc, #68]	; (1e80 <_system_pinmux_config+0x88>)
    1e3a:	4023      	ands	r3, r4
    1e3c:	e001      	b.n	1e42 <_system_pinmux_config+0x4a>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    1e3e:	6041      	str	r1, [r0, #4]
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    1e40:	2300      	movs	r3, #0
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    1e42:	040d      	lsls	r5, r1, #16
    1e44:	0c2d      	lsrs	r5, r5, #16
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1e46:	24a0      	movs	r4, #160	; 0xa0
    1e48:	05e4      	lsls	r4, r4, #23
    1e4a:	432c      	orrs	r4, r5
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    1e4c:	431c      	orrs	r4, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1e4e:	6284      	str	r4, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    1e50:	0c0d      	lsrs	r5, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1e52:	24d0      	movs	r4, #208	; 0xd0
    1e54:	0624      	lsls	r4, r4, #24
    1e56:	432c      	orrs	r4, r5
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    1e58:	431c      	orrs	r4, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    1e5a:	6284      	str	r4, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    1e5c:	78d4      	ldrb	r4, [r2, #3]
    1e5e:	2c00      	cmp	r4, #0
    1e60:	d10c      	bne.n	1e7c <_system_pinmux_config+0x84>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    1e62:	035c      	lsls	r4, r3, #13
    1e64:	d505      	bpl.n	1e72 <_system_pinmux_config+0x7a>
			/* Set the OUT register bits to enable the pullup if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    1e66:	7893      	ldrb	r3, [r2, #2]
    1e68:	2b01      	cmp	r3, #1
    1e6a:	d101      	bne.n	1e70 <_system_pinmux_config+0x78>
				port->OUTSET.reg = pin_mask;
    1e6c:	6181      	str	r1, [r0, #24]
    1e6e:	e000      	b.n	1e72 <_system_pinmux_config+0x7a>
			} else {
				port->OUTCLR.reg = pin_mask;
    1e70:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    1e72:	7853      	ldrb	r3, [r2, #1]
    1e74:	3b01      	subs	r3, #1
    1e76:	2b01      	cmp	r3, #1
    1e78:	d800      	bhi.n	1e7c <_system_pinmux_config+0x84>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    1e7a:	6081      	str	r1, [r0, #8]
		}
	}
}
    1e7c:	bd30      	pop	{r4, r5, pc}
    1e7e:	46c0      	nop			; (mov r8, r8)
    1e80:	fffbffff 	.word	0xfffbffff

00001e84 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    1e84:	b508      	push	{r3, lr}
    1e86:	1c03      	adds	r3, r0, #0
    1e88:	1c0a      	adds	r2, r1, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1e8a:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    1e8c:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports. */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1e8e:	2900      	cmp	r1, #0
    1e90:	d103      	bne.n	1e9a <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
    1e92:	0958      	lsrs	r0, r3, #5
    1e94:	01c0      	lsls	r0, r0, #7
    1e96:	4904      	ldr	r1, [pc, #16]	; (1ea8 <system_pinmux_pin_set_config+0x24>)
    1e98:	1840      	adds	r0, r0, r1
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    1e9a:	211f      	movs	r1, #31
    1e9c:	400b      	ands	r3, r1
    1e9e:	2101      	movs	r1, #1
    1ea0:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
    1ea2:	4b02      	ldr	r3, [pc, #8]	; (1eac <system_pinmux_pin_set_config+0x28>)
    1ea4:	4798      	blx	r3
}
    1ea6:	bd08      	pop	{r3, pc}
    1ea8:	41004400 	.word	0x41004400
    1eac:	00001df9 	.word	0x00001df9

00001eb0 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    1eb0:	4770      	bx	lr
    1eb2:	46c0      	nop			; (mov r8, r8)

00001eb4 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    1eb4:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    1eb6:	4b04      	ldr	r3, [pc, #16]	; (1ec8 <system_init+0x14>)
    1eb8:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    1eba:	4b04      	ldr	r3, [pc, #16]	; (1ecc <system_init+0x18>)
    1ebc:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    1ebe:	4b04      	ldr	r3, [pc, #16]	; (1ed0 <system_init+0x1c>)
    1ec0:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    1ec2:	4b04      	ldr	r3, [pc, #16]	; (1ed4 <system_init+0x20>)
    1ec4:	4798      	blx	r3
}
    1ec6:	bd08      	pop	{r3, pc}
    1ec8:	00001a01 	.word	0x00001a01
    1ecc:	00001715 	.word	0x00001715
    1ed0:	00001eb1 	.word	0x00001eb1
    1ed4:	00001eb1 	.word	0x00001eb1

00001ed8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    1ed8:	e7fe      	b.n	1ed8 <Dummy_Handler>
    1eda:	46c0      	nop			; (mov r8, r8)

00001edc <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    1edc:	b570      	push	{r4, r5, r6, lr}
        uint32_t *pSrc, *pDest;

        /* Change default QOS values to have the best performance and correct USB behavior */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    1ede:	2102      	movs	r1, #2
    1ee0:	2390      	movs	r3, #144	; 0x90
    1ee2:	005b      	lsls	r3, r3, #1
    1ee4:	4a28      	ldr	r2, [pc, #160]	; (1f88 <Reset_Handler+0xac>)
    1ee6:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    1ee8:	4b28      	ldr	r3, [pc, #160]	; (1f8c <Reset_Handler+0xb0>)
    1eea:	78d8      	ldrb	r0, [r3, #3]
    1eec:	2103      	movs	r1, #3
    1eee:	4388      	bics	r0, r1
    1ef0:	2202      	movs	r2, #2
    1ef2:	4310      	orrs	r0, r2
    1ef4:	70d8      	strb	r0, [r3, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    1ef6:	78dd      	ldrb	r5, [r3, #3]
    1ef8:	240c      	movs	r4, #12
    1efa:	43a5      	bics	r5, r4
    1efc:	2008      	movs	r0, #8
    1efe:	4305      	orrs	r5, r0
    1f00:	70dd      	strb	r5, [r3, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    1f02:	4b23      	ldr	r3, [pc, #140]	; (1f90 <Reset_Handler+0xb4>)
    1f04:	7b9e      	ldrb	r6, [r3, #14]
    1f06:	2530      	movs	r5, #48	; 0x30
    1f08:	43ae      	bics	r6, r5
    1f0a:	2520      	movs	r5, #32
    1f0c:	4335      	orrs	r5, r6
    1f0e:	739d      	strb	r5, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    1f10:	7b9d      	ldrb	r5, [r3, #14]
    1f12:	43a5      	bics	r5, r4
    1f14:	4328      	orrs	r0, r5
    1f16:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    1f18:	7b98      	ldrb	r0, [r3, #14]
    1f1a:	4388      	bics	r0, r1
    1f1c:	4302      	orrs	r2, r0
    1f1e:	739a      	strb	r2, [r3, #14]

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    1f20:	4b1c      	ldr	r3, [pc, #112]	; (1f94 <Reset_Handler+0xb8>)
    1f22:	4a1d      	ldr	r2, [pc, #116]	; (1f98 <Reset_Handler+0xbc>)
    1f24:	429a      	cmp	r2, r3
    1f26:	d003      	beq.n	1f30 <Reset_Handler+0x54>
                for (; pDest < &_erelocate;) {
    1f28:	4b1c      	ldr	r3, [pc, #112]	; (1f9c <Reset_Handler+0xc0>)
    1f2a:	4a1a      	ldr	r2, [pc, #104]	; (1f94 <Reset_Handler+0xb8>)
    1f2c:	429a      	cmp	r2, r3
    1f2e:	d304      	bcc.n	1f3a <Reset_Handler+0x5e>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    1f30:	4b1b      	ldr	r3, [pc, #108]	; (1fa0 <Reset_Handler+0xc4>)
    1f32:	4a1c      	ldr	r2, [pc, #112]	; (1fa4 <Reset_Handler+0xc8>)
    1f34:	429a      	cmp	r2, r3
    1f36:	d310      	bcc.n	1f5a <Reset_Handler+0x7e>
    1f38:	e01b      	b.n	1f72 <Reset_Handler+0x96>
    1f3a:	4b1b      	ldr	r3, [pc, #108]	; (1fa8 <Reset_Handler+0xcc>)
    1f3c:	4817      	ldr	r0, [pc, #92]	; (1f9c <Reset_Handler+0xc0>)
    1f3e:	3003      	adds	r0, #3
    1f40:	1ac0      	subs	r0, r0, r3
    1f42:	0880      	lsrs	r0, r0, #2
    1f44:	3001      	adds	r0, #1
    1f46:	0080      	lsls	r0, r0, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    1f48:	2300      	movs	r3, #0
                        *pDest++ = *pSrc++;
    1f4a:	4912      	ldr	r1, [pc, #72]	; (1f94 <Reset_Handler+0xb8>)
    1f4c:	4a12      	ldr	r2, [pc, #72]	; (1f98 <Reset_Handler+0xbc>)
    1f4e:	58d4      	ldr	r4, [r2, r3]
    1f50:	50cc      	str	r4, [r1, r3]
    1f52:	3304      	adds	r3, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    1f54:	4283      	cmp	r3, r0
    1f56:	d1fa      	bne.n	1f4e <Reset_Handler+0x72>
    1f58:	e7ea      	b.n	1f30 <Reset_Handler+0x54>
    1f5a:	4b12      	ldr	r3, [pc, #72]	; (1fa4 <Reset_Handler+0xc8>)
    1f5c:	1d1a      	adds	r2, r3, #4
    1f5e:	4910      	ldr	r1, [pc, #64]	; (1fa0 <Reset_Handler+0xc4>)
    1f60:	3103      	adds	r1, #3
    1f62:	1a89      	subs	r1, r1, r2
    1f64:	0889      	lsrs	r1, r1, #2
    1f66:	0089      	lsls	r1, r1, #2
    1f68:	1852      	adds	r2, r2, r1
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
                *pDest++ = 0;
    1f6a:	2100      	movs	r1, #0
    1f6c:	c302      	stmia	r3!, {r1}
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    1f6e:	4293      	cmp	r3, r2
    1f70:	d1fc      	bne.n	1f6c <Reset_Handler+0x90>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    1f72:	4b0e      	ldr	r3, [pc, #56]	; (1fac <Reset_Handler+0xd0>)
    1f74:	217f      	movs	r1, #127	; 0x7f
    1f76:	4a0e      	ldr	r2, [pc, #56]	; (1fb0 <Reset_Handler+0xd4>)
    1f78:	438a      	bics	r2, r1
    1f7a:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
        __libc_init_array();
    1f7c:	4b0d      	ldr	r3, [pc, #52]	; (1fb4 <Reset_Handler+0xd8>)
    1f7e:	4798      	blx	r3

        /* Branch to main function */
        main();
    1f80:	4b0d      	ldr	r3, [pc, #52]	; (1fb8 <Reset_Handler+0xdc>)
    1f82:	4798      	blx	r3
    1f84:	e7fe      	b.n	1f84 <Reset_Handler+0xa8>
    1f86:	46c0      	nop			; (mov r8, r8)
    1f88:	41007000 	.word	0x41007000
    1f8c:	41005000 	.word	0x41005000
    1f90:	41004800 	.word	0x41004800
    1f94:	20000000 	.word	0x20000000
    1f98:	000026dc 	.word	0x000026dc
    1f9c:	2000001c 	.word	0x2000001c
    1fa0:	20000150 	.word	0x20000150
    1fa4:	2000001c 	.word	0x2000001c
    1fa8:	20000004 	.word	0x20000004
    1fac:	e000ed00 	.word	0xe000ed00
    1fb0:	00000000 	.word	0x00000000
    1fb4:	00002365 	.word	0x00002365
    1fb8:	000021c1 	.word	0x000021c1

00001fbc <Config_LCD>:
	REG_TC5_COUNT8_CC1= 26*ContrastValue;
}
/************************************************************************/
/* Initializes LCD, Contrast, and Builds some required symbols          */
/************************************************************************/
void Config_LCD(void){
    1fbc:	b510      	push	{r4, lr}
	//Config_Contrast_PWM();	//not needed for OLED, since no contrast pin
	//LCD_Init();
	LCD_Init();
    1fbe:	4b07      	ldr	r3, [pc, #28]	; (1fdc <Config_LCD+0x20>)
    1fc0:	4798      	blx	r3
	LCD_CursorOff();
    1fc2:	4b07      	ldr	r3, [pc, #28]	; (1fe0 <Config_LCD+0x24>)
    1fc4:	4798      	blx	r3
	//Build symbol in LCD's CGRAM to be used later on
	LCD_build(0, framelement);	//build '||' symbol at location 0, used to draw frame
    1fc6:	2000      	movs	r0, #0
    1fc8:	4906      	ldr	r1, [pc, #24]	; (1fe4 <Config_LCD+0x28>)
    1fca:	4c07      	ldr	r4, [pc, #28]	; (1fe8 <Config_LCD+0x2c>)
    1fcc:	47a0      	blx	r4
	LCD_build(1, PILOGO);		//build Polltech LOGO at location 1
    1fce:	2001      	movs	r0, #1
    1fd0:	4906      	ldr	r1, [pc, #24]	; (1fec <Config_LCD+0x30>)
    1fd2:	47a0      	blx	r4
	LCD_build(2,DegreeSym);
    1fd4:	2002      	movs	r0, #2
    1fd6:	4906      	ldr	r1, [pc, #24]	; (1ff0 <Config_LCD+0x34>)
    1fd8:	47a0      	blx	r4
}
    1fda:	bd10      	pop	{r4, pc}
    1fdc:	00000e49 	.word	0x00000e49
    1fe0:	00000df5 	.word	0x00000df5
    1fe4:	20000004 	.word	0x20000004
    1fe8:	00000d55 	.word	0x00000d55
    1fec:	2000000c 	.word	0x2000000c
    1ff0:	20000014 	.word	0x20000014

00001ff4 <Disp_IntroLcdMsgs>:

void Disp_IntroLcdMsgs(void){
    1ff4:	b570      	push	{r4, r5, r6, lr}
	LCD_PowerOff();
    1ff6:	4b16      	ldr	r3, [pc, #88]	; (2050 <STACK_SIZE+0x50>)
    1ff8:	4798      	blx	r3
	LCD_Frame1();			//make good looking frame around LCD
    1ffa:	4b16      	ldr	r3, [pc, #88]	; (2054 <STACK_SIZE+0x54>)
    1ffc:	4798      	blx	r3
	LCD_Setcursor(1,9);
    1ffe:	2001      	movs	r0, #1
    2000:	2109      	movs	r1, #9
    2002:	4c15      	ldr	r4, [pc, #84]	; (2058 <STACK_SIZE+0x58>)
    2004:	47a0      	blx	r4
	LCD_Print("   ");
    2006:	4815      	ldr	r0, [pc, #84]	; (205c <STACK_SIZE+0x5c>)
    2008:	4d15      	ldr	r5, [pc, #84]	; (2060 <STACK_SIZE+0x60>)
    200a:	47a8      	blx	r5
	LCD_Setcursor(1,10);
    200c:	2001      	movs	r0, #1
    200e:	210a      	movs	r1, #10
    2010:	47a0      	blx	r4
	LCD_DataWrite(1);		//prints polltech logo that is stored at location 1
    2012:	2001      	movs	r0, #1
    2014:	4b13      	ldr	r3, [pc, #76]	; (2064 <STACK_SIZE+0x64>)
    2016:	4798      	blx	r3
	LCD_Setcursor(2,7);
    2018:	2002      	movs	r0, #2
    201a:	2107      	movs	r1, #7
    201c:	47a0      	blx	r4
	LCD_Print("Polltech    ");
    201e:	4812      	ldr	r0, [pc, #72]	; (2068 <STACK_SIZE+0x68>)
    2020:	47a8      	blx	r5
	LCD_Setcursor(3,6);
    2022:	2003      	movs	r0, #3
    2024:	2106      	movs	r1, #6
    2026:	47a0      	blx	r4
	LCD_Print("Instruments   ");
    2028:	4810      	ldr	r0, [pc, #64]	; (206c <STACK_SIZE+0x6c>)
    202a:	47a8      	blx	r5
	LCD_PowerOn();
    202c:	4b10      	ldr	r3, [pc, #64]	; (2070 <STACK_SIZE+0x70>)
    202e:	4798      	blx	r3
	delay_sec(1);
    2030:	2001      	movs	r0, #1
    2032:	4e10      	ldr	r6, [pc, #64]	; (2074 <STACK_SIZE+0x74>)
    2034:	47b0      	blx	r6
	LCD_Setcursor(2,2);
    2036:	2002      	movs	r0, #2
    2038:	2102      	movs	r1, #2
    203a:	47a0      	blx	r4
	LCD_Print("StackMonitoringKit");
    203c:	480e      	ldr	r0, [pc, #56]	; (2078 <STACK_SIZE+0x78>)
    203e:	47a8      	blx	r5
	LCD_Setcursor(3,2);
    2040:	2003      	movs	r0, #3
    2042:	2102      	movs	r1, #2
    2044:	47a0      	blx	r4
	LCD_Print(" Model PEM-SMK 20 ");
    2046:	480d      	ldr	r0, [pc, #52]	; (207c <STACK_SIZE+0x7c>)
    2048:	47a8      	blx	r5
	
	delay_sec(1);
    204a:	2001      	movs	r0, #1
    204c:	47b0      	blx	r6
}
    204e:	bd70      	pop	{r4, r5, r6, pc}
    2050:	00000e19 	.word	0x00000e19
    2054:	00000d81 	.word	0x00000d81
    2058:	00000c79 	.word	0x00000c79
    205c:	00002530 	.word	0x00002530
    2060:	00000c1d 	.word	0x00000c1d
    2064:	00000be9 	.word	0x00000be9
    2068:	00002534 	.word	0x00002534
    206c:	00002544 	.word	0x00002544
    2070:	00000e31 	.word	0x00000e31
    2074:	00000f95 	.word	0x00000f95
    2078:	00002554 	.word	0x00002554
    207c:	00002568 	.word	0x00002568

00002080 <DoCalibration>:
					"                    ");
	WaitFor(EnterKey);
}


void DoCalibration(){
    2080:	b510      	push	{r4, lr}
	int8_t selected=0;
	LCD_CursorOff();
    2082:	4b09      	ldr	r3, [pc, #36]	; (20a8 <DoCalibration+0x28>)
    2084:	4798      	blx	r3
	selected =LCD_MenuHandle(MenuSize(CalibrationMenu),CalibrationMenu);
    2086:	200a      	movs	r0, #10
    2088:	4908      	ldr	r1, [pc, #32]	; (20ac <DoCalibration+0x2c>)
    208a:	4b09      	ldr	r3, [pc, #36]	; (20b0 <DoCalibration+0x30>)
    208c:	4798      	blx	r3
	
	switch(selected){
    208e:	b240      	sxtb	r0, r0
    2090:	2801      	cmp	r0, #1
    2092:	d108      	bne.n	20a6 <DoCalibration+0x26>
		case 1:
			LCD_FullDisp(	"  Calibration of:   ",
    2094:	4807      	ldr	r0, [pc, #28]	; (20b4 <DoCalibration+0x34>)
    2096:	4908      	ldr	r1, [pc, #32]	; (20b8 <DoCalibration+0x38>)
    2098:	4a08      	ldr	r2, [pc, #32]	; (20bc <DoCalibration+0x3c>)
    209a:	4b09      	ldr	r3, [pc, #36]	; (20c0 <DoCalibration+0x40>)
    209c:	4c09      	ldr	r4, [pc, #36]	; (20c4 <DoCalibration+0x44>)
    209e:	47a0      	blx	r4
			" Absolute Pressure  ",
			"Scan / Edit /Execute",
			"                    ");
			delay_sec(1);
    20a0:	2001      	movs	r0, #1
    20a2:	4b09      	ldr	r3, [pc, #36]	; (20c8 <DoCalibration+0x48>)
    20a4:	4798      	blx	r3
	}
	
}
    20a6:	bd10      	pop	{r4, pc}
    20a8:	00000df5 	.word	0x00000df5
    20ac:	00002468 	.word	0x00002468
    20b0:	00001041 	.word	0x00001041
    20b4:	0000262c 	.word	0x0000262c
    20b8:	00002644 	.word	0x00002644
    20bc:	0000265c 	.word	0x0000265c
    20c0:	000025f4 	.word	0x000025f4
    20c4:	00000cbd 	.word	0x00000cbd
    20c8:	00000f95 	.word	0x00000f95

000020cc <CalibrationModeChk>:


void CalibrationModeChk(){	//chk for key combo and password
    20cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    20ce:	b083      	sub	sp, #12
	//check if key combo is pressed and proceed with calibration
	int32_t EnteredPass=0;
if (KeyDetected())
    20d0:	4b28      	ldr	r3, [pc, #160]	; (2174 <CalibrationModeChk+0xa8>)
    20d2:	4798      	blx	r3
    20d4:	2800      	cmp	r0, #0
    20d6:	d04b      	beq.n	2170 <CalibrationModeChk+0xa4>
{ //chk for key combo is any key press is detected
	KeyscanWORelese();
    20d8:	4b27      	ldr	r3, [pc, #156]	; (2178 <CalibrationModeChk+0xac>)
    20da:	4798      	blx	r3
if ((ParaKey&&UpdateKey)&&!(RunKey||StopKey||StartKey||EnterKey)) //enter cal only when para and update key is pressed
    20dc:	4b27      	ldr	r3, [pc, #156]	; (217c <CalibrationModeChk+0xb0>)
    20de:	781b      	ldrb	r3, [r3, #0]
    20e0:	2b00      	cmp	r3, #0
    20e2:	d045      	beq.n	2170 <CalibrationModeChk+0xa4>
    20e4:	4b26      	ldr	r3, [pc, #152]	; (2180 <CalibrationModeChk+0xb4>)
    20e6:	781b      	ldrb	r3, [r3, #0]
    20e8:	2b00      	cmp	r3, #0
    20ea:	d041      	beq.n	2170 <CalibrationModeChk+0xa4>
    20ec:	4b25      	ldr	r3, [pc, #148]	; (2184 <CalibrationModeChk+0xb8>)
    20ee:	781b      	ldrb	r3, [r3, #0]
    20f0:	2b00      	cmp	r3, #0
    20f2:	d13d      	bne.n	2170 <CalibrationModeChk+0xa4>
    20f4:	4b24      	ldr	r3, [pc, #144]	; (2188 <CalibrationModeChk+0xbc>)
    20f6:	781b      	ldrb	r3, [r3, #0]
    20f8:	2b00      	cmp	r3, #0
    20fa:	d139      	bne.n	2170 <CalibrationModeChk+0xa4>
    20fc:	4b23      	ldr	r3, [pc, #140]	; (218c <CalibrationModeChk+0xc0>)
    20fe:	781b      	ldrb	r3, [r3, #0]
    2100:	2b00      	cmp	r3, #0
    2102:	d135      	bne.n	2170 <CalibrationModeChk+0xa4>
    2104:	4b22      	ldr	r3, [pc, #136]	; (2190 <CalibrationModeChk+0xc4>)
    2106:	781b      	ldrb	r3, [r3, #0]
    2108:	2b00      	cmp	r3, #0
    210a:	d131      	bne.n	2170 <CalibrationModeChk+0xa4>
{	//calibration key combination  detected
	
	LCD_Clrscr();
    210c:	4b21      	ldr	r3, [pc, #132]	; (2194 <CalibrationModeChk+0xc8>)
    210e:	4798      	blx	r3
	LCD_OneLine(1,"  Calibration Mode  ");
    2110:	2001      	movs	r0, #1
    2112:	4921      	ldr	r1, [pc, #132]	; (2198 <CalibrationModeChk+0xcc>)
    2114:	4b21      	ldr	r3, [pc, #132]	; (219c <CalibrationModeChk+0xd0>)
    2116:	4798      	blx	r3
	//wait for key combo to be released
	Release(ParaKey||UpdateKey);
    2118:	4d21      	ldr	r5, [pc, #132]	; (21a0 <CalibrationModeChk+0xd4>)
    211a:	4c18      	ldr	r4, [pc, #96]	; (217c <CalibrationModeChk+0xb0>)
    211c:	4e18      	ldr	r6, [pc, #96]	; (2180 <CalibrationModeChk+0xb4>)
    211e:	47a8      	blx	r5
    2120:	7823      	ldrb	r3, [r4, #0]
    2122:	2b00      	cmp	r3, #0
    2124:	d1fb      	bne.n	211e <CalibrationModeChk+0x52>
    2126:	7833      	ldrb	r3, [r6, #0]
    2128:	2b00      	cmp	r3, #0
    212a:	d1f8      	bne.n	211e <CalibrationModeChk+0x52>
	do
	{
		LCD_FullDisp(	"  Calibration Mode  ",
    212c:	4f1a      	ldr	r7, [pc, #104]	; (2198 <CalibrationModeChk+0xcc>)
    212e:	4e1d      	ldr	r6, [pc, #116]	; (21a4 <CalibrationModeChk+0xd8>)
    2130:	4c1d      	ldr	r4, [pc, #116]	; (21a8 <CalibrationModeChk+0xdc>)
    2132:	1c38      	adds	r0, r7, #0
    2134:	1c31      	adds	r1, r6, #0
    2136:	1c22      	adds	r2, r4, #0
    2138:	1c23      	adds	r3, r4, #0
    213a:	4d1c      	ldr	r5, [pc, #112]	; (21ac <CalibrationModeChk+0xe0>)
    213c:	47a8      	blx	r5
						"   Enter Password   ",
						  LCD_BLANK_LINE_MACRO,
						  LCD_BLANK_LINE_MACRO);
		
		EnteredPass=GetNumDataFromUserWithESC(0,0,7,3,8);
    213e:	2308      	movs	r3, #8
    2140:	9300      	str	r3, [sp, #0]
    2142:	2000      	movs	r0, #0
    2144:	2100      	movs	r1, #0
    2146:	2207      	movs	r2, #7
    2148:	2303      	movs	r3, #3
    214a:	4d19      	ldr	r5, [pc, #100]	; (21b0 <CalibrationModeChk+0xe4>)
    214c:	47a8      	blx	r5
		if (EnteredPass==-1)	//-1 is just  used to check when esc key is pressed
    214e:	1c43      	adds	r3, r0, #1
    2150:	d00e      	beq.n	2170 <CalibrationModeChk+0xa4>
		{
			return;			//exit cal mode if para/ESC key is pressed
		}
		
		else if (EnteredPass!=Passw)
    2152:	2801      	cmp	r0, #1
    2154:	d00a      	beq.n	216c <CalibrationModeChk+0xa0>
		{
			LCD_OneLine(4,"   Wrong Password!! ");
    2156:	2004      	movs	r0, #4
    2158:	4916      	ldr	r1, [pc, #88]	; (21b4 <CalibrationModeChk+0xe8>)
    215a:	4d10      	ldr	r5, [pc, #64]	; (219c <CalibrationModeChk+0xd0>)
    215c:	47a8      	blx	r5
			delay_sec(1);
    215e:	2001      	movs	r0, #1
    2160:	4b15      	ldr	r3, [pc, #84]	; (21b8 <CalibrationModeChk+0xec>)
    2162:	4798      	blx	r3
			LCD_OneLine(4,LCD_BLANK_LINE_MACRO);
    2164:	2004      	movs	r0, #4
    2166:	4910      	ldr	r1, [pc, #64]	; (21a8 <CalibrationModeChk+0xdc>)
    2168:	47a8      	blx	r5
    216a:	e7e2      	b.n	2132 <CalibrationModeChk+0x66>
		}
	}while(EnteredPass!=Passw);
		
	if (EnteredPass==Passw)
		DoCalibration();
    216c:	4b13      	ldr	r3, [pc, #76]	; (21bc <CalibrationModeChk+0xf0>)
    216e:	4798      	blx	r3

}	//if (keycombo chk) close brac
}	//if (keydetect) close brac
}	//function close brac
    2170:	b003      	add	sp, #12
    2172:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2174:	0000132d 	.word	0x0000132d
    2178:	00001461 	.word	0x00001461
    217c:	20000089 	.word	0x20000089
    2180:	20000088 	.word	0x20000088
    2184:	2000008a 	.word	0x2000008a
    2188:	2000008d 	.word	0x2000008d
    218c:	2000008c 	.word	0x2000008c
    2190:	2000008b 	.word	0x2000008b
    2194:	00000e05 	.word	0x00000e05
    2198:	00002674 	.word	0x00002674
    219c:	00000cfd 	.word	0x00000cfd
    21a0:	00001369 	.word	0x00001369
    21a4:	0000268c 	.word	0x0000268c
    21a8:	000025f4 	.word	0x000025f4
    21ac:	00000cbd 	.word	0x00000cbd
    21b0:	000006cd 	.word	0x000006cd
    21b4:	000026a4 	.word	0x000026a4
    21b8:	00000f95 	.word	0x00000f95
    21bc:	00002081 	.word	0x00002081

000021c0 <main>:



int main (void)
{
    21c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    21c2:	b087      	sub	sp, #28
	system_init();
    21c4:	4b2a      	ldr	r3, [pc, #168]	; (2270 <main+0xb0>)
    21c6:	4798      	blx	r3
	
	Config_MatrixKeypad();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
    21c8:	4b2a      	ldr	r3, [pc, #168]	; (2274 <main+0xb4>)
    21ca:	4798      	blx	r3
	#ifndef BypassLCD
	Config_LCD();	
    21cc:	4b2a      	ldr	r3, [pc, #168]	; (2278 <main+0xb8>)
    21ce:	4798      	blx	r3
	configure_EEPROM();
    21d0:	4b2a      	ldr	r3, [pc, #168]	; (227c <main+0xbc>)
    21d2:	4798      	blx	r3
	CalibrationModeChk();
    21d4:	4b2a      	ldr	r3, [pc, #168]	; (2280 <main+0xc0>)
    21d6:	4798      	blx	r3
	Disp_IntroLcdMsgs();	//Display company name, model name 
    21d8:	4b2a      	ldr	r3, [pc, #168]	; (2284 <main+0xc4>)
    21da:	4798      	blx	r3
	
//	DoAutoZero();
	LCD_Clrscr();
    21dc:	4b2a      	ldr	r3, [pc, #168]	; (2288 <main+0xc8>)
    21de:	4798      	blx	r3
	#endif
	LCD_Setcursor(3,20);
    21e0:	2003      	movs	r0, #3
    21e2:	2114      	movs	r1, #20
    21e4:	4d29      	ldr	r5, [pc, #164]	; (228c <main+0xcc>)
    21e6:	47a8      	blx	r5
	LCD_DataWrite(ARROW);
    21e8:	207f      	movs	r0, #127	; 0x7f
    21ea:	4b29      	ldr	r3, [pc, #164]	; (2290 <main+0xd0>)
    21ec:	4798      	blx	r3
	
	LCD_Setcursor(1,1);
    21ee:	2001      	movs	r0, #1
    21f0:	2101      	movs	r1, #1
    21f2:	47a8      	blx	r5

//	LCD_CursorOn();
	LCD_FullDisp(	"  Calibration of:   ",
    21f4:	4827      	ldr	r0, [pc, #156]	; (2294 <main+0xd4>)
    21f6:	4928      	ldr	r1, [pc, #160]	; (2298 <main+0xd8>)
    21f8:	4a28      	ldr	r2, [pc, #160]	; (229c <main+0xdc>)
    21fa:	4b29      	ldr	r3, [pc, #164]	; (22a0 <main+0xe0>)
    21fc:	4c29      	ldr	r4, [pc, #164]	; (22a4 <main+0xe4>)
    21fe:	47a0      	blx	r4
	//"    Yes   /   No    ",
	//LCD_BLANK_LINE_MACRO);
	//LCD_Frame2();
						
	
volatile uint8_t selected=0;
    2200:	466c      	mov	r4, sp
    2202:	2600      	movs	r6, #0
    2204:	75e6      	strb	r6, [r4, #23]
	selected =LCD_HorizontalScroll(1, 3,1,3,8,3,14);
    2206:	2308      	movs	r3, #8
    2208:	9300      	str	r3, [sp, #0]
    220a:	2303      	movs	r3, #3
    220c:	9301      	str	r3, [sp, #4]
    220e:	230e      	movs	r3, #14
    2210:	9302      	str	r3, [sp, #8]
    2212:	2001      	movs	r0, #1
    2214:	2103      	movs	r1, #3
    2216:	2201      	movs	r2, #1
    2218:	2303      	movs	r3, #3
    221a:	4f23      	ldr	r7, [pc, #140]	; (22a8 <main+0xe8>)
    221c:	47b8      	blx	r7
    221e:	75e0      	strb	r0, [r4, #23]
//	selected =LCD_MenuHandle(MenuSize(CalibrationMenu),CalibrationMenu);
//	LCD_FullDisp(MSG[0],MSG[1],MSG[2],MSG[3]);
//	LCD_FullDisp(CalibrationMenu[0],CalibrationMenu[1],CalibrationMenu[2],CalibrationMenu[3]);
//	LCD_MenuDisplay(CalibrationMenu, 4);
	
	LCD_Setcursor(1,2);
    2220:	2001      	movs	r0, #1
    2222:	2102      	movs	r1, #2
    2224:	47a8      	blx	r5
	LCD_CursorOn();
    2226:	4b21      	ldr	r3, [pc, #132]	; (22ac <main+0xec>)
    2228:	4798      	blx	r3
	LCD_DispAscii(selected);
    222a:	7de0      	ldrb	r0, [r4, #23]
    222c:	b2c0      	uxtb	r0, r0
    222e:	4b20      	ldr	r3, [pc, #128]	; (22b0 <main+0xf0>)
    2230:	4798      	blx	r3
//	LCD_DispVariable(12345,2,10,0,1);

	Ambient_PT100.STDvalue=10021;
    2232:	4a20      	ldr	r2, [pc, #128]	; (22b4 <main+0xf4>)
    2234:	4b20      	ldr	r3, [pc, #128]	; (22b8 <main+0xf8>)
    2236:	831a      	strh	r2, [r3, #24]
	uint32_t ans=GetNumDataFromUser(32768,2,7,1,10);	
    2238:	240a      	movs	r4, #10
    223a:	9400      	str	r4, [sp, #0]
    223c:	2080      	movs	r0, #128	; 0x80
    223e:	0200      	lsls	r0, r0, #8
    2240:	2102      	movs	r1, #2
    2242:	2207      	movs	r2, #7
    2244:	2301      	movs	r3, #1
    2246:	4d1d      	ldr	r5, [pc, #116]	; (22bc <main+0xfc>)
    2248:	47a8      	blx	r5
	LCD_DispVariable(ans, 2, 7, 3, 10);
    224a:	9400      	str	r4, [sp, #0]
    224c:	2102      	movs	r1, #2
    224e:	2207      	movs	r2, #7
    2250:	2303      	movs	r3, #3
    2252:	4c1b      	ldr	r4, [pc, #108]	; (22c0 <main+0x100>)
    2254:	47a0      	blx	r4
	volatile uint8_t a,b,c,d;

	a=EE_MISCAddr(c);
    2256:	466b      	mov	r3, sp
    2258:	759e      	strb	r6, [r3, #22]
	b=EE_CALAddr(EE_OrifPart_Z);
    225a:	220b      	movs	r2, #11
    225c:	466b      	mov	r3, sp
    225e:	755a      	strb	r2, [r3, #21]
	c=EE_CALAddr(EE_AuxTemp_STDUP);
    2260:	2249      	movs	r2, #73	; 0x49
    2262:	ab05      	add	r3, sp, #20
    2264:	701a      	strb	r2, [r3, #0]
	d=EE_CALAddr(EE_Abs_ADCLOW);
    2266:	2223      	movs	r2, #35	; 0x23
    2268:	466b      	mov	r3, sp
    226a:	74da      	strb	r2, [r3, #19]
    226c:	e7fe      	b.n	226c <main+0xac>
    226e:	46c0      	nop			; (mov r8, r8)
    2270:	00001eb5 	.word	0x00001eb5
    2274:	000012d1 	.word	0x000012d1
    2278:	00001fbd 	.word	0x00001fbd
    227c:	000002cd 	.word	0x000002cd
    2280:	000020cd 	.word	0x000020cd
    2284:	00001ff5 	.word	0x00001ff5
    2288:	00000e05 	.word	0x00000e05
    228c:	00000c79 	.word	0x00000c79
    2290:	00000be9 	.word	0x00000be9
    2294:	0000262c 	.word	0x0000262c
    2298:	00002644 	.word	0x00002644
    229c:	0000265c 	.word	0x0000265c
    22a0:	000025f4 	.word	0x000025f4
    22a4:	00000cbd 	.word	0x00000cbd
    22a8:	000011e1 	.word	0x000011e1
    22ac:	00000de5 	.word	0x00000de5
    22b0:	00000c39 	.word	0x00000c39
    22b4:	00002725 	.word	0x00002725
    22b8:	200000ac 	.word	0x200000ac
    22bc:	00000539 	.word	0x00000539
    22c0:	000003e1 	.word	0x000003e1

000022c4 <__aeabi_uidiv>:
    22c4:	2900      	cmp	r1, #0
    22c6:	d034      	beq.n	2332 <.udivsi3_skip_div0_test+0x6a>

000022c8 <.udivsi3_skip_div0_test>:
    22c8:	2301      	movs	r3, #1
    22ca:	2200      	movs	r2, #0
    22cc:	b410      	push	{r4}
    22ce:	4288      	cmp	r0, r1
    22d0:	d32c      	bcc.n	232c <.udivsi3_skip_div0_test+0x64>
    22d2:	2401      	movs	r4, #1
    22d4:	0724      	lsls	r4, r4, #28
    22d6:	42a1      	cmp	r1, r4
    22d8:	d204      	bcs.n	22e4 <.udivsi3_skip_div0_test+0x1c>
    22da:	4281      	cmp	r1, r0
    22dc:	d202      	bcs.n	22e4 <.udivsi3_skip_div0_test+0x1c>
    22de:	0109      	lsls	r1, r1, #4
    22e0:	011b      	lsls	r3, r3, #4
    22e2:	e7f8      	b.n	22d6 <.udivsi3_skip_div0_test+0xe>
    22e4:	00e4      	lsls	r4, r4, #3
    22e6:	42a1      	cmp	r1, r4
    22e8:	d204      	bcs.n	22f4 <.udivsi3_skip_div0_test+0x2c>
    22ea:	4281      	cmp	r1, r0
    22ec:	d202      	bcs.n	22f4 <.udivsi3_skip_div0_test+0x2c>
    22ee:	0049      	lsls	r1, r1, #1
    22f0:	005b      	lsls	r3, r3, #1
    22f2:	e7f8      	b.n	22e6 <.udivsi3_skip_div0_test+0x1e>
    22f4:	4288      	cmp	r0, r1
    22f6:	d301      	bcc.n	22fc <.udivsi3_skip_div0_test+0x34>
    22f8:	1a40      	subs	r0, r0, r1
    22fa:	431a      	orrs	r2, r3
    22fc:	084c      	lsrs	r4, r1, #1
    22fe:	42a0      	cmp	r0, r4
    2300:	d302      	bcc.n	2308 <.udivsi3_skip_div0_test+0x40>
    2302:	1b00      	subs	r0, r0, r4
    2304:	085c      	lsrs	r4, r3, #1
    2306:	4322      	orrs	r2, r4
    2308:	088c      	lsrs	r4, r1, #2
    230a:	42a0      	cmp	r0, r4
    230c:	d302      	bcc.n	2314 <.udivsi3_skip_div0_test+0x4c>
    230e:	1b00      	subs	r0, r0, r4
    2310:	089c      	lsrs	r4, r3, #2
    2312:	4322      	orrs	r2, r4
    2314:	08cc      	lsrs	r4, r1, #3
    2316:	42a0      	cmp	r0, r4
    2318:	d302      	bcc.n	2320 <.udivsi3_skip_div0_test+0x58>
    231a:	1b00      	subs	r0, r0, r4
    231c:	08dc      	lsrs	r4, r3, #3
    231e:	4322      	orrs	r2, r4
    2320:	2800      	cmp	r0, #0
    2322:	d003      	beq.n	232c <.udivsi3_skip_div0_test+0x64>
    2324:	091b      	lsrs	r3, r3, #4
    2326:	d001      	beq.n	232c <.udivsi3_skip_div0_test+0x64>
    2328:	0909      	lsrs	r1, r1, #4
    232a:	e7e3      	b.n	22f4 <.udivsi3_skip_div0_test+0x2c>
    232c:	1c10      	adds	r0, r2, #0
    232e:	bc10      	pop	{r4}
    2330:	4770      	bx	lr
    2332:	2800      	cmp	r0, #0
    2334:	d001      	beq.n	233a <.udivsi3_skip_div0_test+0x72>
    2336:	2000      	movs	r0, #0
    2338:	43c0      	mvns	r0, r0
    233a:	b407      	push	{r0, r1, r2}
    233c:	4802      	ldr	r0, [pc, #8]	; (2348 <.udivsi3_skip_div0_test+0x80>)
    233e:	a102      	add	r1, pc, #8	; (adr r1, 2348 <.udivsi3_skip_div0_test+0x80>)
    2340:	1840      	adds	r0, r0, r1
    2342:	9002      	str	r0, [sp, #8]
    2344:	bd03      	pop	{r0, r1, pc}
    2346:	46c0      	nop			; (mov r8, r8)
    2348:	00000019 	.word	0x00000019

0000234c <__aeabi_uidivmod>:
    234c:	2900      	cmp	r1, #0
    234e:	d0f0      	beq.n	2332 <.udivsi3_skip_div0_test+0x6a>
    2350:	b503      	push	{r0, r1, lr}
    2352:	f7ff ffb9 	bl	22c8 <.udivsi3_skip_div0_test>
    2356:	bc0e      	pop	{r1, r2, r3}
    2358:	4342      	muls	r2, r0
    235a:	1a89      	subs	r1, r1, r2
    235c:	4718      	bx	r3
    235e:	46c0      	nop			; (mov r8, r8)

00002360 <__aeabi_idiv0>:
    2360:	4770      	bx	lr
    2362:	46c0      	nop			; (mov r8, r8)

00002364 <__libc_init_array>:
    2364:	b570      	push	{r4, r5, r6, lr}
    2366:	4b0e      	ldr	r3, [pc, #56]	; (23a0 <__libc_init_array+0x3c>)
    2368:	4d0e      	ldr	r5, [pc, #56]	; (23a4 <__libc_init_array+0x40>)
    236a:	2400      	movs	r4, #0
    236c:	1aed      	subs	r5, r5, r3
    236e:	10ad      	asrs	r5, r5, #2
    2370:	1c1e      	adds	r6, r3, #0
    2372:	42ac      	cmp	r4, r5
    2374:	d004      	beq.n	2380 <__libc_init_array+0x1c>
    2376:	00a3      	lsls	r3, r4, #2
    2378:	58f3      	ldr	r3, [r6, r3]
    237a:	4798      	blx	r3
    237c:	3401      	adds	r4, #1
    237e:	e7f8      	b.n	2372 <__libc_init_array+0xe>
    2380:	f000 f99c 	bl	26bc <_init>
    2384:	4b08      	ldr	r3, [pc, #32]	; (23a8 <__libc_init_array+0x44>)
    2386:	4d09      	ldr	r5, [pc, #36]	; (23ac <__libc_init_array+0x48>)
    2388:	2400      	movs	r4, #0
    238a:	1aed      	subs	r5, r5, r3
    238c:	10ad      	asrs	r5, r5, #2
    238e:	1c1e      	adds	r6, r3, #0
    2390:	42ac      	cmp	r4, r5
    2392:	d004      	beq.n	239e <__libc_init_array+0x3a>
    2394:	00a3      	lsls	r3, r4, #2
    2396:	58f3      	ldr	r3, [r6, r3]
    2398:	4798      	blx	r3
    239a:	3401      	adds	r4, #1
    239c:	e7f8      	b.n	2390 <__libc_init_array+0x2c>
    239e:	bd70      	pop	{r4, r5, r6, pc}
    23a0:	000026c8 	.word	0x000026c8
    23a4:	000026c8 	.word	0x000026c8
    23a8:	000026c8 	.word	0x000026c8
    23ac:	000026cc 	.word	0x000026cc
    23b0:	42000800 	.word	0x42000800
    23b4:	42000c00 	.word	0x42000c00
    23b8:	42001000 	.word	0x42001000
    23bc:	42001400 	.word	0x42001400
    23c0:	42001800 	.word	0x42001800
    23c4:	42001c00 	.word	0x42001c00
    23c8:	3d3d3d3d 	.word	0x3d3d3d3d
    23cc:	3d3d3d3d 	.word	0x3d3d3d3d
    23d0:	3d3d3d3d 	.word	0x3d3d3d3d
    23d4:	3d3d3d3d 	.word	0x3d3d3d3d
    23d8:	00003d3d 	.word	0x00003d3d
    23dc:	2d2d2d2d 	.word	0x2d2d2d2d
    23e0:	2d2d2d2d 	.word	0x2d2d2d2d
    23e4:	2d2d2d2d 	.word	0x2d2d2d2d
    23e8:	2d2d2d2d 	.word	0x2d2d2d2d
    23ec:	2d2d2d2d 	.word	0x2d2d2d2d
    23f0:	00000000 	.word	0x00000000
    23f4:	5f5f5f5f 	.word	0x5f5f5f5f
    23f8:	5f5f5f5f 	.word	0x5f5f5f5f
    23fc:	5f5f5f5f 	.word	0x5f5f5f5f
    2400:	5f5f5f5f 	.word	0x5f5f5f5f
    2404:	5f5f5f5f 	.word	0x5f5f5f5f
    2408:	00000000 	.word	0x00000000
    240c:	3a677542 	.word	0x3a677542
    2410:	44434c20 	.word	0x44434c20
    2414:	726f485f 	.word	0x726f485f
    2418:	75437a69 	.word	0x75437a69
    241c:	00000072 	.word	0x00000072
    2420:	00001784 	.word	0x00001784
    2424:	000017e0 	.word	0x000017e0
    2428:	000017e0 	.word	0x000017e0
    242c:	0000177e 	.word	0x0000177e
    2430:	0000177e 	.word	0x0000177e
    2434:	0000179a 	.word	0x0000179a
    2438:	0000178a 	.word	0x0000178a
    243c:	000017a0 	.word	0x000017a0
    2440:	000017ce 	.word	0x000017ce
    2444:	0000198c 	.word	0x0000198c
    2448:	000019ec 	.word	0x000019ec
    244c:	000019ec 	.word	0x000019ec
    2450:	0000196c 	.word	0x0000196c
    2454:	0000197e 	.word	0x0000197e
    2458:	0000199a 	.word	0x0000199a
    245c:	00001970 	.word	0x00001970
    2460:	000019a8 	.word	0x000019a8
    2464:	000019dc 	.word	0x000019dc

00002468 <CalibrationMenu>:
    2468:	62412e31 756c6f73 50206574 73736572     1.Absolute Press
    2478:	00657275 61502e32 2e697472 69724f20     ure.2.Parti. Ori
    2488:	50442e66 00202020 61472e33 756f6573     f.DP   .3.Gaseou
    2498:	724f2073 442e6669 00202050 69502e34     s Orif.DP  .4.Pi
    24a8:	20746f74 20205044 20202020 00202020     tot DP         .
    24b8:	74532e35 206b6361 72656854 75436f6d     5.Stack ThermoCu
    24c8:	00202070 6d412e36 6e656962 65542074     p  .6.Ambient Te
    24d8:	202e706d 00202020 654d2e37 20726574     mp.    .7.Meter 
    24e8:	706d6554 2020202e 00202020 75412e38     Temp.      .8.Au
    24f8:	6c6c6978 20797261 706d6554 0020202e     xillary Temp.  .
    2508:	61502e39 63697472 74616c75 6c462065     9.Particulate Fl
    2518:	0020776f 472e3031 6f657361 46207375     ow .10.Gaseous F
    2528:	20776f6c 00202020 00202020 6c6c6f50     low    .   .Poll
    2538:	68636574 20202020 00000000 74736e49     tech    ....Inst
    2548:	656d7572 2073746e 00002020 63617453     ruments   ..Stac
    2558:	6e6f4d6b 726f7469 4b676e69 00007469     kMonitoringKit..
    2568:	646f4d20 50206c65 532d4d45 32204b4d      Model PEM-SMK 2
    2578:	00002030 61655220 66207964 4120726f     0 .. Ready for A
    2588:	2d6f7475 6f72655a 00000000 65654b28     uto-Zero....(Kee
    2598:	69502070 20626f74 2e737341 74754f20     p Pitob Ass. Out
    25a8:	00000000 61532026 696c706d 5020676e     ....& Sampling P
    25b8:	20706d75 2966664f 00000000 72502020     ump Off)....  Pr
    25c8:	20737365 65746e45 654b2072 20202079     ess Enter Key   
    25d8:	00000000 6f442020 20676e69 6f747541     ....  Doing Auto
    25e8:	72655a2d 2020206f 00000000 20202020     -Zero   ....    
    25f8:	20202020 20202020 20202020 20202020                     
    2608:	00000000 2d2d2d2d 00002d2d 41202020     ....------..   A
    2618:	2d6f7475 6f72655a 6e6f6420 20202065     uto-Zero done   
    2628:	00000000 61432020 7262696c 6f697461     ....  Calibratio
    2638:	666f206e 2020203a 00000000 73624120     n of:   .... Abs
    2648:	74756c6f 72502065 75737365 20206572     olute Pressure  
    2658:	00000000 6e616353 45202f20 20746964     ....Scan / Edit 
    2668:	6578452f 65747563 00000000 61432020     /Execute....  Ca
    2678:	7262696c 6f697461 6f4d206e 20206564     libration Mode  
    2688:	00000000 45202020 7265746e 73615020     ....   Enter Pas
    2698:	726f7773 20202064 00000000 57202020     sword   ....   W
    26a8:	676e6f72 73615020 726f7773 20212164     rong Password!! 
    26b8:	00000000                                ....

000026bc <_init>:
    26bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    26be:	46c0      	nop			; (mov r8, r8)
    26c0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    26c2:	bc08      	pop	{r3}
    26c4:	469e      	mov	lr, r3
    26c6:	4770      	bx	lr

000026c8 <__init_array_start>:
    26c8:	000000d9 	.word	0x000000d9

000026cc <_fini>:
    26cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    26ce:	46c0      	nop			; (mov r8, r8)
    26d0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    26d2:	bc08      	pop	{r3}
    26d4:	469e      	mov	lr, r3
    26d6:	4770      	bx	lr

000026d8 <__fini_array_start>:
    26d8:	000000b1 	.word	0x000000b1
